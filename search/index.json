[{"content":" LeetCode 1235. 规划兼职工作\n算法讲解083【必备】动态规划中用观察优化枚举的技巧-下\n思路 按照工作的结束时间进行排序，然后分别找出在前 n 个工作可以选择的情况下的最大利润，最后在所有利润中找到最大利润。\n求解过程 首先将所有数据组合成一个二维数组，然后按照结束时间进行排序。 定义一个 dp 表，dp[i] 表示在前 i 个工作中选择，可以获得的最大利润。 定义转移方程，如果我一定要做第 i 个工作，那么我获得第 i 份工作的利润，并且只能选择第 i 份工作开始时间之前结束的工作，求利润之和；如果我不选择第 i 份工作，那么我获得的利润就是前 i - 1 份工作之前可以赚取的最大值。 $$ \\begin{equation} \\begin{aligned} f(i) = \\begin{cases} f(i - 1) \\\\ profit_i + f(j) \\end{cases}\\\\ \\end{aligned} \\end{equation} $$\n$j$ 为结束时间小于等于 $startTime_i$ 的工作的最右侧索引，因为结束时间是有序的，所以可以使用二分查找快速查询。如果找不到，说明没有工作可以选择，之前的利润为 0。\n复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class Solution { public: int jobScheduling(vector\u0026lt;int\u0026gt;\u0026amp; startTime, vector\u0026lt;int\u0026gt;\u0026amp; endTime, vector\u0026lt;int\u0026gt;\u0026amp; profit) { int len = startTime.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; jobs(len, vector\u0026lt;int\u0026gt;(3)); for (int i = 0; i \u0026lt; len; i++) { jobs[i][0] = startTime[i]; jobs[i][1] = endTime[i]; jobs[i][2] = profit[i]; } sort(jobs.begin(), jobs.end(), [\u0026amp;](vector\u0026lt;int\u0026gt;\u0026amp; a, vector\u0026lt;int\u0026gt;\u0026amp; b) { return a[1] \u0026lt; b[1]; }); vector\u0026lt;int\u0026gt; dp(len); // 只有一个工作可以选择 dp[0] = jobs[0][2]; for (int i = 1, pos, pro; i \u0026lt; len; i++) { // 按照当前工作的开始时间进行查找 pos = find(jobs, jobs[i][0]); // 之前的利润 pro = pos == -1 ? 0 : dp[pos]; // 当前工作的利润 pro += jobs[i][2]; // 做和不做取最大值 dp[i] = max(dp[i - 1], pro); } return dp[len - 1]; } /* 递归版本：在前 i 个任务中选择，利润最大是多少 */ int f(int i, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; jobs, vector\u0026lt;int\u0026gt;\u0026amp; dp) { if (i \u0026lt; 0) { return 0; } if (i == 0) { return jobs[0][2]; } if (dp[i] != -1) { return dp[i]; } int startTime = jobs[i][0]; int endTime = jobs[i][1]; int profit = jobs[i][2]; int ans = f(i - 1, jobs, dp); int pos = find(jobs, startTime); ans = max(ans, profit + f(pos, jobs, dp)); dp[i] = ans; return ans; } // 按照结束时间查找，找到 \u0026lt;= endTime 的最大索引 int find(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; jobs, int target) { int left = 0, right = jobs.size() - 1, mid, ans = -1; while (left \u0026lt;= right) { mid = left + (right - left) / 2; if (jobs[mid][1] \u0026lt;= target) { ans = mid; left = mid + 1; } else { right = mid - 1; } } return ans; } } ","date":"2024-03-17T22:31:56+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-1235.-%E8%A7%84%E5%88%92%E5%85%BC%E8%81%8C%E5%B7%A5%E4%BD%9C/","title":"LeetCode 1235. 规划兼职工作"},{"content":" LeetCode 903. DI 序列的有效排列\n算法讲解082【必备】动态规划中用观察优化枚举的技巧-上\n思路 从尝试入手，要选对尝试的思路，如果一开始使用状态表示 0 - n 的数字，哪个被用了，哪个没用，使用一个整数表示，发现题目不允许，因为 n 的范围最大是 200，无法用状态压缩DP。再仔细思考，发现数字是什么不重要，前面已经用了哪些数字不重要，我们只需要知道，要形成上升或者下降序列，我们可以使用的数字有几个。\n求解过程 当我们来到 i 位置时，剩余的数字和上一个数字的关系是什么。也就是说我们需要知道有多少个数字是小于上一个数字，多少个数字是大于上一个数字的。又因为我们知道了位置，用了多少数字和总数字个数是知道的，所以我们只需要知道比上一个数字小的数字有多少个。\n定义子问题：来到了 i 位置，如果要形成下降序列，比 i - 1 位置小的数字有 less 个，我们可以枚举每一个数字作为 i 位置的数字，然后我们就可以得出下一个子问题的比 i 位置小的数字有多少个。\n同理，如果要形成上升序列，我们可以计算得到比 i - 1 位置大的数字有多少个 (n - i - less)，我们可以枚举每一个数字作为 i 位置的数字，然后得出下一个子问题的比 i 位置小的数字有多少个。\nbasecase: 当我们处于 0 位置，我们不知道上一个位置是上升和下降，所以我们假定上一个数字是正无穷，我们要形成一个下降序列，我们可以使用的比无穷大小的数字有 n 个。\n观察法优化\n当我们写出严格位置依赖的版本之后，它是 $n ^ 3$ 的时间复杂度。通过观察，我们发现 dp[i][less] 只依赖下一行的值。更细致地观察，更新第 i 行要么全部是上升，要么全部是下降，并且得到 dp[i][less] 只需要第 i + 1 行的左边或者右边连续的一段格子，那么我们就可以使用 dp[i][less] 左边和左下的格子不断进行更新，不用重复计算和。dp[i][less] 依赖 dp[i + 1][0 -\u0026gt; less - 1] 我们从左往右遍历，因为前一个格子已经加上过了，所以我们只需要再加上左下角的格子即可。\n同理，上升序列 dp[i][less] 依赖 dp[i + 1][less -\u0026gt; n - i - 1]，所以我们可以倒着遍历，计算当前格子时将右边和下边的格子即可。\n复杂度 时间复杂度：$O(n ^ 2)$ 空间复杂度：$O(n ^ 2)$ 代码 暴力递归版本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: const int mod = 1e9 + 7; int numPermsDISequence(string s) { int n = s.size(); return process(s, 0, n + 1, n + 1); } // 当前来到了 i 位置，比 i - 1 位置小的数字有 less 个 int process(const string\u0026amp; str, int i, int less, int n) { int ans = 0; if (i == n) { // 到达尾部，方案数 + 1 ans = 1; } else if (i == 0 || str[i - 1] == \u0026#39;D\u0026#39;) { // 要形成下降序列，0 之前假设有个无穷大 for (int nextLess = 0; nextLess \u0026lt; less; nextLess++) { ans = (ans + process(str, i + 1, nextLess, n)) % mod; } } else { // 要形成上升序列 for (int nextLess = less; nextLess \u0026lt; n - i; nextLess++) { ans = (ans + process(str, i + 1, nextLess, n)) % mod; } } return ans; } }; 严格位置依赖的动态规划，并且进行优化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: const int mod = 1e9 + 7; int numPermsDISequence(string s) { int n = s.size() + 1; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;int\u0026gt;(n + 1)); for (int less = 0; less \u0026lt;= n; less++) { dp[n][less] = 1; } for (int i = n - 1; i \u0026gt;= 0; i--) { // 要么上升，要么下降 if (i == 0 || s[i - 1] == \u0026#39;D\u0026#39;) { dp[i][1] = dp[i + 1][0]; for (int less = 2; less \u0026lt;= n; less++) { // 左边加左下格子 dp[i][less] = (dp[i][less - 1] + dp[i + 1][less - 1]) % mod; } } else { dp[i][n - i - 1] = dp[i + 1][n - i - 1]; for (int less = n -i - 2; less \u0026gt;= 0; less--) { // 右边格子加下边格子 dp[i][less] = (dp[i][less + 1] + dp[i + 1][less]) % mod; } } } return dp[0][n]; } } ","date":"2024-03-10T19:27:34+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-903.-di-%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%89%E6%95%88%E6%8E%92%E5%88%97/","title":"LeetCode 903. DI 序列的有效排列"},{"content":" LeetCode 309. 买卖股票的最佳时机含冷冻期\n算法讲解082【必备】动态规划中用观察优化枚举的技巧-上\n思路 跟带手续费的股票问题一样，使用一个数组表示已经完成冷静期的持有股票的状态，一个数组表示交易完成的状态。\n求解过程 使用两个数组：prepare 数组表示持有股票状态的最大当前余额，除此之外，还需要包含冷静期，也就是来到当前天时，已经过完冷静期了。done 数组表示交易完成的状态，可以完成无数次交易。\n$$ \\begin{aligned} g(i) \u0026amp;= max\\begin{cases} g(i-1), \u0026amp; 当天股票不参与交易\\\\ f(i-1) + pirces_i \u0026amp; 卖出当天的股票\n\\end{cases} \\\\ f(i) \u0026amp;= max\\begin{cases} f(i-1), \u0026amp; 不买入当天的股票，继续持有之前的\\\\ g(i-2) - pirces_i \u0026amp; 买入当天的股票，跳过之前的冷静期 \\end{cases} \\end{aligned} $$\nprepare[0] 和 prepaer[1] 表示第一次购买，如果第一天就完成了买卖交易，再加上冷静期，需要第3天才能买，所以不考虑。如果前两天必须要买一次，那么肯定买股价低的。\n前两天完成交易只能是第0天买第1天卖，所以收益最大为 0 或者 prices[1] - prices[0]\n因为有冷静期，更新 prepare 数组需要用到前 2 天的交易完成数据，所以在空间优化时需要额外注意一下，先用一个临时变量存储一下，防止被覆盖。\n复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); if (n \u0026lt; 2) { return 0; } // 完成一次购买，但是要扣掉冷静期的余额 int prepare = max(-prices[0], -prices[1]); int lastDone = 0; // 完成交易的最大利润 int curDone = max(0, prices[1] - prices[0]); for (int i = 2, temp; i \u0026lt; n; i++) { temp = curDone; curDone = max(curDone, prepare + prices[i]); prepare = max(prepare, lastDone - prices[i]); lastDone = temp; } return curDone; } }; ","date":"2024-03-10T16:06:20+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-309.-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/","title":"LeetCode 309. 买卖股票的最佳时机含冷冻期"},{"content":" LeetCode 714. 买卖股票的最佳时机含手续费\n算法讲解082【必备】动态规划中用观察优化枚举的技巧-上\n思路 每次交易都要扣除手续费，那我们可以在买的时候就将手续费提前扣除，当卖出股票时可以直接加上当天的股票价格。\n求解过程 定义两个数组：prepare 数组表示当天必须处于持有股票状态，也就是说必须买入当天的股票或者之前的股票，然后再扣去一次手续费。done 数组表示在当天或之前完成交易的最大利润，交易可以是无数次，可以卖出当天的股票或者是之前交易的最大利润。\n$$ \\begin{aligned} g(i) \u0026amp;= max\\begin{cases} g(i-1), \u0026amp; 当天股票不参与交易\\\\ f(i-1) + pirces_i \u0026amp; 卖出当天的股票\n\\end{cases} \\\\ f(i) \u0026amp;= max\\begin{cases} f(i-1), \u0026amp; 不买入当天的股票，继续持有之前的\\\\ g(i) - pirces_i - fee \u0026amp; 买入当天的股票 \\end{cases} \\end{aligned} $$\n空间优化\n因为数组在更新过程中只用到了前一个，因此可以使用滚动数组进行更新，降低空间复杂度。\n复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices, int fee) { int prepare = -prices[0] - fee; // 购买 i 位置的股票，自己当前的余额，提前交手续费 int done = 0; // 完成交易获得的最大利润 int n = prices.size(); for (int i = 1; i \u0026lt; n; i++) { // 如果卖出 i 位置的股票和不卖，取最大值 done = max(done, prepare + prices[i]); // 不买入当前股票，或者交易完成后，买入当前股票，求出最大余额 prepare = max(prepare, done - prices[i] - fee); } return done; } }; ","date":"2024-03-10T16:00:09+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-714.-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/","title":"LeetCode 714. 买卖股票的最佳时机含手续费"},{"content":" LeetCode 235. 二叉搜索树的最近公共祖先\n参考题解：数据结构和算法 - 二叉搜索树的最近公共祖先（3种解决方式）\n思路 从二叉树根节点开始查找，判断该节点是否在两个节点之间，如果是，那么该节点就是最近的公共祖先，如果不是，那么就继续向下找。\n求解过程 二叉搜索树的最重要的一个特性就是每一个节点，它大于所有的自己的左节点，小于所有的自己的右节点。如果某节点是两节点的公共祖先，那么该节点一定大于等于其中一个节点，且小于等于另一个节点（等于是因为可能就是二者之一）。\n所以从根节点开始查找，如果发现当前节点处于二者之间，则说明该节点是最近公共祖先，否则，这两个节点应该位于当前节点的其中一侧，然后向这侧继续查找。\n如何判断当前节点是否处于二者之间？如果是的，那么当前节点与二者之间的差值的符号应该不同，即 root-\u0026gt;val - p-\u0026gt;val 和 root-\u0026gt;val - q-\u0026gt;val 应该是异号的，或者其中之一为 0，那么二者的乘积应该是 \u0026lt;= 0 的，相反如果处于两侧，乘积应该是 \u0026gt; 0 的。\n如果当前节点处于二者的其中一侧，那么 root-\u0026gt;val 应该 大于二者或者小于二者（任意一个节点都是可以的）。如果 root-\u0026gt;val 大于二者，那么应该向左侧继续查找，否则去右侧继续查找。\n复杂度 时间复杂度：$O(log_2n)$ 空间复杂度：$O(1)$ 代码 1 2 3 4 5 6 7 8 9 10 class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { while ((long)(root-\u0026gt;val - p-\u0026gt;val) * (root-\u0026gt;val - q-\u0026gt;val) \u0026gt; 0) { // 如果当前节点在 p q 的同一侧 root = p-\u0026gt;val \u0026lt; root-\u0026gt;val ? root-\u0026gt;left : root-\u0026gt;right; } return root; } }; ","date":"2024-02-25T22:43:51+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-235.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","title":"LeetCode 235. 二叉搜索树的最近公共祖先"},{"content":" LeetCode 188. 买卖股票的最佳时机 IV\n算法讲解082【必备】动态规划中用观察优化枚举的技巧-上\n思路 根据前面几题的经验，使用一个二维 dp 表，记录下交易次数和范围的最大利润，遍历所有可能，得出交易 k 次，在整个数组范围内的最大利润。\n求解过程 当交易次数达到一定数量时，相当于无线次交易，可以使用之前的方式，抓取每一个上坡，得到最大利润。否则：\n定义一个 dp 表： dp[i][j] 表示交易 i 次，在 0 - j 范围上的最大利润，当我们来到第 i 次交易，范围 0 - j 时，如果最后一次交易没有发生在第 j 天，则 dp[i][j] = dp[i][j - 1]；如果最后一次交易发生在第 j 天，则倒数第二次交易可能发生在 0 - j 之间的每一天，所以遍历 0 - j ，找出利润最大的交易方案。\n$$ \\begin{equation} \\begin{aligned} f(i,j) = \\begin{cases} f(i, j - 1)\\\\ \\max(f(i-1, p) + prices_p) + prices_j \\end{cases} \\end{aligned} \\end{equation} $$\n$\\max(f(i-1, p) + prices_p)$ 可以提前处理得到，不用到时候全部遍历一遍。\n复杂度 时间复杂度：$O(n \\times k)$ 空间复杂度：$O(n \\times k)$ 空间复杂度可以优化成 $O(n)$，分析循环的依赖关系。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: int maxProfit(int k, vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); if (k \u0026gt;= n / 2) { return getMaxProfitWithoutLimit(prices); } // dp[i][j] 在 0 - j 范围内，交易 i 次的最大利润 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(k + 1, vector\u0026lt;int\u0026gt;(n)); // dp[...][0] 第 0 天，利润为 0 // dp[0][...] 交易 0 次，利润为 0 for (int i = 1; i \u0026lt;= k; i++) { int best = -prices[0]; for (int j = 1; j \u0026lt; n; j++) { // dp[i][j] = max(dp[i][j - 1], dp[i - 1][0] + prices[j] - prices[0]); dp[i][j] = max(dp[i][j - 1], best + prices[j]); best = max(best, dp[i - 1][j] - prices[j]); } } return dp[k][n - 1]; } int getMaxProfitWithoutLimit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); int ans = 0; for (int i = 1; i \u0026lt; n; i++) { if (prices[i] - prices[i - 1] \u0026gt; 0) { ans += prices[i] - prices[i - 1]; } } return ans; } }; 无枚举优化的版本，暴力搜索 i 次交易，0 - j 范围内的最大利润。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: int maxProfit(int k, vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); if (k \u0026gt;= n / 2) { return getMaxProfitWithoutLimit(prices); } // dp[i][j] 在 0 - j 范围内，交易 i 次的最大利润 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(k + 1, vector\u0026lt;int\u0026gt;(n)); // dp[...][0] 第 0 天，利润为 0 // dp[0][...] 交易 0 次，利润为 0 for (int i = 1; i \u0026lt;= k; i++) { for (int j = 1; j \u0026lt; n; j++) { dp[i][j] = max(dp[i][j - 1], dp[i - 1][0] + prices[j] - prices[0]); for (int p = 0; p \u0026lt; j; p++) { dp[i][j] = max(dp[i][j], dp[i - 1][p] + prices[j] - prices[p]); } } } return dp[k][n - 1]; } int getMaxProfitWithoutLimit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); int ans = 0; for (int i = 1; i \u0026lt; n; i++) { if (prices[i] - prices[i - 1] \u0026gt; 0) { ans += prices[i] - prices[i - 1]; } } return ans; } }; ","date":"2024-01-20T22:20:04+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-188.-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-iv/","title":"LeetCode 188. 买卖股票的最佳时机 IV"},{"content":" LeetCode 123. 买卖股票的最佳时机 III\n算法讲解082【必备】动态规划中用观察优化枚举的技巧-上\n思路 将两次股票交易分开来处理，遍历以每一天作为第二次股票卖出时得到的利润，然后的出最大利润。\n求解过程 使用一个 dp1 数组，记录 0 - i 范围内，交易一次股票所获得的最大利润，买入和卖出可以在 0 - i 的任意一天。\n使用一个 dp2 数组，记录下 0 - i 范围内，交易两次股票所获得的最大利润，卖出第二次股票必须在第 i 天。\n遍历每一天，作为第二次股票卖出的时间 j，然后遍历在开始和卖出股票的之间的每一天，作为第二次股票买入的时间 i，在这之间可以进行第一次股票交易。那么两次股票交易的总利润就等于 $dp2[j] = max(dp1[i] + prices[j] - prices[i])$ ，我们把含有 j 的提取出来就是 $dp2[j] = max(dp1[i] - prices[i]) + prices[j]$，而 dp1[i] - prices[i]) 我们不用每次遍历，可以使用一个数组 best 存储起来。\n因为 dp1 dp2 best 数组只用到了它的前一个位置的结果，所以我们可以使用滚动数组更新它，优化空间复杂度。\n复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); int dp1 = 0; // 0 - i 范围内交易一次获取的最大利润 int dp2 = 0; // 0 - i 范围内交易两次，且最后一次卖出交易为 i 的最大利润 int best; // best[i] 0 - i 范围内 dp1[i] - prices[i] 的最大值 best = -prices[0]; // dp1[0] - prices[0] == -prices[0]; int ans = 0; int minStock = prices[0]; for (int i = 1; i \u0026lt; n; i++) { // 0 天最大利润为 0 minStock = min(minStock, prices[i]); dp1 = max(dp1, prices[i] - minStock); best = max(best, dp1 - prices[i]); dp2 = best + prices[i]; ans = max(ans, dp2); } return ans; } }; 没有经过时间和空间优化的版本，就是最初的版本，无法通过全部用例，但是后面的优化基于此版本。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); vector\u0026lt;int\u0026gt; dp1(n); // 0 - i 范围内交易一次获取的最大利润 vector\u0026lt;int\u0026gt; dp2(n); // 0 - i 范围内交易两次，且最后一次交易为 i 的最大利润 int minStock = prices[0]; for (int i = 1; i \u0026lt; n; i++) { // 0 天最大利润为 0 minStock = min(minStock, prices[i]); dp1[i] = max(dp1[i - 1], prices[i] - minStock); } int ans = 0; for (int j = 1; j \u0026lt; n; j++) { // 0 天最大利润为 0 // 遍历每一个以 0 - i 范围内交易一次，i 第二次买入的最大利润 for (int i = 0; i \u0026lt;= j; i++) { dp2[j] = max(dp2[j], dp1[i] + prices[j] - prices[i]); } ans = max(ans, dp2[j]); } return ans; } }; ","date":"2024-01-20T22:19:49+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-123.-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-iii/","title":"LeetCode 123. 买卖股票的最佳时机 III"},{"content":" LeetCode 122. 买卖股票的最佳时机 II\n算法讲解082【必备】动态规划中用观察优化枚举的技巧-上\n思路 因为可以交易无限次，我们可以抓住每次股价上升的趋势，赚取所有的利润。一个连续上升的利润等同于拆分后每段的利润之和，所以我们只需要跟前一个位置的股价进行比较，如果利润为正就赚，否则赚 0。\n求解过程 遍历股价数组，将当前值与前一值比较，如果当前值较大，总利润增加，否则，总利润不变。\n复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 代码 1 2 3 4 5 6 7 8 9 10 class Solution { public int maxProfit(int[] prices) { int ans = 0; int n = prices.length; for (int i = 1; i \u0026lt; n; i++) { ans += Math.max(0, prices[i] - prices[i - 1]); } return ans; } } ","date":"2024-01-20T22:19:41+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-122.-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii/","title":"LeetCode 122. 买卖股票的最佳时机 II"},{"content":" LeetCode 121. 买卖股票的最佳时机\n算法讲解082【必备】动态规划中用观察优化枚举的技巧-上\n思路 根据题意，买卖不能再同一天，但是它又说，如果不能获得利润就返回 0。所以我们就可以理解为：买卖可以在同一天，返回交易一次的最大利润，如果不能获得利润，那么最大利润肯定为 0。所以我们求出每个位置减去至今位置遇到的最小值，得到的结果取最大就是最大利润。\n求解过程 使用一个变量记录至今遇到的最小值，每来到新的一天，用当前的股票价值计算出当前位置可能获得的最大利润，然后再与全局最大利润相比，更新全局最大利润。\n复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 代码 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int maxProfit(int[] prices) { int mi = prices[0]; int ans = 0; for (int p : prices) { ans = Math.max(ans, p - mi); mi = Math.min(mi, p); } return ans; } } ","date":"2024-01-20T22:18:52+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-121.-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/","title":"LeetCode 121. 买卖股票的最佳时机"},{"content":" LeetCode 1655. 分配重复整数\n算法讲解081【必备】状压dp-下\n思路 根据题意，如果一个数字的个数足够多，那么它可以满足多个订单，如果拆开来处理，维护状态就会变得很复杂，因此我们可以选择将订单进行组合，列举出所有组合，计算出它们需要的数字的个数。\n求解过程 为了让一个数字尽可能地满足更多订单，我们枚举该数字可以满足的所有订单组合，判断是否存在一种方案能够使所有订单都满足条件。\n预处理\n首先我们要求出数字的总个数。 其次我们要统计出每种数字的个数。（数字不重要，数字的个数才重要，我们只保留个数信息） 预处理出一个数组，它的每一个下标都是一种订单组合状态，求出每个状态所需的数字个数。 状态压缩\n我们使用一个整型变量表示订单是否被满足。1 代表没有满足；0 代表已满足。只有订单状态无法确定递归函数是否调用过，还需要数字个数的序号。例如当前来到了第 i 个数字个数，订单状态为 status，我们可以利用前面的数字个数来确定数字是如何分配的，这个状态是唯一的，也就相当于确定了递归函数的调用，下次遇到就不需要展开了。\n枚举子集\n递归展开过程中，需要枚举当前订单状态的所有子集，这里有一个套路，记住即可。\n1 for (int j = status; j \u0026gt; 0; j = (j - 1) \u0026amp; status) {} 对于每一个子集，如果当前的数字个数可以满足子集的订单要求，且后续的分配中存在所有订单都满足的情况，说明该分配方案可以通过，返回 true。否则跳过当前数字，使用下一个数字进行分配，将结果返回。\n复杂度 时间复杂度：$O(n \\times 3 ^ m)$ n 为数字的种类数，m 为订单数。如何得到 $3 ^ m$ ？需要用到 二项式定理。\n递归过程中一共用到了 n 中数字，先乘个 n。 按照订单的个数来分：\n有 0 个订单的组合数为 $\\tbinom{m}{0} = C_m^0$，它的子集个数为 $2 ^ 0$。 有 1 个订单的组合数为 $\\tbinom{m}{1} = C_m^1$，它的子集个数为 $2 ^ 1$。 有 2 个订单的组合数为 $\\tbinom{m}{2} = C_m^2$，它的子集个数为 $2 ^ 2$。 有 i 个订单的组合数为 $\\tbinom{m}{i} = C_m^i$，它的子集个数为 $2 ^ i$。 有 m 个订单的组合数为 $\\tbinom{m}{m} = C_m^m$，它的子集个数为 $2 ^ m$。 $$ \\begin{equation} \\begin{aligned} 3 ^ m \u0026amp;= (1 + 2) ^ m\\\\ \u0026amp; = \\sum_{i = 0}^{m}\\tbinom{m}{i} \\times 2 ^ i\\\\ \u0026amp;= \\tbinom{m}{0} \\times 2 ^ 0 + \\tbinom{m}{1} \\times 2 ^ 1 + \\tbinom{m}{2} \\times 2 ^ 2 + \u0026hellip; + \\tbinom{m}{m} \\times 2 ^ m \\end{aligned} \\end{equation} $$\n空间复杂度：$O(n \\times 2 ^ m)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class Solution { public boolean canDistribute(int[] nums, int[] quantity) { Arrays.sort(nums); int n = 1; for (int i = 1; i \u0026lt; nums.length; i++) { if (nums[i] != nums[i - 1]) { n++; } } int[] count = new int[n]; int index = 0; count[0] = 1; for (int i = 1; i \u0026lt; nums.length; i++) { if (nums[i] != nums[i - 1]) { index++; } count[index]++; } int m = quantity.length; int[] sum = new int[1 \u0026lt;\u0026lt; m]; // 下面这个枚举是生成quantity中的每个子集，所需要数字的个数 for (int i = 0, v, h; i \u0026lt; quantity.length; i++) { v = quantity[i]; h = 1 \u0026lt;\u0026lt; i; for (int j = 0; j \u0026lt; h; j++) { sum[h | j] = sum[j] + v; } } int[][] dp = new int[1 \u0026lt;\u0026lt; m][n]; return process((1 \u0026lt;\u0026lt; m) - 1, 0, n, m, count, sum, dp); } public boolean process(int status, int cur, int n, int m, int[] count, int[] sum, int[][] dp) { if (status == 0) { return true; } if (cur == n) { return false; } if (dp[status][cur] != 0) { return dp[status][cur] == 1; } boolean ans = false; int k = count[cur]; for (int j = status; j \u0026gt; 0; j = (j - 1) \u0026amp; status) { if (sum[j] \u0026lt;= k \u0026amp;\u0026amp; process(status ^ j, cur + 1, n, m, count, sum, dp)) { ans = true; break; } } if (!ans) { ans = process(status, cur + 1, n, m, count, sum, dp); } dp[status][cur] = ans ? 1 : -1; return ans; } } ","date":"2024-01-19T21:35:31+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-1655.-%E5%88%86%E9%85%8D%E9%87%8D%E5%A4%8D%E6%95%B4%E6%95%B0/","title":"LeetCode 1655. 分配重复整数"},{"content":" LeetCode 1434. 每个人戴不同帽子的方案数\n算法讲解081【必备】状压dp-下\n思路 每个人都要选择一个自己喜欢的帽子，可以枚举每个人选择帽子的可能性，列举出所有的可能性，找出一种满足所有人的方案，如果可以满足，则方案数加一。\n求解过程 状态压缩\n我们要想办法表示出所有的状态，如果要表示帽子的状态，最多有 $2 ^ {40}$ 种状态，状态的数量太多，空间会不够。不过人数不多，最多才 10 个人，每个人都满足和不满足两种状态，最多 $2 ^ {10}$ 种状态。只用人的状态无法确定递归的是否为同一个递归函数，还需要一个纬度，就是帽子的序号。我们从小到大依次枚举帽子的序号，再根据人的状态，我们就可以推断出哪个帽子给了谁，也就知道了当前状态的方案数。\n我们使用一个 int 类型的整数表示人的状态，1 表示这个人还没有获得满意的帽子，0 代表这个人获得了满意的帽子。同时递归函数调用时，传入一个帽子的序号。\nBase Case\n所有人都获得了满意的帽子 status == 0 ：方案数加一 帽子的序号已经超过了最大的帽子序号：cur == m + 1 ：该方案不能满足所有人，方案数加零。 预处理\n获取帽子的最大序号 求出每个帽子可以满足的人的状态：例如某个帽子可以满足 1、3、5 号人，使用一个整数表示可以满足的人的集合，将 1、3、5 号比特位的值设置为 1。（相或） 递归展开\n所有人都不选则该帽子：跳过该帽子，求出总方案数。 选择一个人使用该帽子：枚举每一个人，这个人还没获得满意的帽子且这个人喜欢这个帽子，求出该方案的总方案数，累加。 在枚举每一个人的时候，我们可以对枚举进行优化，从该帽子可以满足的人中挑选，看看这个人是否已获得满意的帽子。从预处理的状态数组中，我们可以的到一个整数，它表示该帽子可以满足的人的状态，我们需要取出每一个 1，可以使用 rightOne = (temp \u0026amp; -temp); 获取最右侧的 1，然后将这个 1 异或掉 (temp ^= rightOne;)，然后继续求下一个右侧的 1。\n复杂度 时间复杂度：$O(m \\times 2 ^ n)$ 空间复杂度：$O(m \\times 2 ^ n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class Solution { public int MOD = 1000000007; public int numberWays(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; hats) { // n 个人 int n = hats.size(); // 每一个帽子可以满足人的情况 int[] list = new int[41]; int m = 0; for (int i = 0; i \u0026lt; n; i++) { for (int hat : hats.get(i)) { m = Math.max(m, hat); list[hat] ^= (1 \u0026lt;\u0026lt; i); } } int[][] dp = new int[m + 1][1 \u0026lt;\u0026lt; n]; for (int i = 0; i \u0026lt;= m; i++) { Arrays.fill(dp[i], -1); } // 1 可以选，0 不可选 return process((1 \u0026lt;\u0026lt; n) - 1, 1, n, m, list, dp); } public int process(int status, int cur, int n, int m, int[] list, int[][] dp) { if (status == 0) { // 所有人都得到了想要的帽子 return 1; } if (cur == m + 1) { return 0; } if (dp[cur][status] != -1) { return dp[cur][status]; } int ans = process(status, cur + 1, n, m, list, dp) % MOD; // 优化枚举时间 int temp = list[cur]; int rightOne; while (temp != 0) { rightOne = (temp \u0026amp; -temp); if ((status \u0026amp; rightOne) != 0) { ans = (ans + process(status ^ rightOne, cur + 1, n, m, list, dp)) % MOD; } temp ^= rightOne; } // for (int i = 0; i \u0026lt; n; i++) { // if ((status \u0026amp; (1 \u0026lt;\u0026lt; i)) != 0 \u0026amp;\u0026amp; (list[cur] \u0026amp; (1 \u0026lt;\u0026lt; i)) != 0) { // ans = (ans + process(status ^ (1 \u0026lt;\u0026lt; i), cur + 1, n, m, list, dp)) % MOD; // } // } dp[cur][status] = ans; return ans; } } ","date":"2024-01-19T21:34:54+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-1434.-%E6%AF%8F%E4%B8%AA%E4%BA%BA%E6%88%B4%E4%B8%8D%E5%90%8C%E5%B8%BD%E5%AD%90%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/","title":"LeetCode 1434. 每个人戴不同帽子的方案数"},{"content":" 洛谷 P1171 售货员的难题\n算法讲解080【必备】状压dp-上\n思路 所有村庄中，任意两个村庄之间都是连通的，所以售货员的路线可能是任意一条，我们要枚举出每一条行驶路线，找到路程最短的那条经过的路程是多少。我们使用一个状态变量表示村庄是否已经经过，每次来到一个村庄时，考虑所有没有去过的村庄作为下一站，在所有村庄中，选择路程最小的。\n求解过程 状态压缩\n最多有 20 个村庄，所以可以使用一个 int 类型的整型变量表示所有村庄的状态。在递归过程中还需要一个 dp 表记录递归的结果，以便于在重复调用时再次递归展开。只使用村庄的状态作为条件无法确定是否是同一个递归，还需要知道当前在哪个村庄，因为只要知道了当前位置和村庄的状态，那么经过的村庄的最短路径是确定的。例如当前在 5 村庄，递归最底层是要回到 0 村庄（以 0 村庄作为出发点），那么从 0 -\u0026gt; 5 的最短路径是确定的。\nBase Case\n当所有的村庄都经过一遍之后，要回到初始的位置（村庄 0），返回当前村庄到达村庄0 的路程。\n递归调用\n假设当前来到了村庄 i，枚举每一个没有去过的村庄 j，从 i 出发走完一遍剩余村庄再回到村庄 0 的最短总路程为\n$$ \\min(distance_{ij} + process(j, status | (1 \u0026laquo; j))) $$\n优化\nC++ 可以根据上面的思路编写代码通过，但是 Java 会被卡空间，因此需要对空间进行优化。二维表只记录除出发点之外的所有村庄之间的距离，出发点到各村庄和各村庄到出发点的距离使用两个一维表记录。递归开始村庄从除出发点之外的所有村庄开始，将得到的结果加上从出发点到达各村庄的距离，将所有结果进行比较，取最小值。\n复杂度 时间复杂度：$O(n \\times 2 ^ n)$ 空间复杂度：$O(n \\times 2 ^ n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import java.io.*; public class Main { public static int MAXN = 19; public static int[][] graph = new int[MAXN][MAXN]; public static int[] start = new int[MAXN]; public static int[] back = new int[MAXN]; public static int[][] dp = new int[1 \u0026lt;\u0026lt; MAXN][MAXN]; public static int n; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer in = new StreamTokenizer(br); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while (in.nextToken() != StreamTokenizer.TT_EOF) { n = (int)in.nval - 1; in.nextToken(); // 0,0 位置舍弃 for (int i = 0; i \u0026lt; n; i++) { in.nextToken(); start[i] = (int)in.nval; } for (int i = 0; i \u0026lt; n; i++) { in.nextToken(); back[i] = (int)in.nval; for (int j = 0; j \u0026lt; n; j++) { in.nextToken(); graph[i][j] = (int)in.nval; } } out.println(compute()); } out.flush(); out.close(); br.close(); } public static int compute() { for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); i++) { for (int j = 0; j \u0026lt; n; j++) { dp[i][j] = -1; } } int ans = Integer.MAX_VALUE; for (int i = 0; i \u0026lt; n; i++) { // 从各个村庄出发，再加上从出发点到各个村庄的距离 ans = Math.min(ans, start[i] + process(1 \u0026lt;\u0026lt; i, i)); } return ans; } public static int process(int status, int cur) { if (status == (1 \u0026lt;\u0026lt; n) - 1) { // 从当前村庄回到出发点 return back[cur]; } if (dp[status][cur] != -1) { return dp[status][cur]; } int ans = Integer.MAX_VALUE; for (int i = 0; i \u0026lt; n; i++) { if ((status \u0026amp; (1 \u0026lt;\u0026lt; i)) == 0) { // 所有路程取最小值 ans = Math.min(ans, graph[cur][i] + process(status | (1 \u0026lt;\u0026lt; i), i)); } } dp[status][cur] = ans; return ans; } } ","date":"2024-01-18T22:47:58+08:00","permalink":"https://zhuaowei.github.io/article/%E6%B4%9B%E8%B0%B7-p1171-%E5%94%AE%E8%B4%A7%E5%91%98%E7%9A%84%E9%9A%BE%E9%A2%98/","title":"洛谷 P1171 售货员的难题"},{"content":" LeetCode 698. 划分为k个相等的子集\n算法讲解080【必备】状压dp-上\n思路 这题与 LeetCode 473. 火柴拼正方形 十分相似，只是将固定的 4 改成了变量 k 而已。\n沿用上面这题的思路，还是一个一个子集的满足，直到所有的数字都使用完，最终判断结果满足条件的子集的个数是否为 k。\n求解过程 状态压缩\n使用一个整数表示数字已选和未选的状态，每次递归时，枚举每一个可选的数字，查看该选择能否满足题目的要求，如果存在满足条件的情况，返回 true，否则返回 false。例如下面的整数表示 2、5、6、7、9 下标的数字还没有被选。\n1 2 number: 9 8 7 6 5 4 3 2 1 0 int bit: 1 0 1 1 1 0 0 1 0 0 Base Case\n当所有数字都被选择完的时候，也即 status == 0 的时候，递归结束，判断满足子集的个数是否为 k。\n递归过程\n按照顺序，每次挑选数字只为满足当前子集，只有当前子集被满足了，才能继续下一个子集。同时递归参数要传入当前子集剩余的还需要满足的数字之和。\n在选择数字时，依次选择没有选择过的数字，挑选的数字分为三种情况：\n加上该数字，子集之和超了：不用，跳过。 加上该数字，子集之和正好：当前子集满足，继续下一个子集，初始化下一个子集还需要的数字之和。 加上该数字，子集之和不够：也可以用，继续递归这个子集，更新这个子集还需要的数字之和。 剪枝\n根据题目要求，必须使用所有数字，且必须正好划分为 $k$ 个子集，所以如果数组之和不能被 $k$ 整除，那么一定正好划分 $k$ 个满足条件的子集。如果可以被 k 整除，那么每个子集之和肯定为 $\\frac{sum}{k}$。\n复杂度 时间复杂度：$O(n \\times 2 ^ n)$ 空间复杂度：$O(2 ^ n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public boolean canPartitionKSubsets(int[] nums, int k) { int sum = 0; for (int num : nums) { sum += num; } if (sum % k != 0) { return false; } int target = sum / k; int n = nums.length; int status = (1 \u0026lt;\u0026lt; n) - 1; int[] dp = new int[1 \u0026lt;\u0026lt; n]; return process(status, n, target, target, 0, k, nums, dp); } public boolean process(int status, int n, int rest, int target, int cur, int total, int[] nums, int[] dp) { if (status == 0) { return cur == total; } if (dp[status] != 0) { return dp[status] == 1; } boolean ans = false; for (int i = 0; i \u0026lt; n; i++) { if ((status \u0026amp; (1 \u0026lt;\u0026lt; i)) != 0) { if (rest == nums[i]) { ans |= process(status ^ (1 \u0026lt;\u0026lt; i), n, target, target, cur + 1, total, nums, dp); } else if (rest \u0026gt; nums[i]) { ans |= process(status ^ (1 \u0026lt;\u0026lt; i), n, rest - nums[i], target, cur, total, nums, dp); } } } dp[status] = ans ? 1 : -1; return ans; } } ","date":"2024-01-18T22:46:34+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-698.-%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86/","title":"LeetCode 698. 划分为k个相等的子集"},{"content":" LeetCode 473. 火柴拼正方形\n算法讲解080【必备】状压dp-上\n思路 依次满足每一条边，直到四条边全部满足，然后判断是否有火柴剩余。每次挑选时，尝试剩下的每一种火柴，看看它以及后续的选择是否存在一个选择方案将四条边全部满足。\n求解过程 状态压缩\n根据题意和数据范围，我们要表示所有火柴的每一种状态，而火柴的最大个数为 15，每个火柴有选与不选两种状态，所以一共是 $2 ^ {15}$ 个状态，是可以通过的。因此我们使用一个 int 类型的整数表示所有状态，1 表示火柴还没有选择过，0 表示火柴已经选择过了。例如下面的整数表示 2、5、6、7、9 号火柴还没有被选。\n1 2 number: 9 8 7 6 5 4 3 2 1 0 int bit: 1 0 1 1 1 0 0 1 0 0 Base Case\n当所有火柴都被选择的时候，递归到达最底层，也即 status == 0。这时候判断是否将四条边全部满足，不多也不少，也即 mat == 4。\n递归过程\n因为四条边是按顺序逐个满足的，且只要知道了哪些火柴被选，就知道了当前来到了哪条边。因此只需要使用 dp 表记录状态即可，不需要使用其他的纬度。\n在选择火柴时，依次选择没有选过的火柴，挑选的火柴分为三种情况：\n加上该火柴，边长超了：不用，跳过。 加上该火柴，边长正好：一条边满足，继续下一条边，初始化这条边还需要的长度。 加上该火柴，边长正好：也可以用，继续递归这条边，更新这条边还需要的长度。 剪枝\n根据题目要求，必须使用所有火柴，且必须正好拼成四条边，所以如果火柴的长度之和不能被 4 整除，那么一定无法拼成。如果可以被 4 整除，那么每条边一定是和除以 4。\n复杂度 时间复杂度：$O(n \\times 2 ^ n)$ 空间复杂度：$O(2 ^ n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public boolean makesquare(int[] matchsticks) { int sum = 0; for (int m : matchsticks) { sum += m; } if (sum % 4 != 0) { return false; } int target = sum / 4; int n = matchsticks.length; int status = (1 \u0026lt;\u0026lt; n) - 1; int[] dp = new int[1 \u0026lt;\u0026lt; n]; return process(status, n, target, target, 0, matchsticks, dp); } public boolean process(int status, int n, int rest, int target, int mat, int[] matchsticks, int[] dp) { if (status == 0) { return mat == 4; } if (dp[status] != 0) { return dp[status] == 1; } boolean ans = false; for (int i = 0; i \u0026lt; n; i++) { if ((status \u0026amp; (1 \u0026lt;\u0026lt; i)) != 0) { if (rest == matchsticks[i]) { ans |= process(status ^ (1 \u0026lt;\u0026lt; i), n, target, target, mat + 1, matchsticks, dp); } else if (rest \u0026gt; matchsticks[i]) { ans |= process(status ^ (1 \u0026lt;\u0026lt; i), n, rest - matchsticks[i], target, mat, matchsticks, dp); } } } dp[status] = ans ? 1 : -1; return ans; } } ","date":"2024-01-18T22:45:08+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-473.-%E7%81%AB%E6%9F%B4%E6%8B%BC%E6%AD%A3%E6%96%B9%E5%BD%A2/","title":"LeetCode 473. 火柴拼正方形"},{"content":" LeetCode 464. 我能赢吗\n算法讲解080【必备】状压dp-上\n思路 在玩家1的每一个回合都考虑一下剩下数字的所有可能，只要存在获胜的分支，就说明玩家1可以稳赢。同理，轮到玩家2时，就要找到玩家2稳输的分支。因为两位玩家都绝顶聪明，所以轮到每一位玩家时，他们都尽最大努力获胜。\n求解过程 递归子问题以玩家1的视角进行，如果要玩家1获胜，那么玩家1必须在剩下的数字中挑选一个，挑完之后的数字让玩家2选，使得玩家2必输，那么玩家1就可以获胜。\n状态压缩\n因为要考虑每一种情况，所以必须使用一个数据结构来表示哪些数字是挑选过的，哪些是没有被挑选的。通过题目给定的 $n$ 的范围，推断出这个题目应该使用状态压缩DP。因为要表示所有状态，每个数字都有选或者不选两种状态，那么一共就是 $2 ^ n$ 个状态，而 $n$ 的最大值为 $20$，所以状态最大值就约等于 $10 ^ 6$，是可以通过的。\n我们使用一个 int 类型的整数就可以表示所有的状态，使用整数的比特位作为状态，1 表示没有选，还可以选；0 表示已经选过了，不能选了。例如下面的示例，2、5、6、7、9 没有选过，其余都选过了。\n1 2 number: 9 8 7 6 5 4 3 2 1 0 int bit: 1 0 1 1 1 0 0 1 0 0 Base Case\n当递归来到某位玩家时， rest 小于等于 0 说明对方已经先一步将总和加到了目标值，该玩家输了；否则说明还有机会，轮到该玩家挑选数字。\n剪枝\n如果目标值是 0，玩家1先手，不用挑数字，直接判定玩家1获胜。 如果所有数字之和都不大于目标值，说明不存在赢家。题目说玩家1稳赢时返回 true，这种情况玩家1无法获胜，返回 false。 复杂度 时间复杂度：$O(n \\times 2 ^ n)$ 空间复杂度：$O(2 ^ n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public boolean canIWin(int n, int m) { if (m == 0) { return true; } if ((n * (n + 1) / 2) \u0026lt; m) { return false; } int[] dp = new int[1 \u0026lt;\u0026lt; (n + 1)]; return process((1 \u0026lt;\u0026lt; (n + 1)) - 1, m, n, dp); } // A 选手是先手，当前状态是 status，剩余 rest 需要选 public boolean process(int status, int rest, int n, int[] dp) { if (rest \u0026lt;= 0) { // 对手已经先一步选择 return false; } if (dp[status] != 0) { return dp[status] == 1; } boolean ans = false; for (int i = 1; i \u0026lt;= n; i++) { if ((status \u0026amp; (1 \u0026lt;\u0026lt; i)) != 0 \u0026amp;\u0026amp; !process((status ^ (1 \u0026lt;\u0026lt; i)), rest - i, n, dp)) { // i 可以选择。 ans = true; break; } } dp[status] = (ans ? 1 : -1); return ans; } } ","date":"2024-01-18T22:43:46+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-464.-%E6%88%91%E8%83%BD%E8%B5%A2%E5%90%97/","title":"LeetCode 464. 我能赢吗"},{"content":" LeetCode 2322. 从树中删除边的最小分数\n算法讲解079【必备】树型dp-下\n思路 遍历整棵树，构建出DFN序和size数组，同时计算出每个子树的异或和。然后遍历任意两条边的组合，求出最小分数。\n求解过程 两条边的关系\n无论以那个节点为整个树的头节点，同样的两条边划分的子集是一样的，所以遍历时就按照以 0 为头节点。\n两条边的的位置关系有以下两种：一是并列，二是包含。先删除一条边，将整个树划分为头树和子树两部分，并列指第二条边在头树这部分，包含指第二条边在子树这部分。根据不同的情况选择不同的异或和计算方式。\n为了区分两条边的情况，因此需要使用DFN序和子树大小判断两个节点是否在同一棵树上。同时还要计算出子树的异或和，便于计算划分后的子集的异或和。\n计算过程\n首先构建出无向图，从 0 号节点还是递归，计算出DFN序、子树大小size、子树异或和。\n然后两层for循环遍历每一种组合情况。划分子集时，要求出划分后的子树的头节点，因此对于边上的两个点，取出远离 0 号节点的那一个，也就是DFN序更大的一个。\n求出划分后两个子集的的头节点后，判断DFN序较大的节点是否在较小的节点为头的树上，区分出并列还是包含的关系。计算出三个子集的异或和，计算出分数，取最小分数。\n复杂度 时间复杂度：$O(n + m^2)$ n 为节点个数，m 为边的个数。\n空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class Solution { int MAXN = 1005; int[] xor = new int[MAXN]; int[] dfn = new int[MAXN]; int[] size = new int[MAXN]; int cnt = 0; public int minimumScore(int[] nums, int[][] edges) { int n = nums.length; List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;Integer\u0026gt;()); } for (int[] edge: edges) { graph.get(edge[0]).add(edge[1]); graph.get(edge[1]).add(edge[0]); } dfs(graph, nums, 0); int m = edges.length; int ans = Integer.MAX_VALUE; // 遍历任意两条边 for (int i = 0, a, b, pre, pos, sum1, sum2, sum3; i \u0026lt; m; i++) { // a b 分别是两条边中，远离 0 节点的点。 a = Math.max(dfn[edges[i][0]], dfn[edges[i][1]]); for (int j = i + 1; j \u0026lt; m; j++) { b = Math.max(dfn[edges[j][0]], dfn[edges[j][1]]); // 调换 a b 的位置，确定前后顺序 if (a \u0026lt; b) { pre = a; pos = b; } else { pre = b; pos = a; } // 后一个树，它的异或值是确定的 sum1 = xor[pos]; if (pos \u0026lt; pre + size[pre]) { // 如果是包含关系 sum2 = xor[pre] ^ xor[pos]; sum3 = xor[1] ^ xor[pre]; } else { sum2 = xor[pre]; sum3 = xor[1] ^ xor[pre] ^ xor[pos]; } // 结算 int max = Math.max(sum1, Math.max(sum2, sum3)); int min = Math.min(sum1, Math.min(sum2, sum3)); ans = Math.min(ans, max - min); } } return ans; } public void dfs(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph, int[] nums, int node) { int i = ++cnt; dfn[node] = i; size[i] = 1; xor[i] = nums[node]; for (int next : graph.get(node)) { if (dfn[next] == 0) { dfs(graph, nums, next); xor[i] ^= xor[dfn[next]]; size[i] += size[dfn[next]]; } } } } ","date":"2024-01-05T10:57:32+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2322.-%E4%BB%8E%E6%A0%91%E4%B8%AD%E5%88%A0%E9%99%A4%E8%BE%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E5%88%86%E6%95%B0/","title":"LeetCode 2322. 从树中删除边的最小分数"},{"content":" LeetCode 1154. 一年中的第几天\n思路 这题跟昨天那道题很像，比昨天的还简单，同样也是根据年份是否闰年，计算出天数。\n求解过程 按照月份逐月累加天数，2 月是一个特殊的月份，需要根据年份判断是否是闰年，如果是闰年，需要额外再加一天。\n复杂度 时间复杂度：$O(1)$ 空间复杂度：$O(1)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { int[] daysOfMonth = new int[] { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; public int dayOfYear(String str) { char[] date = str.toCharArray(); int year = 0, month = 0, day = 0; year = year * 10 + (date[0] - \u0026#39;0\u0026#39;); year = year * 10 + (date[1] - \u0026#39;0\u0026#39;); year = year * 10 + (date[2] - \u0026#39;0\u0026#39;); year = year * 10 + (date[3] - \u0026#39;0\u0026#39;); month = month * 10 + (date[5] - \u0026#39;0\u0026#39;); month = month * 10 + (date[6] - \u0026#39;0\u0026#39;); day = day * 10 + (date[8] - \u0026#39;0\u0026#39;); day = day * 10 + (date[9] - \u0026#39;0\u0026#39;); for (int i = 1; i \u0026lt; month; i++) { day += daysOfMonth[i - 1]; } if (isLeapYear(year) \u0026amp;\u0026amp; month \u0026gt; 2) { day += 1; } return day; } public boolean isLeapYear(int year) { return year % 100 == 0 ? year % 400 == 0 : year % 4 == 0; } } ","date":"2023-12-31T12:01:34+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-1154.-%E4%B8%80%E5%B9%B4%E4%B8%AD%E7%9A%84%E7%AC%AC%E5%87%A0%E5%A4%A9/","title":"LeetCode 1154. 一年中的第几天"},{"content":" LeetCode 1185. 一周中的第几天\n思路 计算出当前日期是距离 1970-01-01 的第几天，然后对天数取余，计算出当前日期是星期几。\n求解过程 主要是判断某一年是否是闰年，如何判断一个年份是否是闰年？某一年如果能被 100 整除且能被400整除,或者不能被 100 整除但是能被 4 整除，那么这一年就是闰年。\n从 1970 年一直加到目标年份，然后根据是否闰年再进行月份天数计算，最终与 7 取余，计算出星期。\n复杂度 时间复杂度：$O(n)$ n 为查询的平均年份\n空间复杂度：$O(1)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { String[] weeks = new String[] { \u0026#34;Sunday\u0026#34;, \u0026#34;Monday\u0026#34;, \u0026#34;Tuesday\u0026#34;, \u0026#34;Wednesday\u0026#34;, \u0026#34;Thursday\u0026#34;, \u0026#34;Friday\u0026#34;, \u0026#34;Saturday\u0026#34; }; int[] days = new int[] { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; public String dayOfTheWeek(int day, int month, int year) { int sum = 0; for (int i = 1971; i \u0026lt; year; i++) { if (isLeapYear(i)) { sum += 366; } else { sum += 365; } } boolean leapYear = isLeapYear(year); for (int i = 1; i \u0026lt; month; i++) { sum += getDaysOfMonth(i, leapYear); } sum += day; return weeks[(sum + 4) % 7]; } public boolean isLeapYear(int year) { return year % 100 == 0 ? year % 400 == 0 : year % 4 == 0; } public int getDaysOfMonth(int month, boolean leapYear) { if (leapYear \u0026amp;\u0026amp; month == 2) { return 29; } else { return days[month - 1]; } } } ","date":"2023-12-30T12:01:12+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-1185.-%E4%B8%80%E5%91%A8%E4%B8%AD%E7%9A%84%E7%AC%AC%E5%87%A0%E5%A4%A9/","title":"LeetCode 1185. 一周中的第几天"},{"content":" LeetCode 2706. 购买两块巧克力\n思路 求出所有巧克力中的价格最小的两个，判断是否满足购买条件，返回依情况返回。\n求解过程 准备两个变量，记录下最小值和次小值。遍历数组，更新最小值和次小值。\n如果当前值比最小值小：最小值赋值给次小值，更新最小值。 如果当前值仅比次小值小：更新次小值。 如果当前值比次小值还大：略过。 最后，根据剩余金额返回结果。\n复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int buyChoco(int[] prices, int money) { int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE; for (int p : prices) { if (p \u0026lt; min1) { min2 = min1; min1 = p; } else if (p \u0026lt; min2) { min2 = p; } } int sum = min1 + min2; return sum \u0026lt;= money ? money - sum : money; } } ","date":"2023-12-29T12:00:34+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2706.-%E8%B4%AD%E4%B9%B0%E4%B8%A4%E5%9D%97%E5%B7%A7%E5%85%8B%E5%8A%9B/","title":"LeetCode 2706. 购买两块巧克力"},{"content":"1、下载专用服务器启动器 打开 Steam，依次点击 库 -\u0026gt; 主页，勾选 工具，找到 Don\u0026rsquo;t Strave Together Dedicated Server，点击安装，在安装过程中，可以进行下一步。\n2、创建一个世界 进入饥荒联机版，创建一个世界，修改世界设置，勾选好自己想用的模组，点击创建。创建完成后，不需要进入世界，出现选人界面后就可以退出存档了。\n在世界列表中，找到刚才创建的世界，点击管理，找到存档在文件夹中的位置（存档名字为 Cluster_ + 数字），将整个文件夹复制到上一层文件夹中，可以把复制后的文件夹换一个名字，方便记。（后面我们把这个存档称为联机存档）\n3、创建联机服务器 点击 科雷的服务器创建页面，创建一个服务器用于启动刚才创建的世界。复制创建好的票据，等会用到。\n在联机存档根目录创建一个 cluster_token.txt，将刚才的票据复制进去，保存退出。\n4、添加模组 创建世界用到的模组需要添加到专用服务器才可以使用，添加一次即可，后面创建的世界可以直接用。（如果没有添加模组，这一步可以跳过）\n找到 Don't Strave Together Dedicated Server 的安装目录（可以在 steam 中右键点击属性），在 mods 文件夹下找到 dedicated_server_mods_setup.lua 文件，这个文件是管理模组安装的。\n配置分为两种：一是单个模组安装，二是模组合集安装。\n单个模组安装：在创意工坊找到需要的模组的界面，界面链接最后 id 后面的数字就是模组的 id，粘贴到 ServerModSetup(\u0026quot;378160973\u0026quot;) 中。\n模组合集安装：将订阅合集的 id 粘贴到 ServerModCollectionSetup(\u0026quot;379114180\u0026quot;) 中，跟上面的类似。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 -- Mod Subscribe -- -- [Global Positions](https://steamcommunity.com/sharedfiles/filedetails/?id=378160973) ServerModSetup(\u0026#34;378160973\u0026#34;) -- [Lazy Furnace](https://steamcommunity.com/sharedfiles/filedetails/?id=875994715) ServerModSetup(\u0026#34;875994715\u0026#34;) -- [Show Me](https://steamcommunity.com/sharedfiles/filedetails/?id=2287303119) ServerModSetup(\u0026#34;2287303119\u0026#34;) -- [Epic HealthBar](https://steamcommunity.com/sharedfiles/filedetails/?id=1185229307) ServerModSetup(\u0026#34;1185229307\u0026#34;) -- [Warmhole Marks](https://steamcommunity.com/sharedfiles/filedetails/?id=362175979) ServerModSetup(\u0026#34;362175979\u0026#34;) -- [从骨头复活](https://steamcommunity.com/sharedfiles/filedetails/?id=1271089343) ServerModSetup(\u0026#34;1271089343\u0026#34;) -- [防卡两招](https://steamcommunity.com/sharedfiles/filedetails/?id=1216718131) ServerModSetup(\u0026#34;1216718131\u0026#34;) -- [Drop \u0026amp; Stack](https://steamcommunity.com/sharedfiles/filedetails/?id=1998081438) ServerModSetup(\u0026#34;1998081438\u0026#34;) -- [Simple Health Bar](https://steamcommunity.com/sharedfiles/filedetails/?id=1207269058) ServerModSetup(\u0026#34;1207269058\u0026#34;) -- [Infinite Tent Uses](https://steamcommunity.com/sharedfiles/filedetails/?id=356930882) ServerModSetup(\u0026#34;356930882\u0026#34;) -- [Tips show attack time](https://steamcommunity.com/sharedfiles/filedetails/?id=1898292532) ServerModSetup(\u0026#34;1898292532\u0026#34;) -- [Infinite Thremal Stone](https://steamcommunity.com/sharedfiles/filedetails/?id=466732225) ServerModSetup(\u0026#34;466732225\u0026#34;) 5、配置启动程序 在 Don't Strave Together Dedicated Server 的安装目录下，进入 bin64 文件夹，创建一个 launch_dedicated_server.bat 文件，打开文件，粘贴如下内容。（文件名字随意，创建完毕后可以在桌面创建快捷方式，方便启动）\n-cluster 后面是联机存档的名字，需要改成自己的。\n1 2 3 4 5 6 7 8 @ECHO OFF set SteamAppId=322330 set SteamGameId=322330 Start \u0026#34;DST Master\u0026#34; dontstarve_dedicated_server_nullrenderer_x64.exe -console -cluster 联机存档名字 -shard Master Start \u0026#34;DST Caves\u0026#34; dontstarve_dedicated_server_nullrenderer_x64.exe -console -cluster 联机存档名字 -shard Caves 6、饥荒！启动！ 双击第 5 步创建的脚本程序，会出现两个黑框，分别是地上和地下的服务器。如果有模组，第一次启动会比较慢，因为要下载模组。\n等待一段时间（没模组大概一分钟内），Caves 服务器出现 Sim Pause 后，就可以进入饥荒联机版。点击 浏览游戏，在搜索框中搜索你创建世界的名字，就可以找到自己创建的联机世界了。\n7、关闭服务器 如果不关闭服务器，是无法进入正常创建的世界的，直接点叉不太优雅，并且服务器不会对当前游戏状态进行存档。分别在两个黑框中输入 c_shutdown() ，然后回车，就可以关闭服务了。\n","date":"2023-12-29T09:43:05+08:00","permalink":"https://zhuaowei.github.io/article/%E9%A5%A5%E8%8D%92%E8%81%94%E6%9C%BA%E7%89%88-%E6%90%AD%E5%BB%BA%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/","title":"饥荒联机版 - 搭建专用服务器"},{"content":" LeetCode 2735. 收集巧克力\n思路 暴力解法，求出每一个巧克力在每一种移动情况下的最小成本，再加上移动步数的成本，求出每一种方案的最小值。\n求解过程 使用一个数组记录下所有巧克力在移动至多 $i$ 步的情况下的最小成本，移动步数最多为所有巧克力的个数。先计算出每一步的移动成本，之后再计算收集成本。\n遍历每一个巧克力 $nums_i$，计算它至多移动 $j$ 步时的最小成本，将成本累加到 $cost_i$ 中。\n计算完所有巧克力在至多移动所有步数的结果后，在所有成本中取最小成本返回。\n复杂度 时间复杂度：$O(n^2)$ 空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public long minCost(int[] nums, int x) { int n = nums.length; long[] cost = new long[n]; // 移动成本 for (int i = 1; i \u0026lt; n; i++) { cost[i] = cost[i - 1] + x; } for (int i = 0; i \u0026lt; n; i++) { int temp = nums[i]; // 收集第 i 个巧克力，在移动 j 步的情况下的最小成本 for (int j = 0; j \u0026lt; n; j++) { temp = Math.min(temp, nums[(i - j + n) % n]); cost[j] += temp; } } long ans = Long.MAX_VALUE; // 所有成本的最小值 for (long c : cost) { ans = Math.min(ans, c); } return ans; } } ","date":"2023-12-28T11:58:29+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2735.-%E6%94%B6%E9%9B%86%E5%B7%A7%E5%85%8B%E5%8A%9B/","title":"LeetCode 2735. 收集巧克力"},{"content":" LeetCode 2458. 移除子树后的二叉树高度\n算法讲解079【必备】树型dp-下\n思路 首先构建出二叉树的 DFN序，记录下每一个节点的树大小和深度。查询时，根据当前节点的DFN序和子树大小，计算出除了当前树区域之外的最大高度。\n求解过程 DFN序\nDFN序是指按照遍历顺序重新给树的节点进行编号，同时记录下每个节点的树的大小。根据DFN序和子树大小，可以判断出两个节点是否同属于一棵子树。\n使用深度优先遍历进行构建DFN序，每来到一个节点时，先给当前节点进行编号，然后依次递归执行左树和右树，得到左树和右树的大小，计算出本节点的树的大小。本题除了要记录DFN序和 size 数组外，还需要计算出当前节点到头节点的深度 deep。\n求最大高度\n例如当前查询的是移除 i 为头的子树后的最大高度，它的树大小为 j，那么我们就要查询 deep 数组在 [1, i) 和 [i + j, n] 区间的最大值。为了减少查询时间，我们处理两个前缀、后缀数组，分别记录下 [1, i] 和 [i, n] 的最大深度。\n复杂度 时间复杂度：$O(n + m)$ n 为树的节点个数，m 为查询的次数。\n空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { int MAXN = 100010; int[] height = new int[MAXN]; // 距离头部的高度 int[] dfn = new int[MAXN]; // dfn 序号 index 代表节点值， dfn[index] 代表序号 int[] size = new int[MAXN]; // 树的大小 int[] left = new int[MAXN]; int[] right = new int[MAXN]; int cnt = 0; public int[] treeQueries(TreeNode root, int[] queries) { int n = queries.length; // 构建DFN序 dfs(root, 0); // 处理前缀 后缀数组 for (int i = 1; i \u0026lt;= cnt; i++) { left[i] = Math.max(left[i - 1], height[i]); right[cnt + 1 - i] = Math.max(right[cnt + 2 - i], height[cnt + 1 - i]); } // 查询 for (int i = 0; i \u0026lt; n; i++) { int index = dfn[queries[i]]; int s = size[index]; queries[i] = Math.max(left[index - 1], right[index + s]); } return queries; } public int dfs(TreeNode node, int deep) { int index = ++cnt; dfn[node.val] = index; height[index] = deep; size[index] = 1; if (node.left != null) { size[index] += dfs(node.left, deep + 1); } if (node.right != null) { size[index] += dfs(node.right, deep + 1); } return size[index]; } } ","date":"2023-12-27T22:48:35+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2458.-%E7%A7%BB%E9%99%A4%E5%AD%90%E6%A0%91%E5%90%8E%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E5%BA%A6/","title":"LeetCode 2458. 移除子树后的二叉树高度"},{"content":" LeetCode 2246. 相邻字符不同的最长路径\n算法讲解079【必备】树型dp-下\n思路 定义子问题：求子树的相邻字符不同的最长路径。路径分为经过和不经过当前树的头节点两种，分别计算两种路径长度，取最大值。\n求解过程 子问题分为经过和不经过当前树的头节点两种。\n经过当前头节点的路径，需要在头节点的所有子节点为头的树中，找出与头节点字符不相等的最长和次长树高度，路径长度为两个树高之和再加 1。 不经过当前头节点的路径，需要在头节点的所有子节点为头的树中，找出最长的路径。 因此，需要按照前序遍历的方式，遍历整个树，每个子节点给父节点返回两个信息，当前树的最长相邻字符不等的高度，以及当前树的最长路径。\n复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { class Info { int height; int length; Info(int h, int l) { height = h; length = l; } } public int longestPath(int[] parent, String s) { int n = parent.length; char[] str = s.toCharArray(); List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;Integer\u0026gt;()); } for (int i = 1; i \u0026lt; n; i++) { graph.get(parent[i]).add(i); } return process(graph, str, 0).length; } public Info process(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph, char[] str, int node) { int h = 1, l = 1; int max1 = 0, max2 = 0; for (int next : graph.get(node)) { Info info = process(graph, str, next); // 不经过头节点的最长路径 l = Math.max(l, info.length); // 求树的最长和次长高度 if (str[node] != str[next]) { if (info.height \u0026gt; max1) { max2 = max1; max1 = info.height; } else if (info.height \u0026gt; max2) { max2 = info.height; } } } // 经过和不经过，取最大值 l = Math.max(l, 1 + max1 + max2); return new Info(h + max1, l); } } ","date":"2023-12-27T22:45:50+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2246.-%E7%9B%B8%E9%82%BB%E5%AD%97%E7%AC%A6%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84/","title":"LeetCode 2246. 相邻字符不同的最长路径"},{"content":" LeetCode 2660. 保龄球游戏的获胜者\n思路 按顺序遍历数组，如果某位置的前两次得分存在 10 分，则将本次得分乘 2，分别得到两位玩家的得分，根据得分情况决定胜者。\n求解过程 使用两个变量 $sum1, sum2$ 分别记录两位玩家的得分，使用两个变量 $flag1, flag2$ 分别记录两位玩家最后一次得 10 分的位置。 如果 $flag1 + 2 \\ge i$，说明玩家1在 $i$ 位置前两次得分存在 10 分，将本次的得分乘 2。同理可以计算出玩家 2 的得分。 如果本次得分为 10 分，记录下位置。 $flag$ 初始值设置为 -3 是为了保证在 0 位置时，不会错误计算玩家的得分。\n复杂度 时间复杂度：$O(1)$ 空间复杂度：$O(1)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public int isWinner(int[] player1, int[] player2) { int n = player1.length; int sum1 = 0, sum2 = 0; int flag1 = -3, flag2 = -3; // 记录下上次分数为 10 的位置 for (int i = 0; i \u0026lt; n; i++) { sum1 += player1[i]; if (flag1 + 2 \u0026gt;= i) { // 如果在分数为10的位置在前两轮，再加一遍 sum1 += player1[i]; } if (player1[i] == 10) { // 记录下分数为 10 的位置 flag1 = i; } // 玩家 2 的计算过程，与 1 相同 sum2 += player2[i]; if (flag2 + 2 \u0026gt;= i) { sum2 += player2[i]; } if (player2[i] == 10) { flag2 = i; } } if (sum1 \u0026gt; sum2) { return 1; } else if (sum2 \u0026gt; sum1) { return 2; } else { return 0; } } } ","date":"2023-12-27T22:42:51+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2660.-%E4%BF%9D%E9%BE%84%E7%90%83%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85/","title":"LeetCode 2660. 保龄球游戏的获胜者"},{"content":" LeetCode 1349. 参加考试的最大学生数\n腐烂的橘子 - 详解 压缩状态动态规划解法\n灵茶山艾府 - 教你一步步思考动态规划：从记忆化搜索到递推（两种状态定义+题单）\n思路 定义子问题：在前 n 排的情况下，如何安排才能使坐下的学生最多。计算当前排如何安排时，遍历每一种可能的方案，对于每一种方案，遍历上一行的每一种方案，求每一种安排方案的最大值。\n求解过程 状态压缩\n教室的座位状态压缩：教室中的椅子分为好的和坏的，只能在好的椅子上安排学生。记好的椅子为 1，坏的椅子为 0，因为每一排椅子最多有 8 个，所以可以使用一个整数来表示。那么 n 排椅子可以使用一个 n 大小的一维数组表示。 安排方案的状态压缩：每一排的好的椅子，可以安排坐学生，也可以不坐。记坐学生为 1，不坐学生为 0。同样使用一个整数表示一排学生的安排方案，最多有 8 个位子，所以最多有 $2 ^ 8$ 种安排方案。 教室座位和安排方案的状态压缩存在一种关系，就是安排方案是包含于教室座位的，也就是说，我们只能在教室座位是好的中选择，$schema \\subseteq status_i$。\n状态转移\n子问题是在前 n 排的座位中，每种安排方案的最大学生数。如何从上一行的安排方案中得到本行的安排方案？对于本行每一种的安排方案，遍历上一行所有的安排方案，如果两种方案并不冲突，都可以坐下，那么就可以计算出这种方案的人数。\n$$ \\begin{equation} \\begin{aligned} dp_{i,j} = \\begin{cases} -1 \u0026amp; 该方案本行都坐不下\\\\ 0 \u0026amp; 该方案本行可以坐下，但是与上一行冲突\\\\ \\max(dp_{i,j}, dp_{i - 1, k} + bitCount(j)) \u0026amp; 可以坐下 \\end{cases} \\end{aligned} \\end{equation} $$\n计算过程\n首先得到教室座位的状态。遍历每一行，使用位运算得到表示每一排状态的整数。 使用 dp 表记录每一排，每一种方案的最大人数。然后遍历每一排，每一种方案。 当前来到第 i 排，方案编号为 j（j 表示的状态并不是最终安排的方案，因为坏的位置可能也会安排学生），使用 j 和第 i 行的状态得到安排方案 $schema = j \u0026amp; status_i$。这样就保证 schema 是 status_i 的子集，虽然可能会重复，但是不会遗漏。 判断 schema 方案是否存在相邻位置安排学生的情况：$(schema \u0026amp; (schema \u0026laquo; 1)) == 0$，如果结果为 true，说明没有相邻的情况；否则相邻，结果为 -1。 如果结果为 true，可以继续判断。遍历所有上一行的方案，如果本行的座位存在上一行左上或右上已经安排的情况，直接跳过；否则记录更新最大人数。 循环 3 4 5 步骤，得到前 n 排的每种方案的最大安排人数。遍历前 n 排的每一种方案的人数，取最大值返回。 优化\n遍历本行的方案时，可以使用一个一维数组记录可行的方案编号，这样遍历下一行时，就不用遍历上一行的每种方案编号了。 遍历本行时，只会用到上一行的结果，所以只使用两行 dp 表就可以完成状态转移了。 复杂度 时间复杂度：$O(N \\times 2^{2M})$ N 为教室座位的排数，M 为每排座位的椅子数。\n空间复杂度：$O(N \\times 2^{M})$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 public class Solution { public int maxStudents(char[][] seats) { int n = seats.length, m = seats[0].length; int[] status = new int[n + 1]; // 找到可以坐的位置 for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt; m; j++) { if (seats[i - 1][j] == \u0026#39;.\u0026#39;) { status[i] |= (1 \u0026lt;\u0026lt; j); } } } int[][] dp = new int[n + 1][1 \u0026lt;\u0026lt; m]; for (int i = 1; i \u0026lt;= n; i++) { // 每一排 for (int s = 0; s \u0026lt; (1 \u0026lt;\u0026lt; m); s++) { // 每一个可能的安排 int schema = (s \u0026amp; status[i]); // 在可以选择的座位中选择。 if ((schema \u0026amp; (schema \u0026lt;\u0026lt; 1)) == 0) { // 如果安排的座位没有相邻的，是一种合理安排 // 找到上一排座位的安排 for (int last = 0; last \u0026lt; (1 \u0026lt;\u0026lt; m); last++) { if (dp[i - 1][last] == -1) { continue; } // 如果当前行的所有座位，左上和右上都没有坐人 if (((schema \u0026lt;\u0026lt; 1) \u0026amp; last) == 0 \u0026amp;\u0026amp; ((schema \u0026gt;\u0026gt; 1) \u0026amp; last) == 0) { dp[i][s] = Math.max(dp[i][s], dp[i - 1][last] + countBits(schema)); } } } else { dp[i][s] = -1; } } } int ans = 0; for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; m); i++) { if (ans \u0026lt; dp[n][i]) { ans = dp[n][i]; } } return ans; } public int countBits(int num) { num = ((num \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 0x55555555) + (num \u0026amp; 0x55555555); num = ((num \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 0x33333333) + (num \u0026amp; 0x33333333); num = ((num \u0026gt;\u0026gt;\u0026gt; 4) \u0026amp; 0x0f0f0f0f) + (num \u0026amp; 0x0f0f0f0f); num = ((num \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0x00ff00ff) + (num \u0026amp; 0x00ff00ff); num = ((num \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0x0000ffff) + (num \u0026amp; 0x0000ffff); return num; } } ","date":"2023-12-26T20:51:42+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-1349.-%E5%8F%82%E5%8A%A0%E8%80%83%E8%AF%95%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%95%B0/","title":"LeetCode 1349. 参加考试的最大学生数"},{"content":" LeetCode 1276. 不浪费原料的汉堡制作方案\n思路 设大汉堡 x 个，小汉堡 y 个，根据题意写出二元一次方程组，求出 x 和 y 的解。\n求解过程 根据题意，设大汉堡 x 个，小汉堡 y 个，则汉堡个数与原料的关系式为\n$$ \\begin{equation} \\begin{aligned} \\begin{cases} 4x + 2y = tomatoSlices\\\\ x + y = cheeseSlices \\end{cases} \\end{aligned} \\end{equation} $$\n对二元一次方程组进行求解，得到结果：\n$$ \\begin{equation} \\begin{aligned} \\begin{cases} x = \\frac{tomatoSlices - 2 \\times cheeseSlices}{2}\\\\ y = cheeseSlices - x \\end{cases} \\end{aligned} \\end{equation} $$\n由于 x y 被赋予了原料数的含义，所以不能为负数和小数。所以当 $x \u0026lt; 0 或 x \u0026gt; cheeseSlices 或 x 为小数$ 时，无法正好使用完原料，返回空数组。\n复杂度 时间复杂度：$O(1)$ 空间复杂度：$O(1)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public List\u0026lt;Integer\u0026gt; numOfBurgers(int tomatoSlices, int cheeseSlices) { // a = (t - 2 * c) / 2; // b = c - a; List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;Integer\u0026gt;(); int a = (tomatoSlices - 2 * cheeseSlices); if (a \u0026lt; 0 || a \u0026gt; 2 * cheeseSlices || (a \u0026amp; 1) == 1) { return ans; } a /= 2; int b = cheeseSlices - a; ans.add(a); ans.add(b); return ans; } } ","date":"2023-12-25T23:03:17+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-1276.-%E4%B8%8D%E6%B5%AA%E8%B4%B9%E5%8E%9F%E6%96%99%E7%9A%84%E6%B1%89%E5%A0%A1%E5%88%B6%E4%BD%9C%E6%96%B9%E6%A1%88/","title":"LeetCode 1276. 不浪费原料的汉堡制作方案"},{"content":" LeetCode 1954. 收集足够苹果的最小花园周长\n思路 根据题意可以得出花园的周长跟容纳苹果的最大数量是有关系的，通过归纳得出苹果数量与花园边长的关系式，然后进行二分求解。\n求解过程 边长与苹果的关系\n有题意可知，花园的边长是偶数，放置的苹果可以被均分为四部分。如果设置边长为 2x ，则每一部分的苹果分布与 x 的关系如下：\n1 2 3 4 1 2 3 ... x + 1 2 3 4 ... x + 2 ... x x + 1 x + 2 ... 2x 所以可以归纳出苹果的数量为：\n$$ \\begin{equation} \\begin{aligned} f(x) \u0026amp;= 4 \\times x \\times \\frac{(\\frac{x + 1}{2} + \\frac{3x + 1}{2}) \\times (x + 1)}{2}\\\\ \u0026amp;= 4 \\times x \\times \\frac{(2x + 1) \\times (x + 1)}{2}\\\\ \u0026amp;= 2x \\times (2x + 1) \\times (x + 1) \\end{aligned} \\end{equation} $$\n二分答案法\n根据上述的公式，可以得知 $f(x) \\approx x^3$，而苹果数量最大为 $10^{15}$，所以 x 的范围应该是 $[0, 10^5]$。\n根据二分答案法，求出 x 为 mid 时的最大苹果数量。如果可以放下，记录下答案，右边界左移；否则，左边界右移。最终边长的长度为 $8x$。\n复杂度 时间复杂度：$O(log_2n)$ 空间复杂度：$O(1)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public long minimumPerimeter(long neededApples) { // 设边长为 2x，则最大可以放置的苹果数为 (2 * x + 1) * (x + 1) * x * 2 int left = 0, right = 100000, ans = 0, mid; while (left \u0026lt;= right) { mid = left + (right - left) / 2; if (getMaxApples((long)mid) \u0026gt;= neededApples) { ans = mid; right = mid - 1; } else { left = mid + 1; } } return ans * 8; } public long getMaxApples(long x) { return (2 * x + 1) * (x + 1) * x * 2; } } ","date":"2023-12-24T20:50:40+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-1954.-%E6%94%B6%E9%9B%86%E8%B6%B3%E5%A4%9F%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%B0%8F%E8%8A%B1%E5%9B%AD%E5%91%A8%E9%95%BF/","title":"LeetCode 1954. 收集足够苹果的最小花园周长"},{"content":" LeetCode 968. 监控二叉树\n算法讲解079【必备】树型dp-下\n思路 要使设置的摄像头数量尽量小，就需要让每个摄像头都尽量覆盖更多的节点，避免重复覆盖。因此可以使用贪心策略，自底向上，尽量使用最少的摄像头。\n求解过程 节点状态\n0：表示当前节点无摄像头监控，也无摄像头。 1：表示当前节点被摄像头监控，但是没有摄像头。 2：表示当前节点被摄像头监控，有摄像头。 设置摄像头\n为了使摄像头个数最少，我们让叶子节点不设置摄像头，让其父节点设置摄像头。而一般节点则根据左右子节点的覆盖状态，来决定是否布置摄像头。\n当前节点为空节点：可以看作状态 1，被监控，但是没有摄像头，这样也不会影响上面的节点。\n当前节点为非空节点：\na. 如果左右节点存在状态 0:说明子节点存在没有被覆盖的情况，这个时候就必须在当前节点设置摄像头，计数加一，返回状态 2。\nb. 否则继续判断，如果左右节点存在状态 2: 说明左右子节点不存在状态 0，存在状态 2，当前节点被子节点覆盖，不需要设置摄像头，返回状态 1。\nc. 否则，左右子节点只能都是状态 1：即左右子节点都被覆盖，但是没有摄像头，为了使摄像头数量最少，当前节点先不覆盖，让父节点覆盖，返回状态 0。\n调用递归函数，判断头节点是否被覆盖。如果头节点返回状态 0，则头节点没有被覆盖，必须补上一个摄像头。\n复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { int ans = 0; public int minCameraCover(TreeNode root) { if (process(root) == 0) { ans++; } return ans; } // 定义状态 // 1. 0 没有被监控，且没有摄像头 // 2. 1 被监控，但是没有摄像头 // 3. 2 被监控，且存在摄像头 public int process(TreeNode node) { if (node == null) { return 1; } int status1 = process(node.left); int status2 = process(node.right); if (status1 == 0 || status2 == 0) { ans++; return 2; } if (status1 == 2 || status2 == 2) { return 1; } return 0; } } ","date":"2023-12-24T16:08:45+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-968.-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"LeetCode 968. 监控二叉树"},{"content":" LeetCode 437. 路径总和 III\n算法讲解079【必备】树型dp-下\n思路 记录下二叉树路径的前缀和，每来到一个节点就判断是否存在区间和为目标值。如果存在，就将记录加一。\n求解过程 因为求区间和只跟当前节点之前的路径有关，因此可以使用二叉树的前序遍历。\n遍历到某节点时，计算到当前位置的前缀和，从哈希表中查出要得出目标值需要的前缀和为多少，将次数加入到结果中。 然后将当前位置的前缀和次数加一，记录到哈希表中，继续遍历左右子节点。遍历结束后，将当前位置的前缀和次数再减一。 复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { HashMap\u0026lt;Long, Integer\u0026gt; count = new HashMap\u0026lt;\u0026gt;(); int ans = 0; public int pathSum(TreeNode root, int targetSum) { count.put(0L, 1); process(root, targetSum, 0L); return ans; } public void process(TreeNode node, int target, long sum) { if (node == null) { return; } // 前缀和 sum += node.val; ans += count.getOrDefault(sum - target, 0); count.put(sum, count.getOrDefault(sum, 0) + 1); process(node.left, target, sum); process(node.right, target, sum); count.put(sum, count.get(sum) - 1); } } ","date":"2023-12-23T22:42:50+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-437.-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-iii/","title":"LeetCode 437. 路径总和 III"},{"content":" 洛谷 P1352 没有上司的舞会\n算法讲解079【必备】树型dp-下\n思路 求子问题：求出每个树在头节点去与不去的最大快乐值。每棵树的最大快乐值取决于子树返回的信息，根据子树信息求出当前树的信息，不断向上返回，最终得到整棵树的去与不去的最大快乐值。\n求解过程 使用链式前向星建图，求出校长节点。\n从校长节点开始往下递归，先求出子树的信息，然后根据子树的信息，求出当前节点去与不去的最大快乐值，一路向上返回，就得到了校长去与不去的最大快乐值。在校长去与不去中，选择快乐值最大的。\na. 当前节点不去：最大快乐值等于 子树头节点去与不去的最大值进行累加。\nb. 当前节点去：最大快乐值等于 当前节点快乐值加上子树头节点不去的最大快乐值之和。\n复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 import java.io.*; import java.util.Arrays; public class Main { public static int MAXN = 6001; public static int MAXM = 6001; public static int[] head = new int[MAXN]; public static int[] next = new int[MAXM]; public static int[] to = new int[MAXM]; public static int[] value = new int[MAXN]; public static boolean[] boss = new boolean[MAXN]; public static int[][] ans = new int[MAXN][2]; public static int cnt, n, principal; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer in = new StreamTokenizer(br); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while (in.nextToken() != StreamTokenizer.TT_EOF) { n = (int)in.nval; init(); Arrays.fill(boss, 1, n + 1, true); for (int i = 1; i \u0026lt;= n; i++) { in.nextToken(); value[i] = (int)in.nval; } for (int i = 1, u, v; i \u0026lt;= n - 1; i++) { in.nextToken(); v = (int)in.nval; in.nextToken(); u = (int)in.nval; boss[v] = false; addEdge(u, v); } // 找到校长。 for (int i = 1; i \u0026lt;= n; i++) { if (boss[i]) { principal = i; break; } } compute(principal); out.println(Math.max(ans[principal][0], ans[principal][1])); } out.flush(); out.close(); br.close(); } public static void init() { Arrays.fill(head, 0, n + 1, 0); cnt = 1; } // 将 u -\u0026gt; v 这条边建出来 public static void addEdge(int u, int v) { next[cnt] = head[u]; to[cnt] = v; head[u] = cnt++; } public static void compute(int u) { ans[u][0] = 0; ans[u][1] = value[u]; for (int e = head[u], v; e != 0; e = next[e]) { v = to[e]; compute(v); ans[u][0] += Math.max(ans[v][0], ans[v][1]); ans[u][1] += ans[v][0]; } } } ","date":"2023-12-23T22:22:05+08:00","permalink":"https://zhuaowei.github.io/article/%E6%B4%9B%E8%B0%B7-p1352-%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A/","title":"洛谷 P1352 没有上司的舞会"},{"content":" LeetCode 337. 打家劫舍 III\n算法讲解079【必备】树型dp-下\n思路 先求出左右子节点可以在偷与不偷时可以获取的最大金额，然后根据子节点的信息汇总出当前节点偷与不偷的最大金额。\n求解过程 在求出本节点的信息之前，需要先获取左右子节点的信息，所以需要使用二叉树的后序遍历。\n如果当前节点是空节点，那么偷与不偷的金额都是 0。\n如果非空，则先递归求出子节点的信息，当期节点偷与不偷分别讨论：\na. 如果当前节点不偷，那么在左右子节点中分别选择偷与不偷的最大值进行相加。\nb. 如果当前节点偷，那么在左右子节点中选择不偷的值相加，再加上本节点的值。\n复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int rob(TreeNode root) { int[] ans = process(root); return Math.max(ans[0], ans[1]); } public int[] process(TreeNode node) { int[] ans = new int[2]; if (node == null) { return ans; } int[] LInfo = process(node.left); int[] RInfo = process(node.right); // 当前不能偷，就在左右孩子中挑最大的。 ans[0] = Math.max(LInfo[0], LInfo[1]) + Math.max(RInfo[0], RInfo[1]); ans[1] = LInfo[0] + RInfo[0] + node.val; return ans; } } ","date":"2023-12-23T21:33:14+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-337.-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-iii/","title":"LeetCode 337. 打家劫舍 III"},{"content":" LeetCode 979. 在二叉树中分配硬币\n算法讲解079【必备】树型dp-下\n思路 从树的底层依次向上求，求出当前节点平均分配硬币移动的最小步数。当前节点的最小步数为 树的节点个数减硬币个数的绝对值。\n求解过程 当前节点的最小步数为 树的节点个数减硬币个数的绝对值。因此需要先使用后序遍历，求出左右子树的节点个数和硬币数。\n当前节点为空节点：节点个数为 0，硬币个数为 0。 当前节点非空：先求出左右子树的节点个数和硬币个数，然后计算出当前树的节点个数和硬币树。求当前树的最小移动次数，累加到总答案中。 复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { class Info { int coins; int count; Info (int a, int b) { coins = a; count = b; } } int ans = 0; public int distributeCoins(TreeNode root) { process(root); return ans; } public Info process(TreeNode node) { if (node == null) { return new Info(0, 0); } Info leftInfo = process(node.left); Info rightInfo = process(node.right); int count = leftInfo.count + rightInfo.count + 1; int coins = leftInfo.coins + rightInfo.coins + node.val; ans += Math.abs(count - coins); return new Info(coins, count); } } ","date":"2023-12-23T21:01:39+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-979.-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%88%86%E9%85%8D%E7%A1%AC%E5%B8%81/","title":"LeetCode 979. 在二叉树中分配硬币"},{"content":" LeetCode 543. 二叉树的直径\n算法讲解079【必备】树型dp-下\n思路 求当前节点的最大直径时，分为经过当前节点和不经过当前节点，因此需要记录下左右子树的最大直径和最大高度，求出两种可能性的最大值。\n求解过程 求当前节点的最大直径时，需要用到左右子树的信息，所以需要用到二叉树的后续遍历。\n当前节点为空树时：节点最大高度为 0，树的最大直径为 0。\n当前节点非空时：\na. 如果经过该节点：最大直径为 左树最大高度 + 右树最大高度。\nb. 如果不经过该节点：最大直径为 左树最大直径和右树最大直径的最大值。\n因为直径为两节点之间经过的边数，而不是节点数，所以求经过当前节点的最大直径时，不需要再加一。\n复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { class Info { int height; int diameter; Info(int h, int d) { height = h; diameter = d; } } public int diameterOfBinaryTree(TreeNode root) { return process(root).diameter; } public Info process(TreeNode node) { if (node == null) { return new Info(0, 0); } Info infoLeft = process(node.left); Info infoRight = process(node.right); int height = 1 + Math.max(infoLeft.height, infoRight.height); int diameter = Math.max(Math.max(infoLeft.diameter, infoRight.diameter), infoLeft.height + infoRight.height); return new Info(height, diameter); } } ","date":"2023-12-23T20:53:06+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-543.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/","title":"LeetCode 543. 二叉树的直径"},{"content":" LeetCode 2127. 参加会议的最多员工数\n算法讲解060【必备】拓扑排序的扩展技巧\n思路 根据题意，一共 n 个点，n 条边，并且每一个点出发只有一条边，说明该图肯定存在环。根据环的大小分为大环和小环，也就有了两种安排座位的方案，分别计算两种方案的人数，取较大者。\nn 个点和 n 条边组成的图就是基环树。如果每个点只有一条出边，则看起来是向内的，这种也叫内向基环树。如果每个点只有一条入边，则它为外向基环树。\n求解过程 两种方案\n根据题意可知，图中存在环，根据环的大小将环分为两种：\n小环（size == 2）：遇到这种环，可以现将环安排到座位上，然后再将环上两个节点延伸出来的链安排到座位上。根据贪心原则，我们要尽量选择链长的安排座位。同时，因为座位上原本是链上的点都指向环的节点，因此多个小环的安排方案并不冲突，可以都安排到座位上。 大环（size \u0026gt;= 3）：只能将环上的人安排到座位，且这些座位上的点是收尾相接的，无法插入其他点，所以只能选择最大的环。 最终得到两种方案可以安排的最大人数，取最大值。\n环的计算\n首先按照拓扑排序，统计出每个环山的点，不算自己，可以延伸的最长的链是多长。 经历过拓扑排序后，只剩下环上的点入度不为 0，所以依次遍历所有点，判断入度是否为 0。 如果入度不为 0，从该点出发，遍历环的一周，计算出环的大小。（为了防止重复计算，每经过一个点，将它的入度减一） 根据环的大小和上面的两种方案，分别计算出两种方案的人数，最终返回较大者。 复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { public int maximumInvitations(int[] favorite) { int n = favorite.length; int[] indegree = new int[n]; int[] queue = new int[n]; int[] cnt = new int[n]; int h = 0, t = 0; for (int v : favorite) { indegree[v]++; } for (int i = 0; i \u0026lt; n; i++) { if (indegree[i] == 0) { queue[t++] = i; } } while (h \u0026lt; t) { int u = queue[h++]; int v = favorite[u]; cnt[v] = Math.max(cnt[v], 1 + cnt[u]); if (--indegree[v] == 0) { queue[t++] = v; } } // 将有向图的枝通过拓扑排序全部剪掉，只剩下环 // 如果环的大小为 2，则为这两点连着的最长的链之和再加上 2，多个小环可以一起坐下 // 如果环的大小\u0026gt;= 3，则只能坐下这个环内的人数，其他人无法插入。 int small = 0, big = 0; // 分别计算大环和小环的方案最大人数。 for (int i = 0; i \u0026lt; n; i++) { if (indegree[i] != 0) { int size = 0, start = i; while (indegree[start] != 0) { indegree[start]--; size++; start = favorite[start]; } // 判断环的大小 if (size == 2) { // 环为 2 时，可以将多组放到一个桌子 small += cnt[i] + cnt[favorite[i]] + 2; } else { big = Math.max(big, size); } } } return Math.max(small, big); } } ","date":"2023-12-23T15:52:28+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2127.-%E5%8F%82%E5%8A%A0%E4%BC%9A%E8%AE%AE%E7%9A%84%E6%9C%80%E5%A4%9A%E5%91%98%E5%B7%A5%E6%95%B0/","title":"LeetCode 2127. 参加会议的最多员工数"},{"content":" LeetCode 2050. 并行课程 III\n算法讲解060【必备】拓扑排序的扩展技巧\n思路 完成某一个课程的最短时间为完成所有前置课程的最大时间加上本课程的时间。根据课程的前置关系建图，按照拓扑排序求出下一门课程的最短时间，即完成前置课程和下一门课程的最大时间。\n求解过程 首先通过前置课程关系建图，统计入度。 将所有入度为 0 的点加入队列，这些点的最短完成时间为自身所需的时间。然后开始遍历队列。 按照拓扑排序进行遍历，下一门课程的最小完成时间等于当前课程的完成时间加上下一门课程的时间，与完成下一门课程的最小时间比较，取较大值。 复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public int minimumTime(int n, int[][] relations, int[] time) { ArrayList\u0026lt;Integer\u0026gt;[] graph = new ArrayList[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { graph[i] = new ArrayList\u0026lt;Integer\u0026gt;(); } int[] indegree = new int[n + 1]; int[] ans = new int[n + 1]; for (int[] re : relations) { graph[re[0]].add(re[1]); indegree[re[1]]++; } int[] queue = new int[n + 1]; int h = 0, t = 0; for (int i = 1; i \u0026lt;= n; i++) { if (indegree[i] == 0) { queue[t++] = i; ans[i] = time[i - 1]; } } int res = 0; while (h \u0026lt; t) { int from = queue[h++]; res = Math.max(res, ans[from]); for (int to : graph[from]) { ans[to] = Math.max(ans[to], ans[from] + time[to - 1]); if (--indegree[to] == 0) { queue[t++] = to; } } } return res; } } ","date":"2023-12-23T15:12:06+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2050.-%E5%B9%B6%E8%A1%8C%E8%AF%BE%E7%A8%8B-iii/","title":"LeetCode 2050. 并行课程 III"},{"content":" LeetCode 1962. 移除石子使总数最小\n思路 每次找出数组中的最大值，使其值减半，然后循环 k 次，求出最终的数组之和。\n求解过程 因为数组是会变化的，需要时刻维护数组中的最大值，因此可以使用堆来排序，使用大根堆每次取出数组中的最大值。\n首先将数组中的石头数量添加到堆。 使堆顶的数字减半，这个时候并不需要出堆，只需要将减半后的堆顶向下压。 循环步骤 2，执行 k 次后，求出最终数组的和。 复杂度 时间复杂度：$O(n \\times log_2n)$ 空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Solution { int[] heap; int size = 0; public int minStoneSum(int[] piles, int k) { // 大根堆 int n = piles.length; heap = new int[n]; for (int i = 0; i \u0026lt; n; i++) { add(piles[i]); } for (int i = 0; i \u0026lt; k; i++) { poll(); } int sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += heap[i]; } return sum; } public void add(int value) { heap[size++] = value; int index = size - 1; int up = (index - 1) / 2; while (heap[index] \u0026gt; heap[up]) { swap(heap, index, up); index = up; up = (index - 1) / 2; } } public int poll() { int value = heap[0]; heap[0] -= heap[0] / 2; // 将 0 位置向下压 int index = 0; int left = index * 2 + 1; while (left \u0026lt; size) { int larger = heap[index] \u0026gt; heap[left] ? index : left; int largest = left + 1 \u0026lt; size \u0026amp;\u0026amp; heap[left + 1] \u0026gt; heap[larger] ? left + 1 : larger; if (largest == index) { break; } else { swap(heap, index, largest); } index = largest; left = index * 2 + 1; } return value; } public void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } } ","date":"2023-12-23T11:46:09+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-1962.-%E7%A7%BB%E9%99%A4%E7%9F%B3%E5%AD%90%E4%BD%BF%E6%80%BB%E6%95%B0%E6%9C%80%E5%B0%8F/","title":"LeetCode 1962. 移除石子使总数最小"},{"content":" LeetCode 851. 喧闹和富有\n算法讲解060【必备】拓扑排序的扩展技巧\n思路 根据输入的财富关系，我们可以得到一个财富关系图，按照拓扑排序从最有钱的依次遍历，比较前后两人的安静值，得到更符合要求的答案。\n求解过程 首先建图，使用邻接表法，统计节点的入度。同时准备好结果数组，将默认值设置为当前节点。 使用拓扑排序遍历节点，将出发节点与目标节点的安静值进行比较，将更安静的节点赋值目标节点。 复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public int[] loudAndRich(int[][] richer, int[] quiet) { int n = quiet.length; int[] ans = new int[n]; int[] indegree = new int[n]; int[] queue = new int[n]; int h = 0, t = 0; ArrayList\u0026lt;Integer\u0026gt;[] graph = new ArrayList[n]; for (int i = 0; i \u0026lt; n; i++) { graph[i] = new ArrayList\u0026lt;Integer\u0026gt;(); } for (int[] edge : richer) { graph[edge[0]].add(edge[1]); indegree[edge[1]]++; } // 拓扑排序 for (int i = 0; i \u0026lt; n; i++) { if (indegree[i] == 0) { queue[t++] = i; } ans[i] = i; } while (h \u0026lt; t) { int from = queue[h++]; for (int to : graph[from]) { // 如果出发点比目的点更安静，赋值给目的点。 if (quiet[ans[to]] \u0026gt; quiet[ans[from]]) { ans[to] = ans[from]; } if (--indegree[to] == 0) { queue[t++] = to; } } } return ans; } } ","date":"2023-12-22T23:13:31+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-851.-%E5%96%A7%E9%97%B9%E5%92%8C%E5%AF%8C%E6%9C%89/","title":"LeetCode 851. 喧闹和富有"},{"content":" 洛谷 P4017 最大食物链计数\n算法讲解060【必备】拓扑排序的扩展技巧\n思路 到达某生物的食物链条数等于所有被他吃的生物的链数之和。生物链的关系可以看作一个有向无环图，按照拓扑排序将食物链条数从被捕食者传递到捕食者，最终得到整个生物捕食关系的食物链总数。\n求解过程 首先建图，使用链式前向星法。同时统计每个节点的入度，用于拓扑排序。 如果遍历所有节点，将入度为 0 的点加入队列，这些店都是处于食物链最底层的生物，设置他们的食物链条数为 1. 按照拓扑排序遍历队列中的点。如果队列中的点没有后续节点了，说明它是处于食物链顶层的生物，累计到生物链条数中。如果还有节点，按照拓扑排序的规则减少目的点入度，将入度为 0 的节点添加到队列。 复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 import java.io.*; import java.util.Arrays; public class Main { public static int MAXN = 5001; public static int MAXM = 500001; public static int MOD = 80112002; public static int[] head = new int[MAXN]; public static int[] next = new int[MAXM]; public static int[] to = new int[MAXM]; public static int[] indegree = new int[MAXN]; public static int[] queue = new int[MAXN]; public static int[] ans = new int[MAXN]; public static int cnt, h, t, n, m; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer in = new StreamTokenizer(br); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while (in.nextToken() != StreamTokenizer.TT_EOF) { n = (int)in.nval; in.nextToken(); m = (int)in.nval; // 初始化 init(); for (int i = 1, u, v; i \u0026lt;= m; i++) { in.nextToken(); u = (int)in.nval; in.nextToken(); v = (int)in.nval; addEdge(u, v); indegree[v]++; } out.println(compute()); } out.flush(); out.close(); br.close(); } public static void init() { Arrays.fill(head, 0, n + 1, 0); Arrays.fill(indegree, 0, n + 1, 0); Arrays.fill(ans, 0, n + 1, 0); cnt = 1; h = t = 0; } public static void addEdge(int u, int v) { next[cnt] = head[u]; to[cnt] = v; head[u] = cnt++; } // 食物链不会存在环，也就是拓扑排序的后节点个数等于 n public static int compute() { for (int i = 1; i \u0026lt;= n; i++) { if (indegree[i] == 0) { queue[t++] = i; // i 处于食物链最底层，初始化食物链条数为 1 ans[i] = 1; } } int u, v, res = 0; while (h \u0026lt; t) { u = queue[h++]; if (head[u] == 0) { // 到达食物链顶层，累计结果 res = (res + ans[u]) % MOD; } else { // 否则继续遍历 for (int e = head[u]; e != 0; e = next[e]) { v = to[e]; ans[v] = (ans[u] + ans[v]) % MOD; if (--indegree[v] == 0) { queue[t++] = v; } } } } return res; } } ","date":"2023-12-22T22:40:29+08:00","permalink":"https://zhuaowei.github.io/article/%E6%B4%9B%E8%B0%B7-p4017-%E6%9C%80%E5%A4%A7%E9%A3%9F%E7%89%A9%E9%93%BE%E8%AE%A1%E6%95%B0/","title":"洛谷 P4017 最大食物链计数"},{"content":" 洛谷 U107394 拓扑排序模板\n算法讲解059【必备】建图、链式前向星、拓扑排序\n思路 牛客网和 leetcode 可以使用邻接表法建图，而洛谷是专为比赛用的，所以必须使用链式前向星建图。题目要求获得字典序最小的拓扑排序，所以可以使用小根堆存储入度为 0 的节点，这样每次弹出的节点都是满足要求的节点中字典序最小的。\n求解过程 使用链式前向星建图，同时统计每个节点的入度。 将入度为 0 的节点加入堆。 依次从堆中弹出一个节点，直到堆为空。 遍历弹出节点的每一条边，将目的节点的入度减一，如果减之后为 0，添加到堆。循环 3 4 步骤。 关于链式前向星建图：LeetCode 210. 课程表 II\n关于小根堆的添加和弹出，可以参考本文的代码和注释。\n复杂度 时间复杂度：$O(n \\times log_2n)$ 每个节点都会进入堆一次，出堆一次。进出的时间复杂度都是 $log_2n$\n空间复杂度：$O(n + m)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 import java.io.*; import java.util.Arrays; public class Main { public static int MAXN = 200001; public static int MAXM = 200001; public static int[] head = new int[MAXN]; // public static int[] weight = new int[MAXN]; public static int[] next = new int[MAXM]; public static int[] to = new int[MAXM]; public static int[] indegree = new int[MAXN]; public static int[] ans = new int[MAXN]; public static int[] heap = new int[MAXN]; public static int cnt, h, t, n, m, heapSize; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer in = new StreamTokenizer(br); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while (in.nextToken() != StreamTokenizer.TT_EOF) { n = (int)in.nval; in.nextToken(); m = (int)in.nval; // 初始化 init(); for (int i = 1, u, v; i \u0026lt;= m; i++) { in.nextToken(); u = (int)in.nval; in.nextToken(); v = (int)in.nval; addEdge(u, v); indegree[v]++; } if (compute()) { for (int i = 0; i \u0026lt; n - 1; i++) { out.print(ans[i] + \u0026#34; \u0026#34;); } out.println(ans[n - 1]); } else { out.println(-1); } } out.flush(); out.close(); br.close(); } public static void init() { Arrays.fill(head, 0, n + 1, 0); Arrays.fill(indegree, 0, n + 1, 0); cnt = 1; heapSize = 0; } // 将 u -\u0026gt; v 这条边建出来 public static void addEdge(int u, int v) { next[cnt] = head[u]; to[cnt] = v; // weight[cnt] = w // 权值 head[u] = cnt++; } public static boolean compute() { // 返回是否能完成拓扑排序 for (int i = 1; i \u0026lt;= n; i++) { if (indegree[i] == 0) { // 插入堆 add(i); } } int index = 0; while (heapSize \u0026gt; 0) { int node = poll(); ans[index++] = node; for (int e = head[node]; e != 0; e = next[e]) { if (--indegree[to[e]] == 0) { add(to[e]); } } } return true; } // 小根堆 public static void add(int val) { // 先添加到堆的末尾，然后逐渐向上层移动。 heap[heapSize] = val; int index = heapSize; // 当前位置 // 如果当前节点比父节点小，交换父节点和当前节点 while (heap[index] \u0026lt; heap[(index - 1) / 2]) { // 交换 swap(heap, index, (index - 1) / 2); index = (index - 1) / 2; } // 添加完毕后，堆的大小加一 heapSize++; } public static int poll() { // 堆顶的值，为数组中的最小值，需要返回这个 int value = heap[0]; // 将堆顶的值交换到末尾，堆的大小减一 swap(heap, 0, --heapSize); // 向下移动 // 现在堆顶的值是一个比较大的值，需要将它向下移动 int index = 0; int left = 1; // 左孩子 while (left \u0026lt; heapSize) { // 当前节点和左孩子谁比较小 int less = heap[left] \u0026lt; heap[index] ? left : index; // 较小值与右孩子谁更小（如果有） int lest = left + 1 \u0026lt; heapSize \u0026amp;\u0026amp; heap[left + 1] \u0026lt; heap[less] ? left + 1 : less; // 如果三者最小值是自己，不需要向下移动了 if (lest == index) { break; } else { // 否则与最小值交换，继续向下移动 swap(heap, index, lest); } index = lest; left = 2 * index + 1; } return value; } // 交换数组中的两个值 public static void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } } ","date":"2023-12-22T16:35:28+08:00","permalink":"https://zhuaowei.github.io/article/%E6%B4%9B%E8%B0%B7-u107394-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF/","title":"洛谷 U107394 拓扑排序模板"},{"content":" LeetCode 1671. 得到山形数组的最少删除次数\n思路 先正向求出每个位置最长的递增子序列长度，然后逆序求出每个位置最长的递增子序列的长度，同时求出最大的山脉宽度，剩下的就是最少的删除次数。\n求解过程 定义一个 $end$ 数组，$end_i$ 表示 长度为 $i + 1$ 的递增子序列的最小结尾。\n当来到 $i$ 位置时，在 $end$ 数组中找到一个大于等于 $nums_i$ 的最左侧的索引：\n如果存在为 $j$，则 $nums_i$ 可以替换掉 $end_j$ ，成为长度为 $j + 1$ 的递增子序列的最小结尾，$i$ 位置的最长递增子序列长度为 $j + 1$. 如果不存在 $j$，则说明 $nums_i$ 可以添加到 $end$ 数组的后面，将最长递增子序列的长度扩充一个长度，$i$ 位置的最长递增子序列长度为 $len$。 我们使用一个数组 $pre$ 存储 $i$ 位置及以前的数组中最长递增子序列的长度。然后开始逆向遍历，求出 $i$ 位置及之后的数组中最长递增子序列的长度，二者相加再减去重复的 $i$ 位置，即为以 $i$ 位置为顶点的山地长度。求出了山地长度的最大值，也就得到了删除次数的最小值。\n注意\n因为山地的条件是：山顶及左侧必须是递增子序列，山顶及右侧也必须是递增子序列，所以在计算山脉长度之前，必须先判断 $i$ 位置左右两侧的最长递增子序列长度是否都大于等于 2。\n复杂度 时间复杂度：$O(n \\times log_2n)$ 空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public int minimumMountainRemovals(int[] nums) { // 最长递增子序列 int n = nums.length; int[] end = new int[n]; int[] pre = new int[n]; end[0] = nums[0]; pre[0] = 1; int len = 1; for (int i = 1, index; i \u0026lt; n; i++) { index = find(end, len, nums[i]); if (index == -1) { end[len++] = nums[i]; pre[i] = len; } else { end[index] = nums[i]; pre[i] = index + 1; } } int ans = 0; end[0] = nums[n - 1]; len = 1; for (int i = n - 2, index, temp; i \u0026gt; 0; i--) { index = find(end, len, nums[i]); if (index == -1) { end[len++] = nums[i]; temp = len; } else { end[index] = nums[i]; temp = index + 1; } if (pre[i] \u0026gt; 1 \u0026amp;\u0026amp; temp \u0026gt; 1) { ans = Math.max(ans, pre[i] + temp - 1); } } return n - ans; } public int find(int[] end, int len, int target) { int left = 0, right = len - 1, mid, ans = -1; while (left \u0026lt;= right) { mid = left + (right - left) / 2; if (end[mid] \u0026gt;= target) { ans = mid; right = mid - 1; } else { left = mid + 1; } } return ans; } } ","date":"2023-12-22T15:46:53+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-1671.-%E5%BE%97%E5%88%B0%E5%B1%B1%E5%BD%A2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%A0%E9%99%A4%E6%AC%A1%E6%95%B0/","title":"LeetCode 1671. 得到山形数组的最少删除次数"},{"content":" LeetCode 936. 戳印序列\n算法讲解059【必备】建图、链式前向星、拓扑排序\n思路 盖印的顺序可以想象为一个图，如果前后两次盖印的区间有重叠部分，后面的印可以修正前面错误的位置，如果重叠部分存在错误字符，则可以认为二者之间存在一条“前后盖印的关系”，求出拓扑排序的逆序即为盖印的顺序。\n求解过程 盖印的先后可以认为存在一条边，但是并不是所有的前后盖印都存在边。盖印的区间必须有重叠部分，且重叠部分的字符必须是错的，这样，后面的印才能将先盖的覆盖掉。\n初始时，我们认为字符串的每一个位置都有 m 条边（m 为印的长度），也就是说每一个覆盖此字符的印都被印错了，需要后面的印修正。\n然后遍历印在每一个位置的印章结果，如果正确，说明该字符不需要当前印章修正，入度减一，如果存在入度为 0 的点，说明该印章的所有位置都是正确的，是最后印的。如果错误，说明需要后面的印章进行修正，先建立一条边，方便后面修正。\n根据拓扑排序，后印的字符可以修正错误的字符，也就是入度为 0 的点可以修正其他点，所以将该点指向其他错误的点的入度减一，如果修正后的印也全部正确（入度为 0），那么它可以修正其他的点。\n因为印章可能存在频繁修，所以对于已经修正的位置，记录下来，下次修正时直接跳过。入队的顺序即为拓扑排序的顺序，所以可以直接将队列作为结果数组。因为拓扑排序的顺序与盖印的顺序是相反的，所以需要将拓扑排序逆序输出。\n复杂度 时间复杂度：$O(nm)$ 空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public int[] movesToStamp(String stamp, String target) { char[] s = stamp.toCharArray(); char[] t = target.toCharArray(); int m = s.length, n = t.length; int size = n - m + 1; ArrayList\u0026lt;ArrayList\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { graph.add(new ArrayList\u0026lt;Integer\u0026gt;()); } int[] indegree = new int[size]; int[] queue = new int[size]; int h = 0, r = 0; Arrays.fill(indegree, m); for (int i = 0; i \u0026lt; size; i++) { for (int j = 0; j \u0026lt; m; j++) { if (s[j] == t[i + j]) { if (--indegree[i] == 0) { queue[r++] = i; } } else { graph.get(i + j).add(i); } } } boolean[] vis = new boolean[n]; while (h \u0026lt; r) { int node = queue[h++]; for (int j = 0; j \u0026lt; m; j++) { if (!vis[node + j]) { vis[node + j] = true; for (int next : graph.get(node + j)) { if (--indegree[next] == 0) { queue[r++] = next; } } } } } if (h == size) { for (int i = 0, temp; i \u0026lt; size / 2; i++) { temp = queue[i]; queue[i] = queue[size - i - 1]; queue[size - i - 1] = temp; } return queue; } else { return new int[0]; } } } ","date":"2023-12-21T19:53:03+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-936.-%E6%88%B3%E5%8D%B0%E5%BA%8F%E5%88%97/","title":"LeetCode 936. 戳印序列"},{"content":" LeetCode 2866. 美丽塔 II\n思路 根据题意，需要在高度限制下建塔，使得最终的塔能够形成一个山脉的形状。山脉的形状就是，从两侧到山顶是非严格递增的。所以我们可以假设每一个位置作为山顶，求出它左侧非严格递增，右侧非严格递减的子数组之和的最大值。\n求解过程 先求出从 $0$ 到 $i$ 位置，以 $i$ 为山顶的非严格递增子数组的最大和。然后逆序遍历，求出从 $n - 1$ 到 $i$ 位置的以 $i$ 为山顶的非严格递增子数组的最大和，二者相加再去掉重复的顶点，就是以 $i$ 为山顶的山脉之和。\n在求以 $i$ 为山脉的左侧最大和时，使用单调栈求解。假设当前在 $i$ 位置，左侧比它小的位置是 $j$，那么在 $[j + 1, i]$ 这段只能全部为 $nums_i$，而 $[0, j]$ 范围的最大和为 $pre_j$，那么 $i$ 位置左侧的最大和就是 $pre_j + (i - j + 1) \\times nums_i$。\n同理可以求出右侧以 $i$ 为山脉的最大和，那么 $pre_i + sub_i - nums_i$ 即为以 $i$ 为山顶的山脉之和。\n复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public long maximumSumOfHeights(List\u0026lt;Integer\u0026gt; maxHeights) { int n = maxHeights.size(); int[] stack = new int[n]; int r = 0; long[] pre = new long[n]; long[] sub = new long[n]; // 求出从 0 到 i 能组成的最大的非降序数组（必须以 i 为最高点） for (int i = 0; i \u0026lt; n; i++) { while (r \u0026gt; 0 \u0026amp;\u0026amp; maxHeights.get(i) \u0026lt;= maxHeights.get(stack[r - 1])) { r--; } long p = r \u0026gt; 0 ? pre[stack[r - 1]] : 0; int left = r \u0026gt; 0 ? stack[r - 1] : -1; pre[i] = p + (long)maxHeights.get(i) * (i - left); stack[r++] = i; } r = 0; long ans = 0; // 求出从 i 到 n - 1 能组成的最大的非升序数组（必须以 i 为最高点） for (int i = n - 1; i \u0026gt;= 0; i--) { while (r \u0026gt; 0 \u0026amp;\u0026amp; maxHeights.get(i) \u0026lt;= maxHeights.get(stack[r - 1])) { r--; } long s = r \u0026gt; 0 ? sub[stack[r - 1]] : 0; int right = r \u0026gt; 0 ? stack[r - 1] : n; sub[i] = s + (long)maxHeights.get(i) * (right - i); ans = Math.max(ans, pre[i] + sub[i] - maxHeights.get(i)); stack[r++] = i; } return ans; } } ","date":"2023-12-21T14:43:24+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2866.-%E7%BE%8E%E4%B8%BD%E5%A1%94-ii/","title":"LeetCode 2866. 美丽塔 II"},{"content":" 牛客网 【模板】拓扑排序\n算法讲解059【必备】建图、链式前向星、拓扑排序\n思路 首先使用链式前向星建图，同时统计点的入度。然后遍历所有节点，将入度为 0 的点加入队列，遍历队列的每一个点，消除出队节点的影响，将消除影响后入度为 0 的点加入队列，直到不存在入度为 0 的点。\n求解过程 具体的求解过程可以参考: LeetCode 2276. 统计区间中的整数数目\n注意\n一般是竞赛的时候使用链式前向星，而这个时候要重复使用开辟的空间，就需要对上次使用过的数组进行清空。清空是只需要清空 head数组和 indegree 数组，并将 cnt 设置为 1。\n因为 head 数组默认应该存储的是 0，表示该节点已经没有边了，所以要清空，indegree 在建图时是自增，需要重置。而 next 数组和 to 数组，在建图的过程中会覆盖已有的数据，所以可以不用重置为 0，只需要将 cnt 设置为 1 即可，图的编号重新从 1 开始。\n复杂度 时间复杂度：$O(m)$ 空间复杂度：$O(n + m)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 import java.io.*; import java.util.Arrays; public class Main { public static int MAXN = 200001; public static int MAXM = 200001; public static int[] head = new int[MAXN]; // public static int[] weight = new int[MAXN]; public static int[] next = new int[MAXM]; public static int[] to = new int[MAXM]; public static int[] indegree = new int[MAXN]; public static int[] queue = new int[MAXN]; public static int cnt, h, t, n, m; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer in = new StreamTokenizer(br); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while (in.nextToken() != StreamTokenizer.TT_EOF) { n = (int)in.nval; in.nextToken(); m = (int)in.nval; // 初始化 init(); for (int i = 1, u, v; i \u0026lt;= m; i++) { in.nextToken(); u = (int)in.nval; in.nextToken(); v = (int)in.nval; addEdge(u, v); indegree[v]++; } if (compute()) { for (int i = 0; i \u0026lt; t - 1; i++) { out.print(queue[i] + \u0026#34; \u0026#34;); } out.println(queue[t - 1]); } else { out.println(-1); } } out.flush(); out.close(); br.close(); } public static void init() { Arrays.fill(head, 0, n + 1, 0); Arrays.fill(indegree, 0, n + 1, 0); cnt = 1; h = t = 0; } // 将 u -\u0026gt; v 这条边建出来 public static void addEdge(int u, int v) { next[cnt] = head[u]; to[cnt] = v; // weight[cnt] = w // 权值 head[u] = cnt++; } public static boolean compute() { // 返回是否能完成拓扑排序 for (int i = 1; i \u0026lt;= n; i++) { if (indegree[i] == 0) { queue[t++] = i; } } while (h \u0026lt; t) { int node = queue[h++]; for (int e = head[node]; e != 0; e = next[e]) { if (--indegree[to[e]] == 0) { queue[t++] = to[e]; } } } return t == n; } } ","date":"2023-12-20T22:47:07+08:00","permalink":"https://zhuaowei.github.io/article/%E7%89%9B%E5%AE%A2%E7%BD%91-%E6%A8%A1%E6%9D%BF%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","title":"牛客网 【模板】拓扑排序"},{"content":" LeetCode 210. 课程表 II\n算法讲解059【必备】建图、链式前向星、拓扑排序\n思路 建图有很多种方式，常用的有邻接表法和邻接矩阵法。邻接矩阵法在点集很大的情况下很浪费空间，因为它的空间复杂度是 $O(n^2)$ 的。邻接表法在算法开始前是无法确定它的大小的，在比赛中空间计算是累计方式计算的，虽然最后释放了空间，但是还是会计算到。因此需要使用一种开销比较小，同时又知道图用到的最大空间的方式来建图。\n求解过程 申请空间\n$head$ 数组：大小为节点个数。$head_i$ 表示 $i$ 号节点的对应的边，也就是建图过程中最后一条从 i 出发的边。 $next$ 数组：$next_e$ 表示 $e$ 号边的下一条边，也即从 $i$ 号点出发的边中另外一条边。一直遍历 e = next[e] 可以遍历从 $i$ 号点出发的每一条边。 $to$ 数组：$to_e$ 表示 $e$ 号边的目的节点。 $cnt$ ： 一个整数，从 1 开始，表示边的编号。 以上都是必备的空间，如果需要记录边的权重，点的入度出度等，可以再开辟空间。 因为 $head$ 数组是的索引是节点，所以 $head$ 的大小为节点个数，而 $next$ 和 $to$ 数组，索引表示的是边的编号，所以需要边大小的空间。\n建图\n假设当前建立 u -\u0026gt; v 这条边：\nnext[cnt] = head[u]: 当前边的编号指向出发节点的上一条边的编号。 to[cnt] = pre[0]: 记录当前边指向哪一个点。 head[u] = cnt++: 出发节点指向最新的一条边，边的编号 +1。 以上都是必备数组的建立过程，如果需要添加边权和入度等，可以在合适的位置插入建立步骤。 拓扑排序\n遍历每一个点，如果发现入度为 0 的点，添加到队列。 遍历队列中的每一个点，直到队列为空。 从队列中取出一个点，遍历每一条从该点出发的边，将从它出发的每一个目的节点的入度 -1，如果目的节点的入度减少后为 0，添加到队列。重复此步骤。 因为使用数组实现队列，且指向队列头部的指针 h 不会后退，添加到队列的节点顺序即为一个满足条件的顺序，所以可以直接把入队顺序作为结果。\n复杂度 时间复杂度：$O(m)$ n 为节点个数，m 为边个数。建图的时间复杂度是 m，拓扑排序的时间复杂度是 m。虽然拓扑排序是两层循环，但是每一条边只被遍历一次，最终所有的边都会遍历一次。\n空间复杂度：$O(n + m)$ head indegree queue 数组的大小取决于节点的个数；next to 数组的大小取决于边的个数。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public int[] findOrder(int numCourses, int[][] prerequisites) { int n = numCourses, m = prerequisites.length; int[] head = new int[n]; int[] next = new int[m + 1]; int[] to = new int[m + 1]; int[] indegree = new int[n]; int[] queue = new int[n]; int h = 0, r = 0; int cnt = 1; for (int[] pre : prerequisites) { // pre[0] \u0026lt;- pre[1]; next[cnt] = head[pre[1]]; to[cnt] = pre[0]; indegree[pre[0]]++; head[pre[1]] = cnt++; } for (int i = 0; i \u0026lt; n; i++) { if (indegree[i] == 0) { queue[r++] = i; } } while (h \u0026lt; r) { int node = queue[h++]; for (int e = head[node]; e != 0; e = next[e]) { if (--indegree[to[e]] == 0) { queue[r++] = to[e]; } } } if (r == n) { return queue; } else { return new int[] {}; } } } ","date":"2023-12-20T22:06:49+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-210.-%E8%AF%BE%E7%A8%8B%E8%A1%A8-ii/","title":"LeetCode 210. 课程表 II"},{"content":" LeetCode 2828. 判别首字母缩略词\n思路 依次判断字符串数组中每个字符串的首字母，是否与目标字符串的字符相等。如果存在不相等的字符，返回 $false$；否则返回 $true$。\n求解过程 在开始遍历之前，先判断字符串数组的长度与目标字符串的长度是否相同，如果不同，肯定无法对应，返回 $false$，否则开始遍历。\n复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public boolean isAcronym(List\u0026lt;String\u0026gt; words, String s) { char[] str = s.toCharArray(); int index = 0, n = str.length; if (words.size() != n) { return false; } for (String word : words) { if (word.charAt(0) != str[index]) { return false; } index++; } return true; } } ","date":"2023-12-20T22:04:39+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2828.-%E5%88%A4%E5%88%AB%E9%A6%96%E5%AD%97%E6%AF%8D%E7%BC%A9%E7%95%A5%E8%AF%8D/","title":"LeetCode 2828. 判别首字母缩略词"},{"content":" LeetCode 1901. 寻找峰值 II\n参考题解：灵茶山艾府 - 【图解】利用行最大值判断峰顶位置，附二分题单\n思路 根据 “上山” 的思路，我们只需要沿着“往上走的方向”即可找到一个峰值，即我们每次往上下左右比自己大的位置跳，直到周围的值都比自己小。这种情况最坏情况下时间复杂度是 $O(nm)，使用二分，将上山的路径进行划分，峰值肯定在中点的一侧，或者中点上。\n求解过程 假设存在一条上山路径，我们以行进行二分，我们求出中间行的最大值，则这个最大值肯定在去往峰值的路径上。\n在 $[i, j]$ 行范围上二分，中间行的最大值 $nums_{mid}$ 将路径划分为两部分，${\u0026lt; nums_{mid}, \u0026gt; nums_{mid}}$，我们可以根据最大值上下两个格子的大小继续判断大于部分在那个区间，然后逐渐缩小区间，求出峰值所在的行，而这行的最大值就是峰值。\n复杂度 时间复杂度：$O(n \\times log_2n)$ 空间复杂度：$O(1)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int[] findPeakGrid(int[][] mat) { int n = mat.length, m = mat[0].length; int left = 0, right = n - 2; while (left \u0026lt;= right) { int i = left + (right - left) / 2; int j = indexOfMaxValue(mat[i]); if (mat[i][j] \u0026gt; mat[i + 1][j]) { right = i - 1; } else { left = i + 1; } } return new int[] {left, indexOfMaxValue(mat[left])}; } public int indexOfMaxValue(int[] nums) { int ans = 0; for (int i = 0; i \u0026lt; nums.length; i++) { if (nums[ans] \u0026lt; nums[i]) { ans = i; } } return ans; } } ","date":"2023-12-19T22:00:58+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-1901.-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC-ii/","title":"LeetCode 1901. 寻找峰值 II"},{"content":" LeetCode 162. 寻找峰值\n思路 先判断左右两端的上升或者下降趋势，然后根据区间中点左右两侧的趋势判断哪部分存在极值，然后继续二分。如果中点比左右两侧都大，说明中点就是极值。\n求解过程 特判：因为题目说数组范围外的数字视为负无穷，如果数组开头是下降趋势，则数组开头就是极值；同理，如果数字末尾是上升趋势，则数组末尾是极值。如果数字长度为 1，那么 0 就是极值位置。\n二分：如果数字开头和结尾都不是极值，则说明整个数字是 / .... \\ 这样的，那么在其中肯定存在一个极值。\na. 如果中点比左边的小：/ ...\\m ...\\，则左边肯定存在极值。\nb. 如果中点比右边的小：/ ... /m/ ... \\，则右边肯定存在极值。\nc. 如果中点比左右两侧都大：/ ... /m\\ ... \\，则中点为极值点。\n复杂度 时间复杂度：$O(log_2n)$ 空间复杂度：$O(1)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public int findPeakElement(int[] nums) { // 二分 int n = nums.length; if (n == 1) { return 0; } if (nums[0] \u0026gt; nums[1]) { return 0; } if (nums[n - 2] \u0026lt; nums[n - 1]) { return n - 1; } int left = 1, right = n - 2, ans = 0, mid; while (left \u0026lt;= right) { mid = left + (right - left) / 2; if (nums[mid - 1] \u0026gt; nums[mid]) { right = mid - 1; } else if (nums[mid] \u0026lt; nums[mid + 1]) { left = mid + 1; } else { ans = mid; break; } } return ans; } } ","date":"2023-12-18T20:06:54+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-162.-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/","title":"LeetCode 162. 寻找峰值"},{"content":" LeetCode 746. 使用最小花费爬楼梯\n思路 从楼梯的第一阶或者第二阶出发，计算出走完整个台阶的最小花费。当我们来到某一个阶梯时，我们肯定需要跳出这个台阶，也就是说这个台阶的花费是一定会用掉的。因此，我们可以这样想，我们来到某个台阶，先支付费用，我们下次跳出台阶就可以免费。\n我们来到某个台阶时，它肯定从这个台阶的前一或者前二台阶跳过来。我们选择花费较小的方案。\n求解过程 选择起点，我们可以选择第 0 / 1 台阶开始，当我们到达第 0 个台阶时，花费为 cost[0]；当我们来到第 1 个台阶时，花费为 cost[1]。 求出来到第 i 个台阶时的最小花费。 当全部的台阶都计算完成后，我们可以从倒数第一个台阶跳出，也可以从倒数第二个台阶跳出，取最小花费的方案。 状态转移方程\n$$ \\begin{equation} \\begin{aligned} f(i) = cost_i + \\min(f(i - 1), f(i - 2)) \\end{aligned} \\end{equation} $$\n复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int minCostClimbingStairs(int[] cost) { int n = cost.length; int prev = cost[0]; int cur = cost[1]; int next; for (int i = 2; i \u0026lt; n; i++) { next = cost[i] + Math.min(prev, cur); prev = cur; cur = next; } return Math.min(prev, cur); } } ","date":"2023-12-17T20:06:16+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-746.-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/","title":"LeetCode 746. 使用最小花费爬楼梯"},{"content":" LeetCode 2961. 双模幂运算\n思路 根据题意，需要对公式进行快速求解，求出类似 $a ^ b % m$ 的值，因此需要用到快速幂。代码部分附上快速幂的模板（取模和不取模）。\n求解过程 题本身没什么可说的，说一下快速幂的原理。快速幂可以用于求一个数的大于等于 1 的整数次幂。\n快速幂\n将求幂的式子分解：\n$$ \\begin{equation} \\begin{aligned} a^b \u0026amp;= a^{b_0 + b_1 + b_2 + \u0026hellip; + b_i} \\\\ \u0026amp;= a^{b_0} \\times a^{b_1} \\times \u0026hellip; \\times a^{b_i} \\end{aligned} \\end{equation} $$\nb 为一个正整数，它可以分解为二进制数，所以我们可以根据 b 的每一位是否是 1 来决定是否乘与当前的 $a^{k} (k = 0, 1, 2 \u0026hellip;)$。\n取模\n有时候幂的结果很大，无法使用 int 或 long 来表示，就需要对结果进行取模。根据乘法同余原理，在每一位上计算出结果时，就对结果进行取模，最终的结果与计算完再取模是相等的。\n复杂度 时间复杂度：$O(n \\times log_2n)$ 空间复杂度：$O(1)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public List\u0026lt;Integer\u0026gt; getGoodIndices(int[][] variables, int target) { List\u0026lt;Integer\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); int temp = 0, index = 0; for (int[] var : variables) { temp = f(f(var[0], var[1], 10), var[2], var[3]); if (temp == target) { ans.add(index); } index++; } return ans; } public int f(int base, int power, final int mod) { long r = base; long ans = 1; while (power != 0) { if ((power \u0026amp; 1) == 1) { ans = (ans * r) % mod; } r = (r * r) % mod; power \u0026gt;\u0026gt;= 1; } return (int) ans; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 不带模的快速幂 public static long quickExp(int base, int power) { long r = base; long ans = 1; while (power != 0) { if ((power \u0026amp; 1) == 1) { ans *= r; } r *= r; power \u0026gt;\u0026gt;= 1; } return ans; } // 带模的快速幂 public static int quickExpWithMod(int base, int power, final int mod) { long r = base; long ans = 1; while (power != 0) { if ((power \u0026amp; 1) == 1) { ans = (ans * r) % mod; } r = (r * r) % mod; power \u0026gt;\u0026gt;= 1; } return (int) ans; } ","date":"2023-12-16T21:26:27+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2961.-%E5%8F%8C%E6%A8%A1%E5%B9%82%E8%BF%90%E7%AE%97/","title":"LeetCode 2961. 双模幂运算"},{"content":" LeetCode 2962. 统计最大元素出现至少 K 次的子数组\n参考思路：灵茶山艾府 - 滑动窗口（附题单！）Python/Java/C++/Go\n思路 使用滑动窗口，如果窗口内的最大值数量为 k 个，则前面的以窗口左边界为结尾的子数组加上窗口就是满足题意要求的子数组。\n求解过程 先求出数组的最大值。 窗口右边界从 0 出发，记录窗口内的最大值数量，如果遇到最大值，数量就加一。每次循环，右边界右扩一次。 然后判断窗口内的最大值数量是否为 k，如果相等，左边界可以右移，一直移动到窗口内的最大值数量不等于 k。此时 区间 [left - 1, right] 的最大值数量是等于 k 的，那么前面每个以 left 结尾的子数组加上窗口，他们的最大值数量都是大于等于 k 的，他们的个数为 left。 复杂度 时间复杂度：$O(n)$ 时间复杂度：$O(1)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public long countSubarrays(int[] nums, int k) { int n = nums.length; // 求最大值 int target = Integer.MIN_VALUE; for (int num : nums) { if (num \u0026gt; target) { target = num; } } // 滑窗 // 统计窗口内的最大值数量，如果满足条件，则区间前面的每一个数字与窗口组成的子数组都可以是满足要求的。 int cnt = 0; long ans = 0; for (int l = 0, r = 0; r \u0026lt; n; r++) { if (nums[r] == target) { cnt++; } while (cnt == k) { cnt -= nums[l++] == target ? 1 : 0; } ans += l; } return ans; } } ","date":"2023-12-16T21:24:58+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2962.-%E7%BB%9F%E8%AE%A1%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E8%87%B3%E5%B0%91-k-%E6%AC%A1%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/","title":"LeetCode 2962. 统计最大元素出现至少 K 次的子数组"},{"content":" LeetCode 2276. 统计区间中的整数数目\n思路 按题目要求，需要频繁将某个区间的值修改为指定值，频繁查询区间的值。很明显这道题可以使用线段树来求解。题解的最后是动态开点线段树的模板。\n求解过程 根据题目的范围开辟线段树，设置懒标记的初始值。 实现区间更新和区间查询功能。 线段树原理\n使用二叉树维护区间的和，二叉树的节点属性包括区间的左边界、右边界、中点、区间的值，还有懒标记，降低时间复杂度。\n在进行区间更新和区间查询的时候 [left, right]，从二叉树的头节点开始往下遍历。以查询为例，根据当前节点 [L, R] 的区间与查询的区间进行对比，分为以下三种情况：\n如果两个区间没有交集 R \u0026lt; left || L \u0026gt; right，不是目标区间，返回 0，结束递归。\n如果查询区间包含节点区间 leff \u0026lt;= L \u0026amp;\u0026amp; R \u0026lt;= right，查询时直接返回结果，更新时修改节点的值。\n如果两个区间有交集但不是包含的关系，就是除去上面两种情况。需要根据情况选择左节点还是右节点。\na. 如果区间与节点左半部分有交集 left \u0026lt;= mid，调用左侧的节点进行递归。\nb. 如果区间与节点右半部分有交集 mid \u0026lt; right，调用右侧的节点进行递归。\nc. 最终将两种可能性的结果进行相加，返回。\n懒标记\n使用懒标记，在查询区间完全包含节点区间时，可以根据懒标记快速返回区间值。在更新时，可以暂时不进行底层节点的更新，等下次查询时再更新。使用懒标记可以优化时间复杂度。\n懒标记向下传递的过程：\n检查懒标记是否为标记了本节点，如果没有，直接返回； 如果有，更新当前节点的值，然后传递给左右子节点。 最终消除本节点的懒标记。 复杂度 时间复杂度：$O(log_2n)$ 空间复杂度：$(m \\times log_2n)$ n 为区间的长度，m 为总查询次数。动态开点线段是是在添加和查询的过程中进行建树的，空间复杂度会比较低，如果是正常的则为 $O(n)$。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 class CountIntervals { SegmentTree tree = new SegmentTree(); public CountIntervals() { } public void add(int left, int right) { tree.update(left, right, 1); } public int count() { return tree.query(); } } class Node { int left; int right; int mid; int lazy = 0; int val; Node leftNode, rightNode; Node() { this.lazy = 0; } Node(int l, int r) { this.left = l; this.right = r; this.mid = l + ((r - l) \u0026gt;\u0026gt; 1); this.lazy = 0; } } public class SegmentTree { public static int N = (int) 1e9; private Node root = new Node(1, N); SegmentTree() { } public void update(int left, int right, int val) { _update(root, left, right, val); } public int query() { return _query(root, 1, N); } public int query(int left, int right) { return _query(root, left, right); } private void _update(Node root, int left, int right, int val) { if (left \u0026lt;= root.left \u0026amp;\u0026amp; root.right \u0026lt;= right) { root.lazy = val; root.val = (root.right - root.left + 1) * val; return; } if (root.left \u0026gt; right || root.right \u0026lt; left) { return; } _pushdown(root); // 在这里建树 if (left \u0026lt;= root.mid) { _update(root.leftNode, left, right, val); } if (right \u0026gt; root.mid) { _update(root.rightNode, left, right, val); } _pushup(root); } private int _query(Node root, int left, int right) { if (left \u0026lt;= root.left \u0026amp;\u0026amp; right \u0026gt;= root.right) { return root.val; } if (root.left \u0026gt; right || root.right \u0026lt; left) { return 0; } _pushdown(root); int res = 0; if (left \u0026lt;= root.mid) { res += _query(root.leftNode, left, right); } if (right \u0026gt; root.mid) { res += _query(root.rightNode, left, right); } return res; } private void _pushup(Node root) { if (root.leftNode != null \u0026amp;\u0026amp; root.rightNode != null) { root.val = root.leftNode.val + root.rightNode.val; } } private void _pushdown(Node root) { if (root.leftNode == null) { root.leftNode = new Node(root.left, root.mid); } if (root.rightNode == null) { root.rightNode = new Node(root.mid + 1, root.right); } if (root.lazy != 0) { int temp = root.lazy; root.leftNode.lazy = temp; root.leftNode.val = (root.leftNode.right - root.leftNode.left + 1) * temp; root.rightNode.lazy = temp; root.rightNode.val = (root.rightNode.right - root.rightNode.left + 1) * temp; root.lazy = 0; } } } ","date":"2023-12-16T21:20:01+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2276.-%E7%BB%9F%E8%AE%A1%E5%8C%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E6%95%B0%E7%9B%AE/","title":"LeetCode 2276. 统计区间中的整数数目"},{"content":" LeetCode 730. 统计不同回文子序列\n算法讲解077【必备】区间dp-下\n思路 定义子问题：在区间 [i, j] 的回文子序列的数目。\n求解过程 Base Case\ni \u0026gt; j：无法构成子序列，返回 0。 i == j：只有一个字符，满足回文子序列，返回 1。 递归过程\n如果左右两侧字符不相等：分别求出区间 [i, j - 1] 和区间 [i + 1, j] 的回文子序列数量，因为在区间 [i + 1, j - 1] 有重复计算的回文子序列，所以要减掉。\n如果左右两侧字符相等，需要分类讨论：\na. 如果区间中不存在与端点相同的字符：2 * dp[i + 1, j - 1] + 2，乘 2 分别是加上端点的和不加端点的，2 是只有端点形成的长度为 1 和 2 的回文子序列。\nb. 如果区间中存在一个与端点相同的字符：2 * dp[i + 1, j - 1] + 1，跟上面类似，+1 是区间内部已经有长度为 1 的端点字符的回文子序列，不需要再加了。\nc. 如果区间中存在两个及以上与端点相同的字符：只关心与端点最近的两个字符 L R，上述长度为 1 和 2 的与端点相同字符的回文子序列就没有了，因为内部区间已经包含了，但是会有重复的。因为 [L + 1, R - 1] 区间的回文因为 L R 会计算一次，在 [i, j] 又会计算一次，所以要减去 dp[L + 1][R - 1]。\n为了快速求出区间端点内部与之相同的最近的字符位置，我们使用两个数组记录下与他们最近的左右两侧相同字符的位置，这样在递归中可以快速查找。\n复杂度 时间复杂度：$O(n^2)$ 空间复杂度：$O(n^2)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class Solution { int mod = 1000000007; public int countPalindromicSubsequences(String s) { char[] str = s.toCharArray(); int n = str.length; int[] left = new int[n]; int[] right = new int[n]; int[] last = new int[4]; long[][] dp = new long[n][n]; Arrays.fill(last, -1); for (int i = 0; i \u0026lt; n; i++) { dp[i][i] = 1; left[i] = last[str[i] - \u0026#39;a\u0026#39;]; last[str[i] - \u0026#39;a\u0026#39;] = i; } Arrays.fill(last, n); for (int i = n - 1; i \u0026gt;= 0; i--) { right[i] = last[str[i] - \u0026#39;a\u0026#39;]; last[str[i] - \u0026#39;a\u0026#39;] = i; } for (int i = n - 2; i \u0026gt;= 0; i--) { for (int j = i + 1; j \u0026lt; n; j++) { long res = 0; if (str[i] != str[j]) { res = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1] + mod; } else { int L = right[i]; int R = left[j]; if (L \u0026gt; R) { res = dp[i + 1][j - 1] * 2 + 2; } else if (L == R) { res = dp[i + 1][j - 1] * 2 + 1; } else { res = dp[i + 1][j - 1] * 2 - dp[L + 1][R - 1] + mod; } } dp[i][j] = res % mod; } } return (int)dp[0][n - 1]; } public long process(char[] str, int[] left, int[] right, int i, int j, long[][] dp) { if (i \u0026gt; j) { return 0; } if (i == j) { return 1; } if (dp[i][j] != 0) { return dp[i][j]; } long res = 0; if (str[i] != str[j]) { res = process(str, left, right, i, j - 1, dp) + process(str, left, right, i + 1, j, dp) - process(str, left, right, i + 1, j - 1, dp) + mod; } else { int L = right[i]; int R = left[j]; if (L \u0026gt; R) { res = process(str, left, right, i + 1, j - 1, dp) * 2 + 2; } else if (L == R) { res = process(str, left, right, i + 1, j - 1, dp) * 2 + 1; } else { res = process(str, left, right, i + 1, j - 1, dp) * 2 - process(str, left, right, L + 1, R - 1, dp) + mod; } } res %= mod; dp[i][j] = res; return res; } } ","date":"2023-12-15T22:04:42+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-730.-%E7%BB%9F%E8%AE%A1%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/","title":"LeetCode 730. 统计不同回文子序列"},{"content":" LeetCode 1000. 合并石头的最低成本\n算法讲解077【必备】区间dp-下\n思路 定义子问题：在区间 [i, j] 时石头消除的最小花费。\n求解过程 因为石头必须将 k 个合并成一个，且最后一次消除必须只剩下一个石头，所以在 DP 过程中是有划分依据的。在一般递归中，如果不合并，则石头可以为 1 ... k 个，最后一次必须合并，最终的石头必须为 k 个。根据观察，满足最后只剩下一个石头的数组，必须满足 (n - 1) / (k - 1) == 0。\n递归过程中，需要合并某个区间的石头，无论子过程如何合并，最终合并为 1 个石头的时候，它的花费是固定的，为区间石头的和。所以我们求出前缀和数组，在递归时会用到。\nBase Case\ni \u0026gt;= j：无法合并，花费为 0。 递归过程\n因为题目要求必须 k 个合成一个，要满足 (n - 1) / (k - 1) == 0，因此 i 的递增单位长度应为 k - 1，则 i 到分割点的长度一定可以合并。\n分别以 [i, j] 区间中满足要求的点作为分割，分别计算出左右两侧合并的最小花费。在所有分割点中取最小值。最后如果此时区间长度可以进行合并，需要加上合并的花费。\n复杂度 时间复杂度：$O(n^2)$ 空间复杂度：$O(n^2)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public int mergeStones(int[] stones, int k) { // 反推：如果最终合并成一个，那么倒数第二次就一定是k 个 // 倒数第三次有 n 个 k 合成，形成了 n：k - n + nk = x =\u0026gt; k + n(k - 1) = x // n(k - 1) = x - k =\u0026gt; (n + 1)(k - 1) = x - 1 =\u0026gt; (x - 1) % (k - 1) == 0; int n = stones.length; if ((n - 1) % (k - 1) != 0) { return -1; } int[] pre = new int[n + 1]; for (int i = 0; i \u0026lt; n; i++) { pre[i + 1] = pre[i] + stones[i]; } int[][] dp = new int[n][n]; for (int i = n - 2; i \u0026gt;= 0; i--) { for (int j = i + 1; j \u0026lt; n; j++) { int ans = Integer.MAX_VALUE; for (int m = i; m \u0026lt; j; m += k - 1) { ans = Math.min(ans, dp[i][m] + dp[m + 1][j]); } if ((j - i) % (k - 1) == 0) { ans += pre[j + 1] - pre[i]; } dp[i][j] = ans; } } return dp[0][n - 1]; } public int process(int[] pre, int i, int j, int k) { if (i \u0026gt;= j) { return 0; } int ans = Integer.MAX_VALUE; for (int start = i; start \u0026lt; j; start += k - 1) { ans = Math.min(ans, process(pre, i, start, k) + process(pre, start + 1, j, k)); } if ((j - i) % (k - 1) == 0) { ans += pre[j + 1] - pre[i]; } return ans; } } ","date":"2023-12-15T22:03:36+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-1000.-%E5%90%88%E5%B9%B6%E7%9F%B3%E5%A4%B4%E7%9A%84%E6%9C%80%E4%BD%8E%E6%88%90%E6%9C%AC/","title":"LeetCode 1000. 合并石头的最低成本"},{"content":" LeetCode 546. 移除盒子\n算法讲解077【必备】区间dp-下\n思路 根据题意，连续的相同盒子越多，分数就越高。所以在求区间最高分数的时候，要让相同的盒子尽量“连起来”。单纯的区间 DP 无法满足这种要求，需要定义一个额外的变量维护相同盒子的数量。\n定义子问题，在区间 [i, j] 上获得的最高分数，在区间 DP 时，附带一个参数 cnt，它表示在 i 之前有多少个与 i 相同的盒子与区间相连。\n求解过程 Base Case\ni \u0026gt; j：区间不合法，返回 0。 递归过程\n根据贪心，我们要求最大分数，就要让相同的连续的盒子尽量多，所以继续从 i 往右搜索，看看与 i 相同的盒子数量最多可以扩充到多少。假设扩充到了 start 位置，start 位置的盒子与 i 位置不同，此时连续的与 i 相同的盒子数量为 cnt。 前缀先消一：如果此时将所有的与 i 相同的盒子消掉，那么分数为 cnt * cnt 加上之后没有被消除的。 前缀先消二：我让前面没有消掉的继续往右匹配，假设来到了 m 位置。[start, m - 1] 位置执行递归，[m, j] 区间执行递归，得到的一种消除方案的分数。 同理，继续往右找，继续执行前缀先消二的步骤，得到一种消除方案的分数。在所有方案中取最大值。 复杂度 时间复杂度：$O(n^4)$ 空间复杂度：$O(n^3)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public int removeBoxes(int[] boxes) { int n = boxes.length; int[][][] dp = new int[n][n][n]; // n^3 return process(boxes, 0, boxes.length - 1, 0, dp); } public int process(int[] nums, int i, int j, int x, int[][][] dp) { if (i \u0026gt; j) { return 0; } if (dp[i][j][x] \u0026gt; 0) { return dp[i][j][x]; } int start = i + 1; while (start \u0026lt;= j \u0026amp;\u0026amp; nums[start] == nums[i]) { start++; } int cnt = start - i + x; // 情况一：前缀先消 int res = cnt * cnt + process(nums, start, j, 0, dp); // 情况二：前缀分别跟随后续的数字一起消 for (int k = start; k \u0026lt;= j; k++) { // 与 i 位置相同的盒子，且是连续一段的第一个位置 if (nums[k] == nums[i] \u0026amp;\u0026amp; nums[k] != nums[k - 1]) { res = Math.max(res, process(nums, start, k - 1, 0, dp) + process(nums, k, j, cnt, dp)); } } dp[i][j][x] = res; return res; } } ","date":"2023-12-15T22:02:43+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-546.-%E7%A7%BB%E9%99%A4%E7%9B%92%E5%AD%90/","title":"LeetCode 546. 移除盒子"},{"content":" 洛谷 P3205 [HNOI2010] 合唱队\n算法讲解077【必备】区间dp-下\n思路 按照入队的逆序进行想，则子问题应该是：在区间 [left, right] 中，如果左侧是最后入队的，则在剩下的区间 left + 1, right] 中，又有两种情况。如果 $nums_{left + 1}$ 最后入队，则 $nums_{left}$ 应该大于它;如果 $nums_{right}$ 最后入队，则 $nums_{left}$ 应该大于它，则 [left, right] 区间中左侧入队的方案数为符合条件的可能性之和。\n同理，右侧作为最后入队的时候，也分为两种情况。\n求解过程 求解子问题：在区间 [i, j] 中，求出组成目标队列顺序的方案数。\n因为同一个区间分为左右两侧分别是最后入队的情况，所以再使用一个纬度记录是否是左侧最后入队。在本文代码中，0 表示是左侧最后入队，1 表示右侧最后入队。\nBase Case\ni == j：只有一个人，作为最初始的情况，本来就在在队伍中，返回 0。 i + 1 == j：根据大小判断每种入队的方案数。如果 $height_i \u0026lt; height_j$，i 和 j 最后入队的方案之后一种。如果 $height_i \u0026gt; height_j$，无论谁先入队都无法满足要求，都是 0 。 递归过程\n$height_i$ 最后入队，讨论在区间 [i + 1, j]的入队情况：\na. $height_{i + 1}$ 最后入队，且 $height_i \u0026lt; height_{i + 1}$，满足入队顺序，方案数加上 [i + 1, j] 区间 $height_{i + 1}$ 后入队的方案数；否则不加。\nb. $height_{j}$ 最后入队，且 $height_i \u0026lt; height_{j}$，满足入队顺序，方案数加上 [i + 1, j] 区间 $height_{j}$ 后入队的方案数；否则不加。\n同理，讨论 $height_j$ 最后入队，讨论在区间 [i, j - 1]的入队情况。\n复杂度 时间复杂度：$O(n^2)$ 空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 import java.io.*; public class Main { public static int MOD = 19650827; public static int MAXN = 1001; public static int[] height = new int[MAXN]; public static int[][] dp = new int[MAXN][2]; public static int n; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer in = new StreamTokenizer(br); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while (in.nextToken() != StreamTokenizer.TT_EOF) { n = (int) in.nval; for (int i = 1; i \u0026lt;= n; i++) { in.nextToken(); height[i] = (int) in.nval; } if (n == 1) { out.println(1); } else { out.println(compute2()); } } out.flush(); out.close(); br.close(); } public static int compute1() { int[][][] dp = new int[n + 1][n + 1][2]; for (int i = 1; i \u0026lt; n; i++) { if (height[i] \u0026lt; height[i + 1]) { dp[i][i + 1][0] = 1; dp[i][i + 1][1] = 1; } } for (int i = n - 2; i \u0026gt;= 1; i--) { for (int j = i + 2; j \u0026lt;= n; j++) { // 如果 i 是最后放进去的 if (height[i] \u0026lt; height[i + 1]) { dp[i][j][0] = (dp[i][j][0] + dp[i + 1][j][0]) % MOD; } if (height[i] \u0026lt; height[j]) { dp[i][j][0] = (dp[i][j][0] + dp[i + 1][j][1]) % MOD; } if (height[j] \u0026gt; height[i]) { dp[i][j][1] = (dp[i][j][1] + dp[i][j - 1][0]) % MOD; } if (height[j] \u0026gt; height[j - 1]) { dp[i][j][1] = (dp[i][j][1] + dp[i][j - 1][1]) % MOD; } } } return (dp[1][n][0] + dp[1][n][1]) % MOD; } public static int compute2() { if (height[n - 1] \u0026lt; height[n]) { dp[n][0] = 1; dp[n][1] = 1; } else { dp[n][0] = 0; dp[n][1] = 0; } for (int i = n - 2; i \u0026gt;= 1; i--) { if (height[i] \u0026lt; height[i + 1]) { dp[i + 1][0] = 1; dp[i + 1][1] = 1; } else { dp[i + 1][0] = 0; dp[i + 1][1] = 0; } for (int j = i + 2, a, b; j \u0026lt;= n; j++) { a = 0; b = 0; // 如果 i 是最后放进去的 if (height[i] \u0026lt; height[i + 1]) { a = (a + dp[j][0]) % MOD; } if (height[i] \u0026lt; height[j]) { a = (a + dp[j][1]) % MOD; } if (height[j] \u0026gt; height[i]) { b = (b + dp[j - 1][0]) % MOD; } if (height[j] \u0026gt; height[j - 1]) { b = (b + dp[j - 1][1]) % MOD; } dp[j][0] = a; dp[j][1] = b; } } return (dp[n][0] + dp[n][1]) % MOD; } } ","date":"2023-12-15T22:00:55+08:00","permalink":"https://zhuaowei.github.io/article/%E6%B4%9B%E8%B0%B7-p3205-hnoi2010-%E5%90%88%E5%94%B1%E9%98%9F/","title":"洛谷 P3205 [HNOI2010] 合唱队"},{"content":" LeetCode 664. 奇怪的打印机\n洛谷 P4170 [CQOI2007] 涂色\n算法讲解077【必备】区间dp-下\n思路 定义子问题：在区间 [left, right] 涂色的最小次数。因为后涂的颜色可以覆盖前一种颜色，如果我们要让涂色次数最少，可以使用贪心，让左侧的颜色尽量涂多一些。\n求解过程 讨论在子问题在区间 [left, right] 涂色的最小次数。\nBase Case\n如果区间值剩下一个位置，可以涂 1 次。 如果区间剩下两个位置，如果颜色一样，涂 1次，否则涂 2 次。 递归过程\n如果左右两端颜色一样，我们可以认为这两种是一次性涂好的，然后继续判断在 [left, right - 1] 范围是否需要再涂。 如果左右两端颜色不一样，说明左侧的颜色涂到的位置未知，右侧颜色开始的位置也未知，但是他们应该是相邻的。分别以区间中的每一个点作为分割点，计算出左右区间的最小涂色次数之和。在所有可能性中取最小值。 状态转移方程\n$$ \\begin{equation} \\begin{aligned} f(i, j) = \\begin{cases} 1 \u0026amp;\u0026amp; i == j\\\\ \\begin{cases} 1 \u0026amp;\u0026amp; 两端颜色一致\\\\ 2 \u0026amp;\u0026amp; 两端颜色不一致 \\end{cases} \u0026amp;\u0026amp; i + 1 == j\\\\ \\begin{cases} f(i, j - 1) \u0026amp;\u0026amp; 两端颜色一致\\\\ \\min(f(i, k) + f(k + 1, j)) \u0026amp;\u0026amp; k = i, i + 1, \u0026hellip;, j - 1 \\end{cases} \u0026amp;\u0026amp; i + 1 \u0026lt; j \\end{cases} \\end{aligned} \\end{equation} $$\n复杂度 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); String s = br.readLine(); out.println(strangePrinter(s)); out.flush(); out.close(); br.close(); } public static int strangePrinter(String s) { char[] str = s.toCharArray(); int n = str.length; int[][] dp = new int[n][n]; for (int i = 0; i \u0026lt; n; i++) { dp[i][i] = 1; } for (int i = n - 2; i \u0026gt;= 0; i--) { for (int j = i + 1; j \u0026lt; n; j++) { if (str[i] == str[j]) { dp[i][j] = dp[i][j - 1]; } else { int ans = Integer.MAX_VALUE; for (int k = i; k \u0026lt; j; k++) { ans = Math.min(ans, dp[i][k] + dp[k + 1][j]); } dp[i][j] = ans; } } } return dp[0][n - 1]; } } ","date":"2023-12-15T17:13:36+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-664.-%E5%A5%87%E6%80%AA%E7%9A%84%E6%89%93%E5%8D%B0%E6%9C%BA-%E6%B4%9B%E8%B0%B7-p4170-cqoi2007-%E6%B6%82%E8%89%B2/","title":"LeetCode 664. 奇怪的打印机 | 洛谷 P4170 [CQOI2007] 涂色"},{"content":" 牛客网 括号区间匹配\n算法讲解077【必备】区间dp-下\n思路 定义子问题：在区间 [left, right] 之间能够将括号变成有效的最小插入次数。\n求解过程 括号的组合有两种，一是嵌套 [()]，二是并列 []()。在子问题中，讨论区间 [left, right] 两端的括号形成可能性。\n如果两侧端点可以匹配上，那么说明两端的括号可能属于同一组，讨论剩余的插入次数；也可能不是同一组，按下面一种方式讨论。 如果两侧端点无法匹配，那么肯定不是一组，只讨论不是一组的情况。分别以区间内的每一个字符作为分割点，讨论左右两侧的最小插入数。 以上所有情况中取最小值，作为 [left, right] 区间的字符串的最小插入数。\nBase Case\n当区间只剩一个字符时，肯定无法匹配，插入一个字符使其匹配。 如果区间只剩两个字符，判断是否匹配，若匹配，返回 0，不匹配，返回 2。 状态转移方程\n$$ \\begin{equation} \\begin{aligned} f(i,j) = \\begin{cases} 1 \u0026amp;\u0026amp; i == j, \\\\ 0 \u0026amp;\u0026amp; i + 1 == j 且 str_i 与 str_j 匹配\\\\ 2 \u0026amp;\u0026amp; i + 1 == j 且 str_i 与 str_j 不匹配\\\\ \\min\\begin{cases} f(i + 1, j - 1) \u0026amp;\u0026amp; str_{i + 1} 与 str_j 匹配\\\\ f(i, k) + f(k, j) \u0026amp;\u0026amp; k = i, i + 1, i + 2, \u0026hellip;, j - 1 \\end{cases} \u0026amp;\u0026amp; i + 1 \u0026lt; j \\end{cases} \\end{aligned} \\end{equation} $$\n根据状态转移方程和上面的分析，很容易写出记忆化搜索版本和严格位置依赖的版本。\n复杂度 时间复杂度：$O(n^3)$ 空间复杂度：$O(n^2)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); String s = br.readLine(); out.println(compute(s)); out.flush(); out.close(); br.close(); } public static int compute(String s) { char[] str = s.toCharArray(); int n = str.length; int[][] dp = new int[n][n]; for (int i = 0; i \u0026lt; n; i++) { dp[i][i] = 1; } for (int i = 0; i \u0026lt; n - 1; i++) { // 不匹配的情况，剩下的两个字符不匹配的情况 if (!((str[i] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; str[i + 1] == \u0026#39;)\u0026#39;) || (str[i] == \u0026#39;[\u0026#39; \u0026amp;\u0026amp; str[i + 1] == \u0026#39;]\u0026#39;))) { dp[i][i + 1] = 2; } } for (int i = n - 3; i \u0026gt;= 0; i--) { for (int j = i + 2; j \u0026lt; n; j++) { int ans = Integer.MAX_VALUE; // 可以匹配 if ((str[i] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; str[j] == \u0026#39;)\u0026#39;) || (str[i] == \u0026#39;[\u0026#39; \u0026amp;\u0026amp; str[j] == \u0026#39;]\u0026#39;)) { ans = dp[i + 1][j - 1]; } for (int k = i; k \u0026lt; j; k++) { ans = Math.min(ans, dp[i][k] + dp[k + 1][j]); } dp[i][j] = ans; } } return dp[0][n - 1]; } } ","date":"2023-12-15T16:43:24+08:00","permalink":"https://zhuaowei.github.io/article/%E7%89%9B%E5%AE%A2%E7%BD%91-%E6%8B%AC%E5%8F%B7%E5%8C%BA%E9%97%B4%E5%8C%B9%E9%85%8D/","title":"牛客网 括号区间匹配"},{"content":" LeetCode 2415. 反转二叉树的奇数层\n思路 不用真的将节点对象进行翻转，而是将节点存储的值进行翻转。使用层序遍历，在遍历完奇数层之后，将节点中的值翻转。\n求解过程 使用一个队列存储头节点，然后开始循环，直到队列为空。\n在循环中，如果上一次遍历的是奇数层，则队列中存储的就是奇数层节点的值，执行翻转。这里使用一个 boolean 变量记录是否是奇数层。\n然后遍历队列中的每一个节点，添加他们的左右子节点到队列中。（踩坑，不要用队列大小作为循环停止条件，要先计算出队列节点个数，确定循环次数）\n复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public TreeNode reverseOddLevels(TreeNode root) { if (root == null) { return root; } Queue\u0026lt;TreeNode\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(); deque.add(root); TreeNode node; boolean reverse = false; while (!deque.isEmpty()) { int n = deque.size(), temp; if (reverse) { // 翻转 List\u0026lt;TreeNode\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(deque); TreeNode node1, node2; for (int j = 0; j \u0026lt; n / 2; j++) { node1 = list.get(j); node2 = list.get(n - j - 1); temp = node1.val; node1.val = node2.val; node2.val = temp; } } reverse = !reverse; for (int i = 0; i \u0026lt; n; i++) { node = deque.poll(); if (node.left != null) { deque.add(node.left); } if (node.right != null) { deque.add(node.right); } } } return root; } } ","date":"2023-12-15T16:24:52+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2415.-%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A5%87%E6%95%B0%E5%B1%82/","title":"LeetCode 2415. 反转二叉树的奇数层"},{"content":" LeetCode 面试题 08.14. 布尔运算\n算法讲解076【必备】区间dp-上\n思路 子问题：以范围内每一个运算符作为划分点，求解左右两侧结果为 true 和 false 的表达式数量，然后根据当前运算符计算出结果为 true 和 false 的数量。\n求解过程 递归保证 [i, j] 范围内的表达式是合法的，即偶数位置是数字，奇数位置是运算符，且 i 和 j 都是偶数。\nbase case\ni == j：只剩下一个数字，根据数字是 0/1，计算出 true 和 false 的数量。 递归过程\n分别以区间内的每一个运算符作为划分，求出两侧的 true 和 false 的数量，然后计算出本次运算 true 和 false 的数量。求出每一个字符作为划分的 true 和 false 的数量，求所有字符的到的结果的总和。\n最终根据题意返回需要的 true/false 的数量。\n复杂度 时间复杂度：$O(n^3)$ 空间复杂度：$O(n^2)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class Solution { public int countEval(String s, int result) { char[] str = s.toCharArray(); int n = str.length; int[][][] dp = new int[n][n][]; for (int i = 0; i \u0026lt; n; i += 2) { dp[i][i][0] = str[i] == \u0026#39;0\u0026#39; ? 1 : 0; dp[i][i][1] = str[i] == \u0026#39;1\u0026#39; ? 1 : 0; } int[] temp = new int[2]; for (int i = n - 3; i \u0026gt;= 0; i -= 2) { for (int j = i + 2; j \u0026lt; n; j += 2) { for (int k = i + 1, a, b, c, d; k \u0026lt; j; k += 2) { temp = dp[i][k - 1]; a = temp[0]; b = temp[1]; temp = dp[k + 1][j]; c = temp[0]; d = temp[1]; if (str[k] == \u0026#39;\u0026amp;\u0026#39;) { dp[i][j][1] += b * d; dp[i][j][0] += a * c + a * d + b * c; } else if (str[k] == \u0026#39;|\u0026#39;) { dp[i][j][0] += a * c; dp[i][j][1] += b * c + b * d + a * d; } else { dp[i][j][1] += a * d + b * c; dp[i][j][0] += a * c + b * d; } } } } return dp[0][n - 1][result]; // int[] res = process(s.toCharArray(), 0, s.length() - 1); } public int countEval1(String s, int result) { char[] str = s.toCharArray(); int n = str.length; int[][][] dp = new int[n][n][]; int[] cnt = process(str, 0, n - 1, dp); return cnt[result]; } // [i, j] 范围内，以每个字符作为最后运算符的结果数 public int[] process(char[] str, int i, int j, int[][][] dp) { if (dp[i][j] != null) { return dp[i][j]; } int F = 0, T = 0; if (i == j) { F = str[i] == \u0026#39;0\u0026#39; ? 1 : 0; T = str[i] == \u0026#39;1\u0026#39; ? 1 : 0; dp[i][j] = new int[] {F, T}; return dp[i][j]; } int[] res = new int[2]; for (int k = i + 1, a, b, c, d; k \u0026lt; j; k += 2) { res = process(str, i, k - 1, dp); a = res[0]; b = res[1]; res = process(str, k + 1, j, dp); c = res[0]; d = res[1]; if (str[k] == \u0026#39;\u0026amp;\u0026#39;) { T += b * d; F += a * c + a * d + b * c; } else if (str[k] == \u0026#39;|\u0026#39;) { F += a * c; T += b * c + b * d + a * d; } else { T += a * d + b * c; F += a * c + b * d; } } dp[i][j] = new int[] {F, T}; return dp[i][j]; } } ","date":"2023-12-14T22:20:01+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-08.14.-%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97/","title":"LeetCode 面试题 08.14. 布尔运算"},{"content":" LeetCode 312. 戳气球\n算法讲解076【必备】区间dp-上\n思路 如果在区间 [i, j] 之间选出一个气球作为第一个被戳破的，那么根据它可以将气球分为两部分，但是它左侧和右侧的气球戳破顺序是不确定的，所以无法确定本次戳破气球获得的分数。\n反过来想，在 [i, j] 之间选择一个气球最后一个被戳破，则它的左右两侧没有被戳破的气球是确定的，就是 i - 1 和 j + 1，这个时候就可以计算出最后一个戳破的分数，同时也将气球划分出两部分。\n求解过程 先在气球的两侧添加一个分值为 1 的气球。在 [1, n] 范围内求解戳破气球获取的最大分值。所以子问题是 在 [i, j] 范围内可以获取的最大分数。\nbase case\ni \u0026gt; j：范围不合法，返回 0。 i == j：只有一个气球，在 [i, j] 范围内它是最后戳破的，那么肯定有 i - 1 和 j + 1 位置的气球是没有被戳破，分数为 三个位置的数相乘。 递归过程\n设当前来到了 [i, j] 位置，依次选择一个气球作为最后被戳破的，计算出此次戳破和划分后的分值，求分值的最大值。\n$$ \\begin{equation} f(i,j) = \\begin{cases} 0 \u0026amp; \u0026amp; {i \\gt j}, \\\\ nums_{i - 1} \\times nums_{j + 1} \\times nums_{k} + f(i, k - 1) + f(k + 1, j) \u0026amp; \u0026amp; { i \\le j 且 k = i, i + 1, \u0026hellip;, j} \\end{cases} \\end{equation} $$\n根据上面的递归过程分析和状态转移方程，写出记忆化搜索版本和最终的严格位置依赖版本。\nbase case 中的情况 2 可以放到递归过程中求解，产生的递归调用因为范围不合法，会返回 0，不影响最终的结果。所以在严格位置依赖版本中，base case省略了情况 2，同时，因为数据初始化时默认值为 0，所以也忽略掉了情况 1。\n复杂度 时间复杂度：$O(n^3)$ 空间复杂度：$O(n^2)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public int maxCoins(int[] nums) { int n = nums.length; int m = n + 2; int[] ball = new int[m]; ball[0] = ball[n + 1] = 1; for (int i = 0; i \u0026lt; n; i++) { ball[i + 1] = nums[i]; } int[][] dp = new int[m][m]; // for (int i = 1; i \u0026lt;= n; i++) { // dp[i][i] = ball[i - 1] * ball[i] * ball[i + 1]; // } for (int i = n; i \u0026gt;= 1; i--) { for (int j = i; j \u0026lt;= n; j++) { for (int k = i; k \u0026lt;= j; k++) { dp[i][j] = Math.max(dp[i][j], ball[i - 1] * ball[k] * ball[j + 1] + dp[i][k - 1] + dp[k + 1][j]); } } } return dp[1][n]; } // 在 [i, j] 范围内选择一个气球戳破，得到的最大值是多少。 public int process(int[] ball, int i, int j) { if (i \u0026gt; j) { return 0; } if (i == j) { return ball[i - 1] * ball[i] * ball[i + 1]; } int res = 0; for (int k = i; k \u0026lt;= j; k++) { res = Math.max(res, ball[i - 1] * ball[k] * ball[j + 1] + process(ball, i, k - 1) + process(ball, k + 1, j)); } return res; } } ","date":"2023-12-14T22:18:22+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-312.-%E6%88%B3%E6%B0%94%E7%90%83/","title":"LeetCode 312. 戳气球"},{"content":" LeetCode 1547. 切棍子的最小成本\n算法讲解076【必备】区间dp-上\n思路 将切点按照大小排序，然后再在收尾添加 0 和 n，依次选择除了端点的所有切点作为下一次裁剪的点，计算出每一种切点的花费，取最小值。\n求解过程 首先对切点进行排序，然后在收尾添加 0 和 n。定义子问题，在第 [i, j] 范围内选择一个切点，要求切点的花费最小。\nbase case\n当 i \u0026gt; j：没有切点，无法裁剪，返回 0。 递归过程\n依次选择 i, i + 1, i + 2, ..., j 作为切点，那么无论如何选择，它的本次的花费为 cut[j + 1] - cut[i - 1]。\n$$ \\begin{equation} f(i,j) = \\begin{cases} 0 \u0026amp; \u0026amp; {i \\gt j}, \\\\ cut_{j + 1} - cut_{i - 1} + \\min(f(i, k - 1), f(k + 1, j)) \u0026amp; \u0026amp; { i \\le j 且 k = i, i + 1, i + 2, \u0026hellip;, j} \\end{cases} \\end{equation} $$\n根据上面的递归分析和状态转移方程，可以写出记忆化搜索和严格位置依赖的版本。\n复杂度 时间复杂度：$O(n^3)$ 空间复杂度：$O(n^2)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public int minCost(int n, int[] cuts) { int m = cuts.length; int[] seg = new int[m + 2]; seg[0] = 0; seg[m + 1] = n; for (int i = 1; i \u0026lt;= m; i++) { seg[i] = cuts[i - 1]; } int[][] dp = new int[m + 2][m + 2]; Arrays.sort(seg); for (int i = m; i \u0026gt;= 1; i--) { for (int j = i; j \u0026lt;= m; j++) { dp[i][j] = Integer.MAX_VALUE; for (int k = i; k \u0026lt;= j; k++) { dp[i][j] = Math.min(dp[i][j], dp[i][k - 1] + dp[k + 1][j]); } dp[i][j] += seg[j + 1] - seg[i - 1]; } } return dp[1][m]; } public int process(int[] seg, int i, int j, int[][] dp) { if (i \u0026gt; j) { return 0; } if (dp[i][j] != 0) { return dp[i][j]; } int res = Integer.MAX_VALUE; for (int k = i; k \u0026lt;= j; k++) { res = Math.min(res, process(seg, i, k - 1, dp) + process(seg, k + 1, j, dp)); } dp[i][j] = res + seg[j + 1] - seg[i - 1]; return dp[i][j]; } } ","date":"2023-12-14T22:17:34+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-1547.-%E5%88%87%E6%A3%8D%E5%AD%90%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%AC/","title":"LeetCode 1547. 切棍子的最小成本"},{"content":" LeetCode 1039. 多边形三角剖分的最低得分\n算法讲解076【必备】区间dp-上\n思路 先确定三角形的两个点，然后依次选择剩余的点作为划分点，判断哪种划分方式获得的分值最小。因此确定的子问题是在 (i, j) 中选择一个作为划分点，能获取的最小分值。\n求解过程 首先确定数组中的首尾位置作为三角形的点，然后依次选择二者之间的点作为第三个定点，将点集划分为两个部分，之后继续在这两个部分递归，直到最终无法划分。\nbase case\ni + 1 \u0026gt;= j：少于两个点或者范围非法，无法构成三角形，返回 0。 i + 2 == j：只剩下 3 个点，只能形成一个三角形，无法继续划分，返回计算的分值。 递归过程\n设当前来到 (i, j) 位置，依次以 i + 1, i + 2, ..., j - 1 作为顶点划分点集，计算子集的最小分值，最终求出在所有划分中最小的分值。\n$$ \\begin{equation} f(i,j) = \\begin{cases} 0 \u0026amp; \u0026amp; {i + 1 \\ge j}, \\\\ nums_i \\times nums_{i + 1} \\times nums_{i + 2} \u0026amp; \u0026amp; { i + 2 == j}, \\\\ \\min(nums_i \\times nums_k \\times nums_j + f(i, k) + f(k, j)) \u0026amp;\u0026amp; {i + 2 \\lt j 且 k = i + 1, i + 2, \u0026hellip;, j - 1} \\end{cases} \\end{equation} $$\n根据上述的递归过程和状态转移方程，可以写出记忆化搜索版本和严格位置依赖的 DP 版本。\n复杂度 时间复杂度：$O(n^3)$ 空间复杂度：$O(n^2)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public int minScoreTriangulation(int[] values) { int n = values.length; int[][] dp = new int[n][n]; // for (int i = 0; i \u0026lt; n - 3; i++) { // dp[i][i + 2] = values[i] * values[i + 1] * values[i + 2]; // } for (int i = n - 3, temp; i \u0026gt;= 0; i--) { for (int j = i + 2; j \u0026lt; n; j++) { dp[i][j] = Integer.MAX_VALUE; for (int k = i + 1; k \u0026lt; j; k++) { temp = values[i] * values[k] * values[j]; dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + temp); } } } return dp[0][n - 1]; } public int minScoreTriangulation1(int[] values) { int n = values.length; int[][] dp = new int[n][n]; return process(values, 0, n - 1, dp); } // 将 left 和 right 连起来，剩余一个定点在 (left, right) 之间寻找 public int process(int[] values, int i, int j, int[][] dp) { if (i + 1 \u0026gt;= j) { return 0; } if (dp[i][j] != 0) { return dp[i][j]; } if (i + 2 == j) { dp[i][j] = values[i] * values[i + 1] * values[i + 2]; return dp[i][j]; } int res = Integer.MAX_VALUE; for (int k = i + 1; k \u0026lt; j; k++) { int temp = values[i] * values[k] * values[j]; res = Math.min(res, temp + process(values, i, k, dp) + process(values, k, j, dp)); } dp[i][j] = res; return res; } } ","date":"2023-12-14T22:16:54+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-1039.-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%9A%84%E6%9C%80%E4%BD%8E%E5%BE%97%E5%88%86/","title":"LeetCode 1039. 多边形三角剖分的最低得分"},{"content":" LeetCode 486. 预测赢家\n算法讲解076【必备】区间dp-上\n思路 求解子问题：在区间 [i, j] 上，如果 A 先手，A 可以获取的最大分值是多少。\n求解过程 先通过递归求解。如果当前的区间是 [i, j]：\nbase case\ni == j：只有一个数，A 只能选 nums[i]。 i + 1 == j：有两个数，A 先手，A 肯定选较大的。 递归过程\n如果 A 选择了 nums[i]：在 [i + 1, j] 上 B 就是先手的，如果此时 B 选，他肯定会选择有利于自己的结果，让 A 在剩下的区间获得的分值最小。即 $min(f(i + 2, j), f(i + 1, j - 1))$。 同理，如果 A 选择了 nums[j]，B 同样会让 A 在剩余区间获得最小分值。即 $min(f(i + 1, j - 1), f(i, j - 2))$。 经过上方的思考，A 决定在两种选择中选择较大值。\n$$ \\begin{equation} f(i,j) = max \\left{ \\begin{aligned} nums_i + min(f(i + 2, j), f(i + 1, j - 1)) \\\\ nums_j + min(f(i + 1, j - 1), f(i, j - 2)) \\end{aligned} \\right. \\end{equation} $$\n挂个缓存表或者修改为严格位置依赖的版本都可以过。\n复杂度 时间复杂度：$O(n^2)$ 空间复杂度：$O(n^2)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public boolean predictTheWinner(int[] nums) { int n = nums.length; int[][] dp = new int[n][n]; int sum = 0; for (int i = 0; i \u0026lt; n; i++) { dp[i][i] = nums[i]; sum += nums[i]; } for (int i = 0; i \u0026lt; n - 1; i++) { dp[i][i + 1] = Math.max(nums[i], nums[i + 1]); } for (int i = n - 3; i \u0026gt;= 0; i--) { for (int j = i + 2; j \u0026lt; n; j++) { dp[i][j] = Math.max( nums[i] + Math.min(dp[i + 2][j], dp[i + 1][j - 1]), nums[j] + Math.min(dp[i][j - 2], dp[i + 1][j - 1]) ); } } return dp[0][n - 1] \u0026gt;= (sum - dp[0][n - 1]); } public boolean compute1(int[] nums) { int sum = 0; for (int num : nums) { sum += num; } int res = process(nums, 0, nums.length - 1); return res \u0026gt;= (sum - res); } // 返回在 [left, right] 上，A 先手的情况下，可以获得的最大分数 public int process(int[] nums, int left, int right) { if (left == right) { return nums[left]; } if (left + 1 == right) { return Math.max(nums[left], nums[right]); } // 如果 A 选作左边的，那么 B 可以选左右两边，B 选完后肯定留下较小的给 A。 int res1 = nums[left] + Math.min(process(nums, left + 2, right), process(nums, left + 1, right - 1)); int res2 = nums[right] + Math.min(process(nums, left, right - 2), process(nums, left + 1, right - 1)); return Math.max(res1, res2); } } ","date":"2023-12-14T22:15:28+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-486.-%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/","title":"LeetCode 486. 预测赢家"},{"content":" LeetCode 1312. 让字符串成为回文串的最少插入次数\n算法讲解076【必备】区间dp-上\n思路 提取子问题，求使 [i, j] 范围内的字符串变成回文串的最小操作是次数，根据两侧字符是否相等决定递归子问题的范围。\n求解过程 先写出递归方式。按照上述的思路，求使子串变成回文的最小操作次数。\nbase case\ni == j：只有一个字符，肯定是回文，返回 0 i + 1 == j：只有两个字符，如果相等是回文，返回 0；否则返回 1，添加一个字符。 递归过程\nstr[i] == str[j]：两侧已经构成回文，递归调用 process(i + 1, j - 1)。 否则，添加一个字符，分别使左右两侧字符形成回文，再递归调用下一个范围 process(i + 1, j) 和 process(i, j - 1), 选择最小的操作次数，再加上本次递归的一次操作次数。 空间优化\n分析递归调用的过程，有重复调用递归，所以挂一个 DP 表减少展开次数。然后修改为严格位置依赖的版本，根据分析，每个 (i, j) 位置的格子只依赖左侧，下侧和左下角的位置，因此定义 DP 顺序为 i 从大到小，j 从左向右。使用一维表格时，为了防止当前位置覆盖上一行的值，使用一个变量临时存储。\n复杂度 时间复杂度：$O(n^2)$ 空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class Solution { // DP + 空间压缩 public int minInsertions(String s) { char[] str = s.toCharArray(); int n = str.length; int[] dp = new int[n]; for (int i = n - 2, prev; i \u0026gt;= 0; i--) { prev = dp[i + 1]; dp[i + 1] = str[i] == str[i + 1] ? 0 : 1; for (int j = i + 2, temp; j \u0026lt; n; j++) { temp = dp[j]; if (str[i] == str[j]) { dp[j] = prev; } else { dp[j] = 1 + Math.min(dp[j - 1], dp[j]); } prev = temp; } } return dp[n - 1]; } // DP public int minInsertions1(String s) { char[] str = s.toCharArray(); int n = str.length; int[][] dp = new int[n][n]; for (int i = 0; i \u0026lt; n - 1; i++) { dp[i][i + 1] = str[i] == str[i + 1] ? 0 : 1; } for (int i = n - 3; i \u0026gt;= 0; i--) { for (int j = i + 2; j \u0026lt; n; j++) { if (str[i] == str[j]) { dp[i][j] = dp[i + 1][j - 1]; } else { dp[i][j] = 1 + Math.min(dp[i][j - 1], dp[i + 1][j]); } } } return dp[0][n - 1]; } // 暴力递归 public int process(char[] str, int left, int right) { if (left == right) { return 0; } if (left + 1 == right) { return str[left] == str[right] ? 0 : 1; } int res; if (str[left] == str[right]) { res = process(str, left + 1, right - 1); } else { res = 1 + Math.min(process(str, left, right - 1), process(str, left + 1, right)); } return res; } } ","date":"2023-12-14T17:34:11+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-1312.-%E8%AE%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%90%E4%B8%BA%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E6%8F%92%E5%85%A5%E6%AC%A1%E6%95%B0/","title":"LeetCode 1312. 让字符串成为回文串的最少插入次数"},{"content":" LeetCode 2132. 用邮票贴满网格图\n思路 遍历每一个邮票右下角可能符合要求的点，判断在邮票范围内是否存在被占据的点。如果存在，什么都不做；如果不存在，可以贴邮票，将邮票范围内的子矩阵整体加一，这里使用二维差分来实现。\n遍历完成后，将标记好的数组使用前缀和转化为表示邮票个数的数组。然后遍历数组中的每一个格子，如果某格子没有被占据，也不存在邮票，则返回 false。最终返回 true。\n求解过程 先统计网格的二维前缀和数组。然后遍历每一个可以作为邮票右下角的点：\n如果邮票范围内的格子存在被占据的情况，不能放邮票。 否则，放置邮票，通过差分将范围内的邮票数量加一。 最终还原每个格子的邮票数量，如果某个格子没有被占据，且邮票数量为 0，返回false。最终，不存在空格子没邮票，返回true。\n复杂度 时间复杂度：$O(n \\times m)$ 空间复杂度：$O(n \\times m)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public boolean possibleToStamp(int[][] grid, int stampHeight, int stampWidth) { int n = grid.length, m = grid[0].length; // if (stampHeight \u0026gt; n || stampWidth \u0026gt; m) { // return false; // } int[][] sums = new int[n + 1][m + 1]; int[][] res = new int[n + 1][m + 1]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { sums[i + 1][j + 1] = grid[i][j] + sums[i + 1][j] + sums[i][j + 1] - sums[i][j]; } } for (int i = stampHeight; i \u0026lt;= n; i++) { for (int j = stampWidth; j \u0026lt;= m; j++) { int cnt = sums[i][j] - sums[i][j - stampWidth] - sums[i - stampHeight][j] + sums[i - stampHeight][j - stampWidth]; // 如果可以放下 if (cnt == 0) { res[i - stampHeight + 1][j - stampWidth + 1] += 1; if (i \u0026lt; n) { res[i + 1][j - stampWidth + 1] -= 1; } if (j \u0026lt; m) { res[i - stampHeight + 1][j + 1] -= 1; } if (i \u0026lt; n \u0026amp;\u0026amp; j \u0026lt; m) { res[i + 1][j + 1] += 1; } } } } for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { res[i + 1][j + 1] += res[i + 1][j] + res[i][j + 1] - res[i][j]; if (grid[i][j] == 0 \u0026amp;\u0026amp; res[i + 1][j + 1] == 0) { return false; } } } return true; } } ","date":"2023-12-14T16:19:47+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2132.-%E7%94%A8%E9%82%AE%E7%A5%A8%E8%B4%B4%E6%BB%A1%E7%BD%91%E6%A0%BC%E5%9B%BE/","title":"LeetCode 2132. 用邮票贴满网格图"},{"content":" PKU Judging Online - 1742 Coins\n算法讲解075【必备】背包dp-多重背包、混合背包\n思路 通过不同种类及不同数量的硬币进行组合，判断这些硬币可以组合成 [0, m] 上的哪些值，返回最终的种类数。\n这是一道混合背包题目，根据硬币的数量和面值，灵活选择使用 01 背包、完全背包或者多重背包。\n求解过程 根据硬币的数量，选择不同的解决方式：\n如果硬币只有 1 个，使用 01 背包。 如果硬币有 k 个 $(k \\times value_i \\le m)$，相当于多重背包，使用多重背包来解决。 如果硬币有 k 个 $(k \\times value_i \\gt m)$，相当于完全背包，用完全背包来解决。 ACWing 01背包问题\n洛谷 P1616 疯狂的采药\n洛谷 P1776 宝物筛选（单调队列优化）\n复杂度 时间复杂度：$O(n \\times m)$ 空间复杂度：$O(m)$ 经过优化，三种背包问题的时间复杂度都是 $O(n \\times m)$，空间复杂度都是 $O(m)$。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 import java.io.*; import java.util.Arrays; public class Main { public static int MAXN = 101; public static int MAXM = 100001; public static int[] value = new int[MAXN]; public static int[] count = new int[MAXN]; public static boolean[] dp = new boolean[MAXM]; public static int n, m; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer in = new StreamTokenizer(br); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while (in.nextToken() != StreamTokenizer.TT_EOF) { n = (int)in.nval; in.nextToken(); m = (int)in.nval; if (n == 0 \u0026amp;\u0026amp; m == 0) { break; } for (int i = 1; i \u0026lt;= n; i++) { in.nextToken(); value[i] = (int)in.nval; } for (int i = 1; i \u0026lt;= n; i++) { in.nextToken(); count[i] = (int)in.nval; } out.println(compute()); } out.flush(); out.close(); br.close(); } public static int compute() { Arrays.fill(dp, 1, m + 1, false); dp[0] = true; for (int i = 1; i \u0026lt;= n; i++) { if (count[i] == 1) { // 01 背包 for (int j = m; j \u0026gt;= value[i]; j--) { if (dp[j - value[i]]) { // 如果选一个，且上次为 true dp[j] = true; } } } else if (value[i] * count[i] \u0026gt; m) { // 完全背包 for (int j = value[i]; j \u0026lt;= m; j++) { if (dp[j - value[i]]) { dp[j] = true; } } } else { for (int spare = 0; spare \u0026lt; value[i]; spare++) { int cnt = 0; for (int j = m - spare, k = 0; j \u0026gt;= 0 \u0026amp;\u0026amp; k \u0026lt;= count[i]; j -= value[i], k++) { if (dp[j]) { cnt++; } } for (int j = m - spare, l = j - (count[i] + 1) * value[i]; j \u0026gt;= 1; j -= value[i], l -= value[i]) { if (dp[j]) { cnt--; } else { dp[j] = cnt \u0026gt; 0; } if (l \u0026gt;= 0 \u0026amp;\u0026amp; dp[l]) { cnt++; } } } } } int ans = 0; for (int j = 1; j \u0026lt;= m; j++) { if (dp[j]) { ans++; } } return ans; } } ","date":"2023-12-13T17:15:58+08:00","permalink":"https://zhuaowei.github.io/article/pku-judging-online-1742-coins/","title":"PKU Judging Online - 1742 Coins"},{"content":" 洛谷 P1833 赏樱花\n算法讲解075【必备】背包dp-多重背包、混合背包\n思路 通过转化，将完全背包转化为多重背包，再通过二进制分组，将多重背包转化为 01 背包。如果物品数量有限，通过二进制分组转化为 01 背包；如果物品数量无限，根据最大花费和物品价格计算出可以选择的最大数量，转化为多重背包，再转化为 01 背包。\n求解过程 多重背包二进制分组的原理：洛谷 P1776 宝物筛选（二进制分组优化）\n读取时，根据物品的数量进行二进制分组。如果物品数量为 0，设置为物品的最大数量进行二进制分组；如果是其他，直接进行二进制分组。\n分完组后，使用 01 背包的方式求解。\n复杂度 时间复杂度：$O(\\sum_{i = 1}^{N}{(1 + log_2P_i)} \\times T)$ N 为樱花种类数量，P 为观赏次数，T 为剩余时间。\n空间复杂度：$O(T)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 import java.io.*; import java.util.Arrays; public class Main { public static int MAXN = 100001; public static int MAXT = 1001; public static int[] time = new int[MAXN]; public static int[] value = new int[MAXN]; public static int[] dp = new int[MAXT]; public static int n, t, m; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer in = new StreamTokenizer(br); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while (in.nextToken() != StreamTokenizer.TT_EOF) { int startHour, startMinute, endHour, endMinute; startHour = (int)in.nval; in.nextToken(); in.nextToken(); startMinute = (int)in.nval; in.nextToken(); endHour = (int)in.nval; in.nextToken(); in.nextToken(); endMinute = (int)in.nval; in.nextToken(); // 计算剩余时间 t = (endMinute + 60 - startMinute) + (endHour - startHour - 1) * 60; n = (int)in.nval; m = 0; for (int i = 1, cost, val, cnt; i \u0026lt;= n; i++) { in.nextToken(); cost = (int)in.nval; in.nextToken(); val = (int)in.nval; in.nextToken(); cnt = (int)in.nval; if (cnt == 0) { cnt = MAXT; } for (int r = 1; r \u0026lt;= cnt; r \u0026lt;\u0026lt;= 1) { time[++m] = r * cost; value[m] = r * val; cnt -= r; } if (cnt \u0026gt; 0) { time[++m] = cnt * cost; value[m] = cnt * val; } } out.println(compute()); } out.flush(); out.close(); br.close(); } public static int compute() { Arrays.fill(dp, 1, t + 1, 0); for (int i = 1; i \u0026lt;= m; i++) { for (int j = t; j \u0026gt;= time[i]; j--) { dp[j] = Math.max(dp[j], dp[j - time[i]] + value[i]); } } return dp[t]; } } ","date":"2023-12-13T17:15:13+08:00","permalink":"https://zhuaowei.github.io/article/%E6%B4%9B%E8%B0%B7-p1833-%E8%B5%8F%E6%A8%B1%E8%8A%B1/","title":"洛谷 P1833 赏樱花"},{"content":" 洛谷 P1776 宝物筛选\n算法讲解075【必备】背包dp-多重背包、混合背包\n思路 在无优化版本的基础上进行优化，根据物品重量的余数，将最大重量进行分组，使用单调队列，分别对组内的 dp 结果求区间的最大值，这样就可以快速地获取最大重量时的最优结果，求出最优解。\n求解过程 根据余数分组\n首先在无优化版本中，dp[i][j] 的 j 是线性变化的，单位为 1。而物品的重量为 $w_i$，求上一个装载 k - 1 个物品的最大价值时，依赖的是 dp[i - 1][j - w[i]] + v[i]。如果依次求余数为 [0 -\u0026gt; w[i] - 1] 的组，它不会缺少依赖，时间复杂度也跟之前一样。\n这样，我们可以维护一个大小为 $cnt_i \\times w_i$ 的窗口，表示当前可以选择的物品重量范围，在这个窗口内，选择任意个物品的结果都会进入单调队列，并在队列头部存储窗口内的最大值，这样，我们就可以直接选择最优解，时间复杂度也不高。\nDP 过程\nbase case dp[0][0] = 0。遍历每一种物品，在循环中依次以 0, 1, 2, ..., wi - 1 为开头，跨度为 w[i] 地进行遍历。在每一轮遍历中，使用一个单调栈记录下区间最大值：\n将当前 j 位置的结果进队，保持队列呈严格递增序。 判断左边界 j - (cnt[i] + 1) * w[i] 是否为最大值的索引，如果是，队列头部右移。因为区间大小是 cnt[i] * w[i]，+ 1 是在这一轮循环中滑窗之外的，需要去掉。 现在单调队列的窗口范围是正确的，求出 dp[i][j] 的最大值（取队头）。 空间压缩\n分析依赖关系，当前 [i,j] 位置的 dp 结果依赖上一行 \u0026lt;= j 的位置，所以在使用一行时，需要从后向前遍历。同时，因为使用了单调队列，它维持的是在 i - 1 行时，窗口内的最大值，所以在开始遍历之前，[j - cnt[i] * w[i], j] 范围内的单调队列。\n复杂度 时间复杂度：$n \\times m$ 空间复杂度：$m$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 import java.io.*; import java.util.Arrays; public class Main { public static int MAXN = 101; public static int MAXW = 40001; public static int[] weight = new int[MAXN]; public static int[] value = new int[MAXN]; public static int[] cnt = new int[MAXN]; public static int[] dp = new int[MAXW]; public static int[] deque = new int[MAXW]; public static int n, w, h, t; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer in = new StreamTokenizer(br); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while (in.nextToken() != StreamTokenizer.TT_EOF) { n = (int) in.nval; in.nextToken(); w = (int) in.nval; for (int i = 1; i \u0026lt;= n; i++) { in.nextToken(); value[i] = (int) in.nval; in.nextToken(); weight[i] = (int) in.nval; in.nextToken(); cnt[i] = (int) in.nval; } out.println(compute3()); } out.flush(); out.close(); br.close(); } // 严格位置依赖的动态规划 public static int compute1() { int[][] dp = new int[n + 1][w + 1]; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= w; j++) { dp[i][j] = dp[i - 1][j]; for (int k = 1; k \u0026lt;= cnt[i] \u0026amp;\u0026amp; k * weight[i] \u0026lt;= j; k++) { dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - k * weight[i]] + k * value[i]); } } } return dp[n][w]; } // 单调队列优化 public static int compute2() { int[][] dp = new int[n + 1][w + 1]; for (int i = 1; i \u0026lt;= n; i++) { // 使用余数作为遍历开始 for (int spare = 0; spare \u0026lt;= Math.min(w, weight[i] - 1); spare++) { h = t = 0; for (int j = spare; j \u0026lt;= w; j += weight[i]) { while (h \u0026lt; t \u0026amp;\u0026amp; dp[i - 1][deque[t - 1]] + diffValue(j - deque[t - 1], i) \u0026lt;= dp[i - 1][j]) { t--; } deque[t++] = j; if (deque[h] == j - (cnt[i] + 1) * weight[i]) { h++; } dp[i][j] = dp[i - 1][deque[h]] + diffValue(j - deque[h], i); } } } return dp[n][w]; } // 例如前后两个结果，相差 diff 重量，求他们差的 value 是多少 public static int diffValue(int diff, int i) { return diff / weight[i] * value[i]; } // 单调队列优化 + 空间优化 public static int compute3() { Arrays.fill(dp, 1, w + 1, 0); for (int i = 1; i \u0026lt;= n; i++) { // 使用余数作为遍历开始 for (int spare = 0; spare \u0026lt;= Math.min(w, weight[i] - 1); spare++) { h = t = 0; // 先把单调队列初始化一下 for (int j = w - spare, k = 0; j \u0026gt;= 0 \u0026amp;\u0026amp; k \u0026lt;= cnt[i]; j -= weight[i], k++) { while (h \u0026lt; t \u0026amp;\u0026amp; dp[j] + diffValue(deque[t - 1] - j, i) \u0026gt;= dp[deque[t - 1]]) { t--; } deque[t++] = j; } for (int j = w - spare; j \u0026gt;= 0; j -= weight[i]) { dp[j] = dp[deque[h]] + diffValue(j - deque[h], i); if (deque[h] == j) { h++; } int enter = j - (cnt[i] + 1) * weight[i]; if (enter \u0026gt;= 0) { while (h \u0026lt; t \u0026amp;\u0026amp; dp[enter] + diffValue(deque[t - 1] - enter, i) \u0026gt;= dp[deque[t - 1]]) { t--; } } deque[t++] = enter; } } } return dp[w]; } } ","date":"2023-12-13T17:09:06+08:00","permalink":"https://zhuaowei.github.io/article/%E6%B4%9B%E8%B0%B7-p1776-%E5%AE%9D%E7%89%A9%E7%AD%9B%E9%80%89%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/","title":"洛谷 P1776 宝物筛选（单调队列优化）"},{"content":" 洛谷 P1776 宝物筛选\n算法讲解075【必备】背包dp-多重背包、混合背包\n思路 物品的数量可以分解为几个二进制数字的组合，通过对这几个二进制数的组合，可以表示在 [0, cnt] 之间选取任意个数量的物品。\n求解过程 整数分解\n任何一个正整数都可以被分解成二进制的形式，例如 17 -\u0026gt; [1, 2, 4, 8, 2]。\n具体的分解过程为：\n17 包含 1，分解为 1 + 16 16 包含 2，分解为 2 + 14 14 包含 4，分解为 4 + 10 14 包含 8，分解为 8 + 2 2 不包含 16，结束。最后分解为 2。 组合\n这些分解出来的数字可以组成任意 [0, cnt] 之间的数，也就是说它可以表示选取任意多个物品，但是它的时间复杂度仅为 $1 + \\lfloor log_2target \\rfloor$。\n数据处理\n在读取数据的时候，根据物品的数量分解，计算每个段的物品价值和花费，将每个分段的物品作为最终 DP 的物品列表进行计算，使用 01 背包的方式。\n复杂度 时间复杂度：$O(\\sum_{i = 1}^{n}{(1 + log_2cnt_i)} \\times m)$ 空间复杂度：$O(m)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import java.io.*; import java.util.Arrays; public class Main { public static int MAXN = 1001; public static int MAXW = 40001; public static int[] cost = new int[MAXN]; public static int[] value = new int[MAXN]; public static int[] cnt = new int[MAXN]; public static int[] dp = new int[MAXW]; public static int n, w, m; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer in = new StreamTokenizer(br); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while (in.nextToken() != StreamTokenizer.TT_EOF) { n = (int)in.nval; in.nextToken(); w = (int)in.nval; m = 0; for (int i = 1, v, weight, count, r; i \u0026lt;= n; i++) { in.nextToken(); v = (int)in.nval; in.nextToken(); weight = (int)in.nval; in.nextToken(); count = (int)in.nval; // 核心 r = 1; while (r \u0026lt;= count) { value[++m] = r * v; cost[m] = r * weight; count -= r; r \u0026lt;\u0026lt;= 1; } if (count \u0026gt; 0) { value[++m] = count * v; cost[m] = count * weight; } } out.println(compute()); } out.flush(); out.close(); br.close(); } public static int compute() { Arrays.fill(dp, 0, w + 1, 0); for (int i = 1; i \u0026lt;= m; i++) { for (int j = w; j \u0026gt;= cost[i]; j--) { dp[j] = Math.max(dp[j], dp[j - cost[i]] + value[i]); } } return dp[w]; } } ","date":"2023-12-13T17:08:27+08:00","permalink":"https://zhuaowei.github.io/article/%E6%B4%9B%E8%B0%B7-p1776-%E5%AE%9D%E7%89%A9%E7%AD%9B%E9%80%89%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E7%BB%84%E4%BC%98%E5%8C%96/","title":"洛谷 P1776 宝物筛选（二进制分组优化）"},{"content":" 洛谷 P1776 宝物筛选\n算法讲解075【必备】背包dp-多重背包、混合背包\n思路 首先说一下，这个不优化的版本是无法通过全部测试用例的。\n多重背包相较于完全背包和 01 背包，它的物品数量是有限的，它的每个物品可以选 0 \u0026hellip; cnt 个。所以可以在 01 背包的基础上再套一层循环，来限制选择的个数。\n求解过程 base case\n前 0 个物品选择价值为小于等于 j 的最小花费是 0。\nDP 过程\n选 0 个：dp[i - 1][j] 选 1 个：dp[i - 1][j - cost[i]] + value[i] 选 k 个：dp[i - 1][j - k * cost[i]] + k * value[i] 上述选 k 个的前提是当前的钱数能够买 k 个。\n复杂度 时间复杂度：$O(n \\times m \\times \\sum_{k = 1}^{cnt}count_i)$ n 为物品种类数量，m 为最大花费，$\\sum_{k = 1}^{cnt}count_i)$ 为所有物品的总数量。这个时间复杂度很大，不进行优化是无法通过测试全部用例的。\n空间复杂度：$O(m)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 import java.io.*; import java.util.Arrays; public class Main { public static int MAXN = 101; public static int MAXW = 40001; public static int[] weight = new int[MAXN]; public static int[] value = new int[MAXN]; public static int[] cnt = new int[MAXN]; public static int[] dp = new int[MAXW]; public static int n, w; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer in = new StreamTokenizer(br); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while (in.nextToken() != StreamTokenizer.TT_EOF) { n = (int) in.nval; in.nextToken(); w = (int) in.nval; for (int i = 1; i \u0026lt;= n; i++) { in.nextToken(); value[i] = (int) in.nval; in.nextToken(); weight[i] = (int) in.nval; in.nextToken(); cnt[i] = (int) in.nval; } out.println(compute2()); } out.flush(); out.close(); br.close(); } // 严格位置依赖的动态规划 public static int compute1() { int[][] dp = new int[n + 1][w + 1]; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= w; j++) { dp[i][j] = dp[i - 1][j]; for (int k = 1; k \u0026lt;= cnt[i] \u0026amp;\u0026amp; k * weight[i] \u0026lt;= j; k++) { dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - k * weight[i]] + k * value[i]); } } } return dp[n][w]; } // 时间复杂度太高 public static int compute1() { Arrays.fill(dp, 0, w + 1, 0); for (int i = 1; i \u0026lt;= n; i++) { // dp[i][j] = dp[i - 1][j] for (int j = w; j \u0026gt;= cost[i]; j--) { for (int k = 1; k \u0026lt;= cnt[i] \u0026amp;\u0026amp; k * cost[i] \u0026lt;= j; k++) { dp[j] = Math.max(dp[j], dp[j - k * cost[i]] + k * value[i]); } } } return dp[w]; } } ","date":"2023-12-13T17:08:06+08:00","permalink":"https://zhuaowei.github.io/article/%E6%B4%9B%E8%B0%B7-p1776-%E5%AE%9D%E7%89%A9%E7%AD%9B%E9%80%89%E6%97%A0%E6%9E%9A%E4%B8%BE%E4%BC%98%E5%8C%96/","title":"洛谷 P1776 宝物筛选（无枚举优化）"},{"content":" LeetCode 2697. 字典序最小回文串\n思路 从两边向中间遍历，如果相等就跳过，如果不相等就让小的字符赋值为大的字符。\n求解过程 使用双指针分别指向字符串的开头和结尾，依次判断指针指向的字符是否相等：\n相等：两指针向中心移动一格。 不相等：让较小的字符赋值给较大的字符的位置。 复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public String makeSmallestPalindrome(String s) { char[] str = s.toCharArray(); int left = 0, right = str.length - 1; while (left \u0026lt; right) { if (str[left] \u0026lt; str[right]) { str[right] = str[left]; } else if (str[left] \u0026gt; str[right]) { str[left] = str[right]; } left++; right--; } return String.valueOf(str); } } ","date":"2023-12-13T17:00:06+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2697.-%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E5%9B%9E%E6%96%87%E4%B8%B2/","title":"LeetCode 2697. 字典序最小回文串"},{"content":" 洛谷 P2918 [USACO08NOV] Buying Hay S\n算法讲解074【必备】背包dp-分组背包、完全背包\n思路 如果使用花费钱数作为 DP 维度，根据计算得知，花费的钱数最多为 $2.5 \\times 10^8$，需要 125 MB的空间开辟一个 DP 表，显然是不行的。\n如果使用干草数量作为 DP 维度，干草数量显然不会超出最大值很多，是可以开辟足够空间的。\n求解过程 最大的干草数量\n需要购买的干草数量最多为 $H(1 \u0026lt;= H \u0026lt;= 50000)$，没捆干草最多为 5000，所以可能当前购买的干草不够 H，但是加上下一捆干草数量就够了，也就不需要再买了，多了也不优惠。因此干草数量最多为 55000。 对于具体的实例，最大的干草数量为 需要购买的干草数量加上干草最大捆的数量。\n定义\ni 为在前 i 家公司购买干草 j 为购买的干草数量严格等于 j dp[i][j] 为在前 i 家公司购买的干草数量严格等于 j 的最小花费。 base case\ndp[0][0] = 0：在前 0 家选购干草数量为 0 的最小花费。 dp[0][1 -\u0026gt; m] = Integer.MAX_VALUE: 在前 0 家选购干草数量为 m 的最小花费，因为没有公司，无法选购干草，设置为 MAX_VALUE 是表示方案不可达。 DP过程\n当前来到第 i 家公司：\n如果一捆都不买：dp[i][j] = dp[i - 1][j] 如果买一捆：dp[i][j] = dp[i - 1][j - value[i]] + cost[i]，因为上面的不买方案 dp[i][j] = dp[i - 1][j]，所以等价于 dp[i][j] = dp[i][j - value[i]] + cost[i] 购买 n 捆：dp[i][j] = dp[i][j - value[i]] + cost[i]，计算之前已经在 i 家公司买了 n - 1 捆。 2 3 可以合并为一个表达式，在上述所有情况中选择最小值作为 dp[i][j] 的结果。\n在 DP 过程中，需要先判断上一个方案是否可行，如果不可行，就不能继续购买。 最终，在达到购买要求的干草数量上遍历，取出花费最小的方案。\n空间压缩\n跟完全背包一样的压缩方式，分析依赖关系，确定遍历顺序\u0026hellip;\n复杂度 时间复杂度：$O(n \\times m)$ 空间复杂度：$O(m)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import java.io.*; import java.util.Arrays; public class Main { public static int MAXH = 55001; public static int MAXN = 101; public static int[] cost = new int[MAXN]; public static int[] value = new int[MAXN]; public static int[] dp = new int[MAXH]; public static int n, h, m; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer in = new StreamTokenizer(br); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while (in.nextToken() != StreamTokenizer.TT_EOF) { n = (int)in.nval; in.nextToken(); h = (int)in.nval; int maxV = 0; for (int i = 1; i \u0026lt;= n; i++) { in.nextToken(); value[i] = (int)in.nval; maxV = Math.max(maxV, value[i]); in.nextToken(); cost[i] = (int)in.nval; } m = h + maxV; // 最多购入这么多干草 out.println(compute()); } out.flush(); out.close(); br.close(); } public static int compute() { Arrays.fill(dp, 1, m + 1, Integer.MAX_VALUE); for (int i = 1; i \u0026lt;= n; i++) { for (int j = value[i]; j \u0026lt;= m ; j++) { if (dp[j - value[i]] != Integer.MAX_VALUE) { dp[j] = Math.min(dp[j], dp[j - value[i]] + cost[i]); } } } int ans = Integer.MAX_VALUE; for (int i = h; i \u0026lt;= m; i++) { ans = Math.min(ans, dp[i]); } return ans; } } ","date":"2023-12-12T16:44:32+08:00","permalink":"https://zhuaowei.github.io/article/%E6%B4%9B%E8%B0%B7-p2918-usaco08nov-buying-hay-s/","title":"洛谷 P2918 [USACO08NOV] Buying Hay S"},{"content":" LeetCode 44. 通配符匹配\n算法讲解074【必备】背包dp-分组背包、完全背包\n思路 首先先写出暴力递归的版本，在 s 串来到 i，p 串来到 j 时，判断 i,j 之后的字符串能否匹配。写出递归调用的 base case 和 递归调用过程。\n求解过程 base case\n当 i 来到末尾时：\na. j 也来到末尾：匹配成功，返回 true。\nb. j 没有来到末尾：查看 j 及之后的字符是否全是 *，如果全是，返回 true，否则返回 false。\n当 i 没有到末尾，j 来到了末尾时：肯定无法匹配，返回 false。\n递归过程\n如果 p[j] == '*': 选择匹配 0 个或者 1 个字符，继续匹配。 如果 p[j] != '*': 必须匹配一个字符。如果 str[i] == pat[j] || pat[j] == '?'，继续匹配，否则返回 false。 写出来暴力递归后，是无法通过的，需要修改为记忆化搜索或者 DP 版本。根据 base case 和递归调用过程修改为 DP 版本，下面是最终的空间压缩版本。\n复杂度 时间复杂度：$O(n \\times m)$ 空间复杂度：$O(m)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class Solution { public boolean isMatch(String s, String p) { char[] str = s.toCharArray(); char[] pat = p.toCharArray(); int n = str.length, m = pat.length; boolean[] dp = new boolean[m + 1]; dp[m] = true; for (int j = m - 1; j \u0026gt;= 0; j--) { if (pat[j] != \u0026#39;*\u0026#39;) { break; } dp[j] = true; } for (int i = n - 1; i \u0026gt;= 0; i--) { // dp[i][m] = false; boolean prev = dp[m], temp; dp[m] = false; for (int j = m - 1; j \u0026gt;= 0; j--) { temp = dp[j]; if (pat[j] == \u0026#39;*\u0026#39;) { dp[j] = dp[j] || dp[j + 1]; } else { dp[j] = (str[i] == pat[j] || pat[j] == \u0026#39;?\u0026#39;) \u0026amp;\u0026amp; prev; } prev = temp; } } return dp[0]; } // 暴力递归 public boolean process(char[] str, char[] pat, int i, int j) { // i 到头了 if (i == str.length) { if (j == pat.length) { // j 也到头了，返回 true return true; } else { // 如果后面全是 * 返回true，否则返回 false while (j \u0026lt; pat.length) { if (pat[j] != \u0026#39;*\u0026#39;) { return false; } j++; } return true; } } // i 没到头，j 到头了，返回 false if (j == pat.length) { return false; } // i j 都没到头 if (pat[j] == \u0026#39;*\u0026#39;) { return process(str, pat, i, j + 1) || process(str, pat, i + 1, j); } else { return (str[i] == pat[j] || pat[j] == \u0026#39;?\u0026#39;) \u0026amp;\u0026amp; process(str, pat, i + 1, j + 1); } } } ","date":"2023-12-12T16:38:58+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-44.-%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/","title":"LeetCode 44. 通配符匹配"},{"content":" LeetCode 10. 正则表达式匹配\n算法讲解074【必备】背包dp-分组背包、完全背包\n思路 使用暴力递归，然后根据暴力递归写出记忆化搜索版本或者直接到 DP 版本。暴力递归中，当 s 串来到 i 位置，p 串来到 j 位置，判断 i,j 之后的字符串能够匹配。\n求解过程 暴力递归的base case：\ni 到达了 s 的末尾：如果 j 也到达了 p 的末尾，匹配成功；如果 j 没有到达末尾，判断 p 串剩余的能否匹配空串，即剩余部分应为类似 \u0026quot;a*.*\u0026quot; 这种串。 i 没有到达结尾，但是 j 到达了末尾，肯定无法匹配。无法用一个空的模板匹配非空串。 递归过程\n如果 j + 1 不越界且为 *：\na. 让 [j, j + 1] 匹配空串，继续匹配。\nb. 让 [j, j + 1] 匹配一个字符，然后继续匹配。\n如果 j + 1 越界或者 j + 1 不为 *，必须匹配单个字符：\na. 匹配成功（s[i] == p[j] || p[j] == '.'）： 继续匹配。\nb. 匹配失败：返回 false。\n写出递归过程后，根据递归的 base case 和 递归过程，写出记忆化搜索版本和 DP 版本。\n复杂度 时间复杂度：$O(n \\times m)$ 空间复杂度：$O(n \\times m)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Solution { public boolean isMatch(String s, String p) { char[] str = s.toCharArray(); char[] pat = p.toCharArray(); int n = str.length, m = pat.length; boolean[][] dp = new boolean[n + 1][m + 1]; dp[n][m] = true; for (int j = m - 1; j \u0026gt;= 0; j--) { dp[n][j] = j + 1 \u0026lt; m \u0026amp;\u0026amp; pat[j + 1] == \u0026#39;*\u0026#39; \u0026amp;\u0026amp; dp[n][j + 2]; } for (int i = n - 1; i \u0026gt;= 0; i--) { // dp[i][m] = false; for (int j = m - 1; j \u0026gt;= 0; j--) { if (j + 1 \u0026lt; m \u0026amp;\u0026amp; pat[j + 1] == \u0026#39;*\u0026#39;) { // 把模板消掉，看看能不能匹配 dp[i][j] = dp[i][j + 2] || ((str[i] == pat[j] || pat[j] == \u0026#39;.\u0026#39;) \u0026amp;\u0026amp; dp[i + 1][j]); } else { dp[i][j] = ((str[i] == pat[j] || pat[j] == \u0026#39;.\u0026#39;) \u0026amp;\u0026amp; dp[i + 1][j + 1]); } } } return dp[0][0]; } // 暴力递归，也能过 public boolean process(char[] s, char[] p, int i, int j) { if (i == s.length) { // i 到头了 ，j 也到头了 if (j == p.length) { return true; } else { // j 没到头，但是末尾可以消除，消除后能到头，也返回 true，否则返回 false return j + 1 \u0026lt; p.length \u0026amp;\u0026amp; p[j + 1] == \u0026#39;*\u0026#39; ? process(s, p, i, j + 2) : false; } } if (j == p.length) { // i 没到头，j 到头了，返回 false return false; } boolean res = false; // 剩下就是都没到头的情况 if (j + 1 \u0026lt; p.length \u0026amp;\u0026amp; p[j + 1] == \u0026#39;*\u0026#39;) { // 把模板消掉，看看能不能匹配 res = res || process(s, p, i, j + 2); if (s[i] == p[j] || p[j] == \u0026#39;.\u0026#39;) { // 可以匹配，继续匹配 res = res || process(s, p, i + 1, j); } } else { // 只匹配一个字符 if (s[i] == p[j] || p[j] == \u0026#39;.\u0026#39;) { res = res || process(s, p, i + 1, j + 1); } else { res = res || false; } } return res; } } ","date":"2023-12-12T15:34:17+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-10.-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/","title":"LeetCode 10. 正则表达式匹配"},{"content":" LeetCode 2454. 下一个更大元素 IV\n苗 - 【CPP】单调栈 + 优先队列\n思路 将求解下下一个更大元素分成两步，先求下一个更大元素，如果有，存储起来，再求下下一个更大元素。\n求解过程 使用一个栈和一个优先队列（也可以使用两个栈），一个用来计算出某元素是否有下一个更大元素，另一个存储 有下一个更大元素的集合。\n遍历每一个元素，首先判断优先队列中是否有元素，如果有再看看当前元素是否大于它中的元素。因为优先队列里存储的元素已经找到过一个更大元素了，如果当前元素再大于它，就找到两个了。然后使用单调栈，计算出当前元素是否大于栈内的元素，如果大于，说明栈内的元素找到了一个更大元素。\n两个单调栈\n优先队列的目的是取出队列中最小的元素，依次判断当前元素是否大于它，如果为空或者不大于，就停止。\n如果使用单调栈实现：判断是否有下一个更大值的栈，它是单调递减的，从这个栈中弹出，然后压入到另一个栈中，那么另一个栈中的元素就是单调递增的，所以要将栈栈弹出的元素翻转过来再进入另一个栈。\n复杂度 时间复杂度：$O(n \\times log_2n)$ 空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int[] secondGreaterElement(int[] nums) { int n = nums.length; // 普通的单调栈，用于判断是否找到当前位置右侧第一个大于它的数字。 int[] stack = new int[n]; int r = 0; // 优先队列，加快查找，存储的是已经找到 右侧第一个大于它 的索引 PriorityQueue\u0026lt;int[]\u0026gt; queue = new PriorityQueue\u0026lt;\u0026gt;((num1, num2) -\u0026gt; num1[1] - num2[1]); int[] ans = new int[n]; Arrays.fill(ans, -1); for (int i = 0; i \u0026lt; n; i++) { while (!queue.isEmpty() \u0026amp;\u0026amp; queue.peek()[1] \u0026lt; nums[i]) { // queue 里的数字是已经找到一个大于它的数字了，现在判断第二个是否大于它 ans[queue.poll()[0]] = nums[i]; } while (r \u0026gt; 0 \u0026amp;\u0026amp; nums[stack[r - 1]] \u0026lt; nums[i]) { queue.add(new int[] {stack[r - 1], nums[stack[r - 1]]}); r--; } stack[r++] = i; } return ans; } } ","date":"2023-12-12T11:20:50+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2454.-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-iv/","title":"LeetCode 2454. 下一个更大元素 IV"},{"content":" LeetCode 1631. 最小体力消耗路径\n参考题解的方法二：zerotrac 🌸 - 最小体力消耗路径\n思路 体力消耗的计算方式是在 (0,0) -\u0026gt; (n - 1,m - 1) 的路径中，相邻两个节点的最大高度差，跟路径的长度无关。所以要找到最小体力消耗路径，要尽量选择高度差小的边，判断当前边组成的路径能够走到右下角的点。\n求解过程 首先将所有的边存储起来，同时记录下这条边两端的高度差，然后按照高度差的大小将每条边进行排序。\n遍历每一条边，将两端的节点连接起来，判断能够到达右下角。如果不能到达，继续添加边；如果可以到达，返回此时的高度差。\n为了判断图中左上角和右下角能否连通，可以使用并查集实现。在开始遍历边之前初始化并查集，然后每添加一条边就判断是否连通。\n复杂度 时间复杂度：$O(n \\times m)$ 空间复杂度：$O(n \\times m)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class Solution { int[] father; public int minimumEffortPath(int[][] heights) { int n = heights.length, m = heights[0].length; ArrayList\u0026lt;int[]\u0026gt; edges = new ArrayList\u0026lt;\u0026gt;(); father = new int[n * m]; initUnionFind(); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { int id = m * i + j; if (i \u0026gt; 0) { edges.add(new int[] {id - m, id, Math.abs(heights[i][j] - heights[i - 1][j])}); } if (j \u0026gt; 0) { edges.add(new int[] {id - 1, id, Math.abs(heights[i][j] - heights[i][j - 1])}); } } } // 按照差值排序 Collections.sort(edges, (e1, e2) -\u0026gt; e1[2] - e2[2]); for (int[] edge : edges) { unite(edge[0], edge[1]); if (isSameSet(0, n * m - 1)) { return edge[2]; } } return 0; } public void initUnionFind() { for (int i = 0; i \u0026lt; father.length; i++) { father[i] = i; } } public void unite(int a, int b) { int fa = find(a); int fb = find(b); if (fa == fb) { return; } father[fa] = fb; } public boolean isSameSet(int a, int b) { int fa = find(a); int fb = find(b); return fa == fb; } public int find(int x) { if (x == father[x]) { return x; } else { father[x] = find(father[x]); return father[x]; } } } ","date":"2023-12-11T21:05:37+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-1631.-%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84/","title":"LeetCode 1631. 最小体力消耗路径"},{"content":" 洛谷 P1616 疯狂的采药\nB站左程云：算法讲解074【必备】背包dp-分组背包、完全背包\n思路 完全背包和 01 背包的区别：01 背包每个物品只能选一次，选或不选；完全背包每个物品可以无限选，选择 n 件（n = 0, 1, 2, 3\u0026hellip;）。\n因为每一种物品都可以无限选，所以在来到第 i 件物品时：\n如果一件都不选：$dp[i][j] = dp[i - 1][j]$\n如果选，在之前已经选了 n 件的基础上（n = 0, 1, 2, 3\u0026hellip;），再次选择一件：$dp[i][j] = dp[i][j - cost_i] + value_i$。\n在上述各种可能里选择最大的结果。\n求解过程 根据上述过程，对每一件物品计算选择 n 件的结果，取最大值。\n空间压缩\n这题数据量很大，只能进行空间压缩才能过，否则会 TLE。\n如果只用一行进行 DP，分析一下 $dp[i][j]$ 的依赖：\n如果不选，它依赖上一行的 $dp[j]$，因为只有一行，不用改。 如果选择，它依赖本行的 $dp[j - cost_i]$，所以在求 $dp[j]$ 时，应该先计算好本行索引比自己小的位置，所以从左往右遍历。(01 背包是从右往左) 复杂度 时间复杂度：$O(n \\times m)$ 空间复杂度：$O(m)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import java.io.*; import java.util.Arrays; public class Main { public static int MAXT = (int)1e7 + 1; public static int MAXM = (int)1e4 + 1; public static int[] cost = new int[MAXM]; public static int[] value = new int[MAXM]; public static long[] dp = new long[MAXT]; public static int t, m; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer in = new StreamTokenizer(br); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while (in.nextToken() != StreamTokenizer.TT_EOF) { t = (int)in.nval; in.nextToken(); m = (int)in.nval; for (int i = 1; i \u0026lt;= m; i++) { in.nextToken(); cost[i] = (int)in.nval; in.nextToken(); value[i] = (int)in.nval; } out.println(compute2()); } out.flush(); out.close(); br.close(); } // 未压缩空间 public static long compute1() { long[][] dp = new long[MAXM][MAXT]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 0; j \u0026lt;= t; j++) { dp[i][j] = dp[i - 1][j]; if (j \u0026gt;= cost[i]) { dp[i][j] = Math.max(dp[i][j], dp[i][j - cost[i]] + value[i]); } } } return dp[m][t]; } // 空间压缩 public static long compute2() { Arrays.fill(dp, 1, t + 1, 0); for (int i = 1; i \u0026lt;= m; i++) { for (int j = cost[i]; j \u0026lt;= t; j++) { dp[j] = Math.max(dp[j], dp[j - cost[i]] + value[i]); } } return dp[t]; } } ","date":"2023-12-11T17:32:30+08:00","permalink":"https://zhuaowei.github.io/article/%E6%B4%9B%E8%B0%B7-p1616-%E7%96%AF%E7%8B%82%E7%9A%84%E9%87%87%E8%8D%AF/","title":"洛谷 P1616 疯狂的采药"},{"content":" LeetCode 2218. 从栈中取出 K 个硬币的最大面值和\nB站左程云：算法讲解074【必备】背包dp-分组背包、完全背包\n思路 将问题转化为分组背包 DP。每一堆硬币像栈一样取，只能从栈顶一个一个取，每一堆的方案有以下几种：选 0 个，得到 0 元；选 1 个 得到 x1 元；选 2 个，得到 x2 元 \u0026hellip;\n将每一堆硬币视为一组，从每组中选择一个方案，最终得到在硬币数不超过 k 的情况下获得的最大价值。\n求解过程 遍历每一个堆：\n1. 对每一个堆先求每一种方案的花费硬币个数和获得的钱数。\r2. 然后在剩余 0 -\u0026gt; m 个硬币的情况下，考虑每一种方案获得的钱数，最终求最大值。\r空间压缩\n每一个 dp[i][j] 依赖 dp[i - 1][0 -\u0026gt; j] 范围的值，如果不选的话 dp[i][j] = dp[i - 1][j]，如果只用一行来表示，dp[j] = dp[j]。因为 dp[j] 依赖上一行的 dp[j - 1]，所以在硬币数方面从后往前遍历。\n另：因为可能出现堆中硬币数大于剩余硬币数的情况，所以不用求和到底。\n复杂度 时间复杂度：$O(n \\times m)$ 空间复杂度：$O(m)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int maxValueOfCoins(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; piles, int m) { int n = piles.size(); int[] dp = new int[m + 1]; for (List\u0026lt;Integer\u0026gt; pile : piles) { // 求前缀和 for (int i = 1; i \u0026lt; Math.min(m, pile.size()); i++) { pile.set(i, pile.get(i) + pile.get(i - 1)); } // 计算 for (int j = m; j \u0026gt;= 0; j--) { for (int k = 0; k \u0026lt; Math.min(m, pile.size()); k++) { if (j \u0026gt;= k + 1) { dp[j] = Math.max(dp[j], dp[j - k - 1] + pile.get(k)); } } } } return dp[m]; } } ","date":"2023-12-11T17:29:33+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2218.-%E4%BB%8E%E6%A0%88%E4%B8%AD%E5%8F%96%E5%87%BA-k-%E4%B8%AA%E7%A1%AC%E5%B8%81%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E5%80%BC%E5%92%8C/","title":"LeetCode 2218. 从栈中取出 K 个硬币的最大面值和"},{"content":" 洛谷 P1757 通天之分组背包\nB站左程云：算法讲解074【必备】背包dp-分组背包、完全背包\n思路 分组背包的模板题，先按照组号排序，对组内每一个物品求在花费不超过 j 时获得的最大价值。\n求解过程 首先按照组号排序，确定组的左右边界，然后从左到右遍历每一组。在一组内：\n一个物品都不选：dp[group][j] = dp[group - 1][j] 依次遍历组内每一个物品：dp[group][j] = dp[group - 1][j - items[k][0]] + items[k][1] 在上述结果中求最大值。\n空间压缩\n跟 01 背包类似，每一组只依赖前一组 dp[group - 1][0 -\u0026gt; j] 的值，所以从右往左遍历。\n复杂度 时间复杂度：$O(n \\times m)$ n 为物品数量，m 为最大花费。虽然 DP 是按照组来的，但是物品还是都只被遍历了一遍。\n空间复杂度：$O(m)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import java.io.*; import java.util.Arrays; public class Main { public static int MAXN = 1001; public static int MAXK = 101; public static int[][] items = new int[MAXN][3]; public static int[] dp = new int[MAXN]; public static int n, m; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer in = new StreamTokenizer(br); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while (in.nextToken() != StreamTokenizer.TT_EOF) { m = (int)in.nval; in.nextToken(); n = (int)in.nval; for (int i = 1; i \u0026lt;= n; i++) { in.nextToken(); items[i][0] = (int)in.nval; in.nextToken(); items[i][1] = (int)in.nval; in.nextToken(); items[i][2] = (int)in.nval; } out.println(compute1()); } out.flush(); out.close(); br.close(); } public static int compute1() { int[][] dp = new int[MAXK][m + 1]; Arrays.sort(items, 1, n + 1, (item1, item2) -\u0026gt; item1[2] - item2[2]); int group = 0; for (int start = 1, end = 2; start \u0026lt;= n;) { while (end \u0026lt;= n \u0026amp;\u0026amp; items[start][2] == items[end][2]) { end++; } group++; for (int j = 0; j \u0026lt;= m; j++) { dp[group][j] = dp[group - 1][j]; for (int k = start; k \u0026lt; end; k++) { if (j \u0026gt;= items[k][0]) { dp[group][j] = Math.max(dp[group][j], dp[group - 1][j - items[k][0]] + items[k][1]); } } } start = end++; } return dp[group][m]; } public static int compute2() { Arrays.fill(dp, 1, m + 1, 0); Arrays.sort(items, 1, n + 1, (item1, item2) -\u0026gt; item1[2] - item2[2]); for (int start = 1, end = 2; start \u0026lt;= n; ) { while (end \u0026lt;= n \u0026amp;\u0026amp; items[start][2] == items[end][2]) { end++; } for (int j = m; j \u0026gt;= 0; j--) { for (int k = start; k \u0026lt; end; k++) { if (j \u0026gt;= items[k][0]) { dp[j] = Math.max(dp[j], dp[j - items[k][0]] + items[k][1]); } } } start = end++; } return dp[m]; } } ","date":"2023-12-11T17:27:37+08:00","permalink":"https://zhuaowei.github.io/article/%E6%B4%9B%E8%B0%B7-p1757-%E9%80%9A%E5%A4%A9%E4%B9%8B%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/","title":"洛谷 P1757 通天之分组背包"},{"content":" P1064 [NOIP2006 提高组] 金明的预算方案\n牛客网 购物单\n算法讲解073【必备】背包dp-01背包、有依赖的背包\n思路 物品分为主件和附件，附件必须在购买主件后才能考虑购买。所以在求解过程中，判断是否是主件，如果是，就考虑选或者不选。然后考虑主件下的附件，因为附件最多只有 2 件，分为以下四种情况，不买附件，只买附件一，只买附件二，都买，\n求解过程 使用数组分别记录下物品的价格、价值、是否是主件、附件的个数、有哪些附件。\n然后开始01背包DP，当前来到 i 位置，上一个是主件的位置是 last。\n如果当前不是主件，直接跳过。\n如果是主件，预算不够买主件，不买的结果。预算够买主件，买的结果，求最大值。\na. 不够买附件一，不买；够买附件一，买。求最大值。\nb. 不够买附件二，不买；够买附件二，买。求最大值。\nc. 不够买附件一和附件二，不买；够买附件一和附件二，买。求最大值。\n最后更新下上次遇到主件的下标。\n下面的代码是空间压缩后的版本。\n复杂度 时间复杂度：$O(N \\times M)$ N 为物品的数量，M 为购物的预算。\n空间复杂度：$O(M)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import java.io.*; import java.util.Arrays; public class Main { public static int MAX_N = 32001; public static int MAX_M = 61; public static int[] prices = new int[MAX_M]; // 价格 public static int[] values = new int[MAX_M]; // 重要度 public static boolean[] kings = new boolean[MAX_M]; // 是否是主件 public static int[] cnt = new int[MAX_M]; // 附件数量 public static int[][] follows = new int[MAX_M][2]; // 附件 public static int[] dp = new int[MAX_N]; public static int n, m; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer in = new StreamTokenizer(br); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while (in.nextToken() != StreamTokenizer.TT_EOF) { n = (int)in.nval; in.nextToken(); m = (int)in.nval; Arrays.fill(cnt, 0, m + 1, 0); for (int i = 1, q; i \u0026lt;= m; i++) { in.nextToken(); prices[i] = (int)in.nval; in.nextToken(); values[i] = (int)in.nval * prices[i]; in.nextToken(); q = (int)in.nval; kings[i] = q == 0; if (q != 0){ // 如果是附件，它的主件为 q，数量为 cnt[q]，将附件添加到主件后面 follows[q][cnt[q]++] = i; } } out.println(compute()); } out.flush(); out.close(); br.close(); } public static int compute() { Arrays.fill(dp, 0, n + 1, 0); // int last = 0; // 上一次计算主件的下标 for (int i = 1; i \u0026lt;= m; i++) { if (kings[i]) { // 只计算主件，在主件后面再视情况选择附件 for (int j = n; j \u0026gt;= prices[i]; j--) { // 买得起才考虑 dp[j] = Math.max(dp[j], dp[j - prices[i]] + values[i]); // 只考虑主件 // 下面考虑附件 // 如果有附件，且值考虑附件一 if (cnt[i] \u0026gt; 0 \u0026amp;\u0026amp; j - prices[i] - prices[follows[i][0]] \u0026gt;= 0) { dp[j] = Math.max(dp[j], dp[j - prices[i] - prices[follows[i][0]]] + values[i] + values[follows[i][0]]); } // 如果有两个附件，且只考虑附件二 if (cnt[i] \u0026gt; 1 \u0026amp;\u0026amp; j - prices[i] - prices[follows[i][1]] \u0026gt;= 0) { dp[j] = Math.max(dp[j], dp[j - prices[i] - prices[follows[i][1]]] + values[i] + values[follows[i][1]]); } // 如果有两个附件，两个都考虑 if (cnt[i] \u0026gt; 1 \u0026amp;\u0026amp; j - prices[i] - prices[follows[i][0]] - prices[follows[i][1]] \u0026gt;= 0) { dp[j] = Math.max( dp[j], dp[j - prices[i] - prices[follows[i][0]] - prices[follows[i][1]]] + values[i] + values[follows[i][0]] + values[follows[i][1]] ); } } } } return dp[n]; } } ","date":"2023-12-10T20:12:50+08:00","permalink":"https://zhuaowei.github.io/article/%E6%B4%9B%E8%B0%B7-p1064-noip2006-%E6%8F%90%E9%AB%98%E7%BB%84-%E9%87%91%E6%98%8E%E7%9A%84%E9%A2%84%E7%AE%97%E6%96%B9%E6%A1%88/","title":"洛谷 P1064 [NOIP2006 提高组] 金明的预算方案"},{"content":" LeetCode 1049. 最后一块石头的重量 II\n算法讲解073【必备】背包dp-01背包、有依赖的背包\n思路 两块石头碰撞会相互抵消，最终留下较大的减去较小的那块。\n如果将一组石头分成两组，分别捏成两个大石头，则抵消后的结果为较大的减去较小的那块。如果要让结果尽量小，则需要让两堆石头的重量尽量接近，甚至相等。\n求解过程 先求出一组石头的总重量 sum，取中间值 $\\frac{sum}{2}$，让其中一堆石头的重量尽量接近 $\\frac{sum}{2}$，求出这一堆石头的重量后，另外一堆的重量也就知道了，最终抵消的结果也就得出来了。\n求在数组中，石头重量 $\\le \\frac{sum}{2}$ 的最大重量，花费和价值相同的01背包问题，假设结果为 w1，那么 w2 = sum - w1，推出 w1 \u0026lt;= w2，最终抵消的结果为 sum - w1 - w1。\n复杂度 时间复杂度：$O(N \\times M)$ N 为石头数量，M 为 $\\frac{\\sum_{i=1}^{n}nums}{2}$\n空间复杂度：$O(M)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int lastStoneWeightII(int[] stones) { int n = stones.length, sum = 0; for (int stone : stones) { sum += stone; } int m = sum / 2; int[] dp = new int[m + 1]; for (int stone : stones) { for (int j = m; j \u0026gt;= stone; j--) { dp[j] = Math.max(dp[j], dp[j - stone] + stone); } } return sum - dp[m] - dp[m]; } } ","date":"2023-12-10T19:26:20+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-1049.-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-ii/","title":"LeetCode 1049. 最后一块石头的重量 II"},{"content":" LeetCode 494. 目标和\n算法讲解073【必备】背包dp-01背包、有依赖的背包\n思路 思考一：奇偶性，数组中的数，无论如何组合，它的奇偶性是不变的，也就是说 $\\sum_{i=1}^{n}nums$ 和任意一种组合的结果的奇偶性是一样的，推出 $\\sum_{i=1}^{n}nums$ 和 target 的奇偶性是一样的，如果不一样可以直接 pass。\n思考二：每一个数字只有 '+' / '-' 可以选择，而且必须选择，如果全是 '+' 或者全是 '-'，结果分别为 sum 和 -sum，target 应该在这个范围内，如果不在，直接 pass。\n思考三：数组中的数字只有两种可以选，要么是正，要么是负，这就将数组中的数分成了两类，一类是 '+'，一类是 '-'，结果分别为 sumA 和 sumB (都取正数)。\n假设 $sumA - sumB = target 且 sum = sumA + sumB$。\n同时加上 sum : $sumA + sumB + sumA - sumB = target + sum$\n推出 : $sumA = \\frac{target + sum}{2}$\n由于 target 和 sum 奇偶性相同，和除以2一定可以整除。\n接下来就是求在 nums 数组中找一些子序列，使他们的和等于 $\\frac{target + sum}{2}$ 的个数。\n求解过程 首先，求出 nums 数组的和，根据思考一和思考二进行剪枝。\n然后求出子序列之和等于 $\\frac{target + sum}{2}$ 的个数。\n当前来到 (i,j) 位置，如果不选择 i 位置的数字，cnt1 = dp[i - 1][j]，如果选择 i 位置的数字，cnt2 = dp[i - 1][j - nums[i]]，求总和。\n复杂度 时间复杂度：$O(N \\times M)$ N 为数字个数，M 为 $\\frac{(target + \\sum_{i=1}^{n}nums)}{2}$\n空间复杂度：$O(M)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public static int MAX_N = 21; public static int MAX_SUM = 2005; public static int[] dp = new int[MAX_SUM]; public int findTargetSumWays(int[] nums, int target) { int sum = 0; for (int num : nums) { sum += num; } if (sum \u0026lt; target || ((sum \u0026amp; 1) ^ (target \u0026amp; 1)) == 1) { return 0; } int m = (sum + target) / 2; if (m \u0026lt; 0) { return 0; } Arrays.fill(dp, 0, m + 1, 0); dp[0] = 1; for (int num : nums) { for (int j = m; j \u0026gt;= num; j--) { dp[j] += dp[j - num]; } } return dp[m]; } } ","date":"2023-12-10T19:10:35+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-494.-%E7%9B%AE%E6%A0%87%E5%92%8C/","title":"LeetCode 494. 目标和"},{"content":" LeetCode ByteDance-006. 夏季特惠\n算法讲解073【必备】背包dp-01背包、有依赖的背包\n思路 需要分析题意，将问题转化为 01 背包问题。这题背包的容量不是确定的预算，需要根据优惠决定。\n游戏有原价和现价，优惠等于原价减现价。优惠越大，心理越不觉得亏，当优惠比现价还大时，觉得自己赚了，那么这个游戏就是必选的，赚得多余的还可以用于购买其他游戏。例如原价 10，现价 3，优惠 7，优惠等于现价，四舍五入等于白嫖，还赚 4 块。\n所以对于每个游戏，求出自己“赚多少”，如果赚的为正数或者0，则游戏必选；如果赚的为负数，待定，等全部看一遍后，在从待定里选择比较赚的。\n求解过程 首先，求出每个游戏自己可以“赚多少”，如果赚了，游戏选上；如果每赚，添加到待定。\n所有的游戏都遍历一遍后，从待定的游戏中，选择快乐值最高的游戏。此时，因为优惠，自己的预算可能已经被拔高了，最终的预算等于原来的预算 + “自己赚的”。\n复杂度 时间复杂度：$O(N \\times M)$ N 为游戏数量，M 为最终被拔高后的预算\n空间复杂度：$O(M)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import java.io.*; import java.util.Arrays; public class Main { public static int MAXN = 505; // 预算可能被拔高，不是题目上说的 1w public static int MAXX = 100005; public static int[] costs = new int[MAXN]; public static long[] values = new long[MAXN]; public static long[] dp = new long[MAXX]; public static int n, m, x; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer in = new StreamTokenizer(br); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while (in.nextToken() != StreamTokenizer.TT_EOF) { n = (int)in.nval; in.nextToken(); m = 1; x = (int)in.nval; long ans = 0, happy = 0; for (int i = 0, prev, cur, well; i \u0026lt; n; i++) { in.nextToken(); prev = (int)in.nval; in.nextToken(); cur = (int)in.nval; in.nextToken(); happy = (long)in.nval; well = prev - cur - cur; if (well \u0026gt;= 0) { // 优惠比折后更多，约等于白嫖，自己还能赚点 x += well; // 预算被拔高 ans += happy; // 快乐值累加 } else { // 待定 costs[m] = -well; values[m++] = happy; } } ans += compute(); out.println(ans); } out.flush(); out.close(); br.close(); } // 01 背包 public static long compute() { Arrays.fill(dp, 0, x + 1, 0); for (int i = 1; i \u0026lt;= m; i++) { for (int j = x; j \u0026gt;= costs[i]; j--) { dp[j] = Math.max(dp[j], dp[j - costs[i]] + values[i]); } } return dp[x]; } } ","date":"2023-12-10T17:00:24+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-bytedance-006.-%E5%A4%8F%E5%AD%A3%E7%89%B9%E6%83%A0/","title":"LeetCode ByteDance-006. 夏季特惠"},{"content":" ACWing 01背包问题\n算法讲解073【必备】背包dp-01背包、有依赖的背包\n思路 考虑每一件物品，当前来到了第 i 件物品，背包容量为 j。如果选了第 i 件物品，获得的价值是 $w_i$，如果要装下该物品，则背包需要预留给这件物品足够的空间，也就是背包在选择前 i - 1 件物品后，背包容量最大应该为 $j - v_i$。\n如果不选，则不需要预留空间，背包的价值和选择前 i - 1 件物品时是一样的。\n所以我们可以得到一个状态转移方程：\n$$f(i,j) = max \\begin{cases} f(i-1,j) \u0026amp; 不选\\\\ f(i-1,j-v_i) + w_i \u0026amp; j-v_i \\ge 0，选 \\end{cases} $$\n求解过程 遍历每一个物品，计算背包容量从 0 到 v 的最大值，所以有两层循环。\n空间压缩\n当我们遍历到第 i 件物品时，根据转移方程，它只依赖前一个物品的背包容量 \u0026lt;= j 的结果。在二维表中的表现就是 dp[i][j] 只依赖第 i - 1 行小于等于 j 的值，如果使用一维表的话，只使用一行。如果不选，第 i 行的 dp[j] 就等于第 i - 1 行的 dp[j]，所以不用改；如果选的话，第 i 行的 dp[j] = 第 i - 1 行的 dp[j - vi] + wi，由于后面依赖前面，不能从左往右填，要从右往左填。j 左边的是第 i - 1 行的，右边是第 i 行的。\n复杂度 时间复杂度：$O(N \\times M)$ N 为物品数量，M 为背包容量。就是将 N * M 的表格填好，返回右下角的值。\n空间复杂度：$O(M)$ 压缩空间后的空间只需要一行即可，为背包容量大小。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import java.io.*; import java.util.Arrays; public class Main { public static int MAXN = 1005; public static int[] values = new int[MAXN]; public static int[] volumes = new int[MAXN]; public static int[] dp = new int[MAXN]; public static int n, v; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer in = new StreamTokenizer(br); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while (in.nextToken() != StreamTokenizer.TT_EOF) { n = (int)in.nval; in.nextToken(); v = (int)in.nval; for (int i = 0; i \u0026lt; n; i++) { in.nextToken(); volumes[i] = (int)in.nval; in.nextToken(); values[i] = (int)in.nval; } out.println(compute()); } out.flush(); out.close(); br.close(); } public static int compute() { Arrays.fill(dp, 0, v + 1, 0); // 01 背包模板 for (int i = 0; i \u0026lt; n; i++) { for (int j = v; j \u0026gt;= volumes[i]; j--) { dp[j] = Math.max(dp[j], dp[j - volumes[i]] + values[i]); } } return dp[v]; } } ","date":"2023-12-10T11:59:20+08:00","permalink":"https://zhuaowei.github.io/article/acwing-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","title":"ACWing 01背包问题"},{"content":" LeetCode 70. 爬楼梯\n思路 爬一个长度为 n 的阶梯，可能从 n - 1 阶跳一步来到 n，也可以从 n - 2 一下跳两步来到 n。所以来到第 i 个台阶的方法数就等于：\n$$ f(i) = f(i - 1) + f(i - 2) $$\n求解过程 可以使用递归的方式，basecase 为 i == 1 || i == 2。\n递归的方式会有很多重复调用过程，所以使用一个 dp 表记录下调用的结果，如果结果存在直接返回，如果不存在，再展开。这种方式等价与使用一维 DP 表。\n如果直接动态规划，发现 dp[i] 只依赖前两项 dp[i - 1] + dp[i - 2]，所以可以使用滚动数组的方式，记录前两项的值，然后更新当前项，再更新前两项，进入下一次循环。\n复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int climbStairs(int n) { if (n \u0026lt; 3) { return n; } int prev = 1, cur = 2, next; for (int i = 3; i \u0026lt;= n; i++) { next = prev + cur; prev = cur; cur = next; } return cur; } } ","date":"2023-12-10T09:34:09+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-70.-%E7%88%AC%E6%A5%BC%E6%A2%AF/","title":"LeetCode 70. 爬楼梯"},{"content":" 洛谷 P2698 [USACO12MAR] Flowerpot S\n思路 思路主要来自B站左程云的视频课程 算法讲解054【必备】单调队列-上\n求花盆的长度，满足下面的条件，在花盆区间内，第一滴雨水与最后一滴雨水落下的时间差要 \u0026gt;= d。雨水下落速度恒定 1 单位每秒，也就是求最大高度差满足 \u0026gt;= d。\n使用单调队列，维护区间的最大值和最小值，如果满足条件就记录下答案，在所有答案中取最小值。\n单调性分析：对于当前维护的区间：区间右扩，最大值可能会变得更大，最小值可能会变得更小，导致结果更符合要求；区间左边界缩小，最大值可能会变小，最小值可能会变大，导致越来越不符合要求。说明对于单调区间存在单调性，可以使用单调队列解决。\n如何维护区间大小？必须使用数据来维护单调区间的左缩和右扩，时间差 d 就可以作为单调区间变化的条件，如果最大值最小值的差值不满足条件就可以右扩，如果差值满足条件了就可以停止了。如果是因为符合要求而停止的循环，更新结果，然后左边界右移，更新单调区间。\n求解过程 因为雨水的顺序是乱序的，先进行排序，然后开始遍历，使用单调栈维护区间的最大值和最小值。\n先判断当前区间是否符合要求，如果不符合要求，右边界向右扩充，一直扩充到符合要求（前提是没有到数组边界）。然后判断是否符合要求，如果符合就记录下答案。最后左边界缩小，更新单调区间的最大值和最小值。\n如果一直遍历完整个数组都没有符合要求的花盆，返回 -1。\n复杂度 时间复杂度：$O(n \\times log_2n)$ 排序的时间复杂度是 $O(n \\times log_2n)$，单调队列求解的过程是 $O(n)$ 的，每个数字最多入队一次，出队一次。最终的时间复杂度就是 $O(n \\times log_2n)$。\n空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import java.io.*; import java.util.Arrays; public class Main { // 最多有 N 滴水 public static int MAXN = 100005; public static int[][] water = new int[MAXN][2]; public static int[] maxDeque = new int[MAXN]; public static int[] minDeque = new int[MAXN]; public static int maxHead, maxTail, minHead, minTail; public static int n, d; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer in = new StreamTokenizer(br); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while (in.nextToken() != StreamTokenizer.TT_EOF) { n = (int)in.nval; in.nextToken(); d = (int)in.nval; for (int i = 0; i \u0026lt; n; i++) { in.nextToken(); water[i][0] = (int)in.nval; in.nextToken(); water[i][1] = (int)in.nval; } out.println(compute()); } out.flush(); out.close(); br.close(); } public static int compute() { Arrays.sort(water, 0, n, (w1, w2) -\u0026gt; w1[0] - w2[0]); maxHead = maxTail = minHead = minTail = 0; int ans = Integer.MAX_VALUE; for (int l = 0, r = 0; l \u0026lt; n; l++) { // 不满足条件就一直往右扩 while (!satisfy() \u0026amp;\u0026amp; r \u0026lt; n) { while (maxHead \u0026lt; maxTail \u0026amp;\u0026amp; water[maxDeque[maxTail - 1]][1] \u0026lt;= water[r][1]) { maxTail--; } maxDeque[maxTail++] = r; while (minHead \u0026lt; minTail \u0026amp;\u0026amp; water[minDeque[minTail - 1]][1] \u0026gt;= water[r][1]) { minTail--; } minDeque[minTail++] = r; r++; } // 如果是因为 满足条件跳出来的，更新结果 if (satisfy()) { ans = Math.min(ans, water[r - 1][0] - water[l][0]); } // 从队头出队 if (maxHead \u0026lt; maxTail \u0026amp;\u0026amp; l == maxDeque[maxHead]) { maxHead++; } if (minHead \u0026lt; minTail \u0026amp;\u0026amp; l == minDeque[minHead]) { minHead++; } } return ans == Integer.MAX_VALUE ? -1 : ans; } public static boolean satisfy() { int max = maxHead \u0026lt; maxTail ? water[maxDeque[maxHead]][1] : 0; int min = minHead \u0026lt; minTail ? water[minDeque[minHead]][1] : 0; return max - min \u0026gt;= d; } } ","date":"2023-12-09T21:34:27+08:00","permalink":"https://zhuaowei.github.io/article/%E6%B4%9B%E8%B0%B7-p2698-usaco12mar-flowerpot-s/","title":"洛谷 P2698 [USACO12MAR] Flowerpot S"},{"content":" 洛谷 P8776 [蓝桥杯 2022 省 A] 最长不下降子序列\n思路 思路来自 B站左程云的视频课程，在文章末尾可以直接转到左程云的B站个人空间。\n求最长非降序子序列，在此基础上，给你一个机会，使长度为 k 的数组全部变成同一个数字，机会可以用，也可以不用，求此时的最长非降序子序列。\n首先，使用这个机会可能会使结果变大，但是肯定不会使结果变小，所以选择使用这个机会。\n然后是使用这个机会的时机，假如现在 i..(k)..j 可以形成非降序子序列，把 k 向后移动，使它紧贴在 j 的前面 i....(k)j，最终结果并不会改变，但是这样更容易分析了。我们需要求的是 k 之前的最长递增子序列，这些序列的结尾需要 \u0026lt;= j，还有 j 及之后的数组中，以 j 为开头的非降序子序列。最终结果就是 左侧的长度 + k + 右侧的长度。\n求解过程 明确了要求什么，现在来看如何求。左侧的非降序子序列跟正常求非降序子序列一样。\n右侧需要反向求，以 j 为开头的非降序子序列 等价与 从后往前的以 j 为结尾的非升序子序列，逆序求非升序子序列，跟左侧的非降序子序列差不多。因为右侧的数组长度不断变小，不好求，先求出每个 j 的以 j 为开头的非降序子序列长度，使用数组存储起来，使用的时候根据 j 直接取就可以了。\n求出右侧的每个位置的长度之后，开始从头遍历，依次求出将 j 的前 k 个数变成 j 的最长非降序子序列长度，取最大值。\n特殊情况\n最后 k 个元素，变成数组中的最大值，因为右侧没有了 j ，他们可以变成任意大的数。此时最长非降序子序列就是前 n - k 长度的数组的最长非降序子序列加上 k。\n复杂度 时间复杂度：$O(n \\times log_2n)$\n空间复杂度：$O(n)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 import java.io.*; public class Main { public static int MAXN = 100005; public static int[] nums = new int[MAXN]; public static int[] end = new int[MAXN]; public static int[] right = new int[MAXN]; public static int n; public static int k; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StreamTokenizer in = new StreamTokenizer(br); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); while (in.nextToken() != StreamTokenizer.TT_EOF) { n = (int)in.nval; in.nextToken(); k = (int)in.nval; for (int i = 0; i \u0026lt; n; i++) { in.nextToken(); nums[i] = (int)in.nval; } if (k \u0026gt;= n) { out.println(n); } else { out.println(compute()); } } out.flush(); out.close(); br.close(); } public static int compute() { // 先计算出每一个位置开头，后续的最长非递减子序列的最长长度 generateRight(); int len = 0, ans = 0; for (int i = 0, j = k, index, L, R; j \u0026lt; n; i++, j++) { // 让 [i, j - 1] 这一段全部变成 nums[j] // 左侧 [0, i - 1] 找到找到 \u0026lt;= nums[j] 的最长非降序子序列 // 右侧 [j, n - 1] 找到以 nums[j] 为开头的最长非降序子序列 // 现将左侧数组计算出 end 数组 index = findInLeftEnd(end, len, nums[j]); L = index == -1 ? len : index; // 左侧的最长非降序子序列（以 nums[j]） 结尾 R = right[j]; ans = Math.max(ans, L + k + R); // 更新 左侧 end 数组。因为下一次左侧边界要右移了 index = findInLeftEnd(end, len, nums[i]); if (index == -1) { end[len++] = nums[i]; } else { end[index] = nums[i]; } } // 右侧没有了 j ，他们可以变成任意大的数 ans = Math.max(ans, len + k); return ans; } // 在左侧 end 数组中找到 \u0026gt; target 的最长非递减子序列的长度 public static int findInLeftEnd(int[] end, int len, int target) { int left = 0, right = len - 1, mid, ans = -1; while (left \u0026lt;= right) { mid = left + (right - left) / 2; if (end[mid] \u0026gt; target) { ans = mid; right = mid - 1; } else { left = mid + 1; } } return ans; } // 在右侧 end 数组中找到 \u0026lt; nums[j] 的最长非递增子序列的长度 public static int findInRightEnd(int[] end, int len, int target) { int left = 0, right = len - 1, mid, ans = -1; while (left \u0026lt;= right) { mid = left + (right - left) / 2; if (end[mid] \u0026lt; target) { ans = mid; right = mid - 1; } else { left = mid + 1; } } return ans; } // 从 nums 数组右往左生成 非递增子序列，求 每一个 j 位置的最长子序列长度 public static void generateRight() { int len = 0; for (int i = n - 1, index; i \u0026gt;= 0; i--) { index = findInRightEnd(end, len, nums[i]); if (index == -1) { end[len++] = nums[i]; right[i] = len; } else { end[index] = nums[i]; right[i] = index + 1; } } } } ","date":"2023-12-09T16:58:10+08:00","permalink":"https://zhuaowei.github.io/article/%E6%B4%9B%E8%B0%B7-p8776-%E8%93%9D%E6%A1%A5%E6%9D%AF-2022-%E7%9C%81-a-%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97/","title":"洛谷 P8776 [蓝桥杯 2022 省 A] 最长不下降子序列"},{"content":" LeetCode 646. 最长数对链\n思路 思路来自 B站左程云的视频课程，在文章末尾可以直接转到左程云的B站个人空间。\n使用最长递增子序列来求解。两个数对 $nums_i, nums_j (i \u0026lt; j)$ 要形成数对，需要 $right_i \u0026lt; left_j$，当来到 j 的时候，我们根据 $left_j$ 找到最长的递增数对即可。\n求解过程 当来到 j 时，需要根据 $left_j$ 寻找，找到的数对它的 right 最大不能超过 $left_j$。我们使用 end 数组存储长度为 i + 1 的最长递增链的最小结尾。\n每次我们找到 $\\ge left_j$ 的最左侧位置。它有以下几种情况：\n$right_i \\ge left_j$ : 说明 $[left_j, right_j]$ 与 $[left_i, right_i]$ 有交集，无法直接添加到 i 后面，但是可以添加到 i - 1 后面，就是替代 i，i 和 j 结尾要取最小值，更新 i 位置的为最小结尾。 没有找到 $\\ge left_j$ 的位置: 也就是说 end 数组中存储的长度为 len 的数对结尾都小于 $left_j$ , j 位置的数对可以直接接到后面，使最长数对 +1。 复杂度 时间复杂度：$O(n \\times log_2n)$\n空间复杂度：$O(n)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public int findLongestChain(int[][] pairs) { // 按照开头进行排序 Arrays.sort(pairs, (p1, p2) -\u0026gt; p1[0] - p2[0]); int n = pairs.length; // end 数组存储的是长度为 i + 1 的最长递增子序列的最小结尾 使用 right 作为结尾 int[] end = new int[n]; int len = 0; for (int i = 0, index; i \u0026lt; n; i++) { index = find(end, len, pairs[i][0]); if (index == -1) { end[len++] = pairs[i][1]; } else { end[index] = Math.min(end[index], pairs[i][1]); } } return len; } public int find(int[] end, int len, int target) { int left = 0, right = len - 1, mid, ans = -1; while (left \u0026lt;= right) { mid = left + (right - left) / 2; if (end[mid] \u0026gt;= target) { ans = mid; right = mid - 1; } else { left = mid + 1; } } return ans; } } ","date":"2023-12-09T16:32:55+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-646.-%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/","title":"LeetCode 646. 最长数对链"},{"content":" 2111. 使数组 K 递增的最少操作次数\n思路 思路来自 B站左程云的视频课程，在文章末尾可以直接转到左程云的B站个人空间。\n根据题意需要将原数组进行分组，一共分为 k 个组，求将每一组变成非降序子序列的最少操作数。那就求每一组的最长非降序子序列的长度，剩余的就是需要修改的数字个数。\n求解过程 end 数组申请的空间为 (n + k - 1) / k 即可，每组数字的最大个数。\n首先使用两层 for 循环，第一层为 k 个组，，第二层为遍历每一组的数字。\n求出每一组的最长非降序子序列后，将每一组的最长长度加起来，使用原数组长度减去总和就是最少操作数。\n详细的求解最长递增子序列以及最长非递减子序列：LeetCode 300. 最长递增子序列\n复杂度 时间复杂度：$O(n \\times log_2n)$\n空间复杂度：$O(n)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public int kIncreasing(int[] arr, int k) { // 将 原数组进行分组，分成 k 组， // 分别求非降序子序列的最长长度，而那些降序的数字就是需要修改的。 // 由于是非降序，不符合要求的数字修改为前一个或后一个非降序数字即可，操作次数 +1 int n = arr.length, len; int[] end = new int[(n + k - 1) / k]; int ans = 0; for (int i = 0; i \u0026lt; k; i++) { len = 1; // Arrays.fill(end, 0); // 不需要全置为 0，只在 [0, len) 范围搜索。 end[0] = arr[i]; for (int j = i + k, index; j \u0026lt; n; j += k) { index = find(end, len, arr[j]); if (index == -1) { end[len++] = arr[j]; } else { end[index] = arr[j]; } } // 结算 ans += len; } return n - ans; } public int find(int[] end, int len, int target) { int left = 0, right = len - 1, mid, ans = -1; while (left \u0026lt;= right) { mid = left + (right - left) / 2; if (end[mid] \u0026gt; target) { ans = mid; right = mid - 1; } else { left = mid + 1; } } return ans; } } ","date":"2023-12-09T10:46:28+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2111.-%E4%BD%BF%E6%95%B0%E7%BB%84-k-%E9%80%92%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","title":"LeetCode 2111. 使数组 K 递增的最少操作次数"},{"content":" 2048. 下一个更大的数值平衡数\n思路 根据题意求平衡数，由于对结果数字和位数进行了限制，所以能形成平衡数的数字并不是特别多，可以使用打表的方式，将可能的结果存储到一个数组中，再通过二分加速查找。\n我使用的方式是暴力求解。根据题意，n 的范围是 $0 \u0026lt;= n \u0026lt;= 10^6$，那么结果最大就是 7 位数 1224444。长度为 \u0026lt;= 7 的平衡数最多由 3 种数字组成，而它们的和不会超过 7。所以我们可以枚举每一种数字出现的可能，通过这些数字组成一个平衡树，判断是否符合要求，在符合要求的平衡数中取最小值。\n求解过程 最多有三种数字，每种数字最大为 7，所以使用 3 层 for 循环，枚举每一种数字的可能性。数字为 0 代表它不参与平衡数的组成。\n然后写一个递归函数，对每一种可能性的数字组合组成平衡数，将得到的平衡数取 \u0026gt;n 的最小值。\n剪枝\n并不是所有数字组合都可以组成平衡数，数字之间有一定的关联关系：\n三数之和不能超过 7。三数之和也就是平衡数的位数，结果最大为 7 位数。 任意两个不为 0 数字不能相等。数字为 0 不参与平衡数组成，不为 0 说明参与组成，如果两个数字相等，则组成的数中该数字个数不为其自身，也就不是平衡数。 由于三种数字是等价的，不同的组合也会得到同样的结果。例如 (2, 0, 0) (0, 2, 0) 等，会重复计算，由于太复杂了，就不进行判断了。 通过上面的分析，最终使用下面的判断语句实现剪枝。\n复杂度 时间复杂度：$O(N \\times M)$ N 为循环次数，最多循环 $7 \\times 7 \\times 7$ 次。M 为每次循环中递归调用次数，最多 $3 \\times 4$ 次。\n空间复杂度：$O(1)$ 实际跑下来只比打表慢一点。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class Solution { int ans = Integer.MAX_VALUE; public int nextBeautifulNumber(int n) { // 结果最多七位数 for (int i = 0; i \u0026lt;= 7; i++) { for (int j = 0; j \u0026lt;= 7; j++) { for (int k = 0; k \u0026lt;= 7; k++) { if (i + j + k \u0026lt;= 7) { if (i == 0 \u0026amp;\u0026amp; j != k) { dfs(i, j, k, i, j, k, 0, n); continue; } if (j == 0 \u0026amp;\u0026amp; i != k) { dfs(i, j, k, i, j, k, 0, n); continue; } if (k == 0 \u0026amp;\u0026amp; i != j) { dfs(i, j, k, i, j, k, 0, n); continue; } if (i != j \u0026amp;\u0026amp; j != k \u0026amp;\u0026amp; i != k) { dfs(i, j, k, i, j, k, 0, n); } } else { break; } } } } return ans; } // 在使用 cn1 个 n1 ，cn2 个 n2，cn3 个 n3 时，组成的 num 能否 \u0026gt; target public void dfs(int n1, int n2, int n3, int cn1, int cn2, int cn3, int num, int target) { if (cn1 == 0 \u0026amp;\u0026amp; cn2 == 0 \u0026amp;\u0026amp; cn3 == 0) { if (num \u0026gt; target) { ans = Math.min(ans, num); } return; } // 先选 n1 if (cn1 \u0026gt; 0) { dfs(n1, n2, n3, cn1 - 1, cn2, cn3, num * 10 + n1, target); } // 先选 n2 if (cn2 \u0026gt; 0) { dfs(n1, n2, n3, cn1, cn2 - 1, cn3, num * 10 + n2, target); } // 先选 n3 if (cn3 \u0026gt; 0) { dfs(n1, n2, n3, cn1, cn2, cn3 - 1, num * 10 + n3, target); } } } ","date":"2023-12-09T09:50:59+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2048.-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E6%95%B0%E5%80%BC%E5%B9%B3%E8%A1%A1%E6%95%B0/","title":"LeetCode 2048. 下一个更大的数值平衡数"},{"content":" 354. 俄罗斯套娃信封问题\n思路 思路来自 B站左程云的视频课程，在文章末尾可以直接转到左程云的B站个人空间。\n信封不能翻转，首先想到排序，在宽度上较大的信封肯定能装下宽度较小的信封，在宽度相同的情况下，应该尽量先装下高度较大的。所以在宽度上，从小到大排序。因为相同宽和高的信封并不能装下，只能装下宽和高比自己小的。所以在宽度相同时，需要将高度按从大到小排序。这样，同样宽度，高度小的就会自动略过前面比自己高的。\n这样就转化成求排序后的高度最长递增子序列问题了。\n求解过程 对信封进行排序，宽度从小到大。宽度相同时，高度从高到低。\n此时，宽度相同时，因为前面高度较高，自动略过。前面宽度比 i 位置小时，找到 h[i] 能装下的最多信封个数，这些信封高度应该是递增的。也即求解高度的最长递增子序列。\n复杂度 时间复杂度：$O(n \\times log_2n)$\n空间复杂度：$O(n)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public int maxEnvelopes(int[][] envelopes) { int n = envelopes.length; Arrays.sort(envelopes, 0, n, (en1, en2) -\u0026gt; { if (en1[0] == en2[0]) { return en2[1] - en1[1]; } else { return en1[0] - en2[0]; } }); int[] end = new int[n]; // 第 0 个位置肯定只能形成长度为 1 的递增子序列 end[0] = envelopes[0][1]; int len = 1; for (int i = 1, index, num; i \u0026lt; n; i++) { num = envelopes[i][1]; index = find(end, len, num); if (index == -1) { end[len++] = num; } else { end[index] = num; } } return len; } // 找到 \u0026gt;= target 的最左侧索引 public int find(int[] end, int len, int target) { int left = 0, right = len - 1, mid; int ans = -1; while (left \u0026lt;= right) { mid = left + (right - left) / 2; if (end[mid] \u0026gt;= target) { ans = mid; right = mid - 1; } else { left = mid + 1; } } return ans; } } ","date":"2023-12-08T22:00:14+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-354.-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/","title":"LeetCode 354. 俄罗斯套娃信封问题"},{"content":" 300. 最长递增子序列\n思路 思路来自 B站左程云的视频课程，在文章末尾可以直接转到左程云的B站个人空间。\n有两种方法，第一种是暴力解法，第二种是二分。\n暴力解法：使用一个数组存储以 i 位置数字为结尾的最长升序子序列长度。每来到 i 位置，它的最长递增子序列至少是 1，就是自己，然后遍历 i 之前的所有结果，如果发现某位置 j 比 i 位置小，则递增子序列长度为 1 + dp[j]，在所有结果中求最大值。每次得到 dp[i] 后，比较记录最大值。\n二分：使用一个 end 数组，end 数组存储的是目前长度为 i + 1 的递增子序列的最小结尾。\n求解过程 这里只说二分解法。光从字面意思很难理解 end 数组的含义，举个例子：\n假如当前来到了数组 i 位置，在 end 数组中寻找 \u0026gt;= nums[i] 的最左侧索引：\n如果找到了位置 j，则说明 j 以及之前所有数字可以和 nums[i] 形成以 i 位置为结尾的最长递增子序列。然后更新 end[j] 位置为 nums[i]. 如果没有找到，说明 nums[i] 是 end 数组中最大的数，它可以把 end 数组往右扩，此时 j 为 end 数组的有效长度，end[j] = nums[i]，最长递增子序列为 j + 1。 end 数组总是保持递增的，上面两种情况的情况 1，end[j] \u0026gt;= nums[i]，使用 nums[i] 替换了 end[j]，end[j] 只会变得更小。而且后续 end[j] 变得再小也不会小于等于前一个数 end[j - 1]，因为如果后续 nums[k] \u0026lt;= end[j - 1]，那么它在 end 数组中找到的 \u0026gt;= nums[k] 的索引就一定不会是 j，而是小于 j 。\n情况 2 找不到 \u0026gt;= nums[i] 的位置，所以直接在 end 数组右侧添加一个 nums[i]，所以 end 数组中总是保持递增的。\n为什么找到了 \u0026gt;= nums[i] 在 end 数组中的位置就确定了 [0, i] 数组的最长递增子序列了呢？\n通过上面的分析可以得知，end 数组中的所有值 nums[j] 都会在 ( nums[j - 1], nums[j] ] 值之间，不会增大，只会减小。当 nums[i] 在 end 数组中找到位置后，那么它在数组中的最长递增子序列就确定了。因为在 i 之前比 i 小的数字已经在 end 数组中了，即使它后来可能被改变了，但是它会占一个位置，而这个位置是不会消失的。\n回过头来再看 end 数组的定义，end 数组中每个数字都只会变小，变小后的值就是当前数组的长度为 j + 1 的递增子序列的最小结尾。\nend : 目前长度为 i + 1 的递增子序列的最小结尾\n知道了 end 数组是递增的，就可以使用二分法求出 \u0026gt;= nums[i] 的索引。\n复杂度 时间复杂度：$O(n \\times log_2n)$\n空间复杂度：$O(n)$\n扩展 如果是非降序序列，很简单，在寻找 \u0026gt;= nums[i] 时修改为 \u0026gt; nums[i] 即可。这样 end 数组中就可以存储非降序的序列，结果也就是非降序的了。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public int lengthOfLIS(int[] nums) { int n = nums.length; int[] end = new int[n]; // 第 0 个位置肯定只能形成长度为 1 的递增子序列 end[0] = nums[0]; int len = 1; for (int i = 1; i \u0026lt; n; i++) { int index = find(end, len, nums[i]); if (index == -1) { end[len++] = nums[i]; } else { end[index] = nums[i]; } } return len; } // 找到 \u0026gt;= target 的最左侧索引 public int find(int[] end, int len, int target) { int left = 0, right = len - 1, mid; int ans = -1; while (left \u0026lt;= right) { mid = left + (right - left) / 2; if (end[mid] \u0026gt;= target) { ans = mid; right = mid - 1; } else { left = mid + 1; } } return ans; } } ","date":"2023-12-08T15:01:44+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-300.-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/","title":"LeetCode 300. 最长递增子序列"},{"content":" 2008. 出租车的最大盈利\n思路 司机在行驶过程中，只能往右走，路程中依次经过 1 -\u0026gt; n，求司机的最大盈利。首先想到动态规划，求解司机在到达 i 点时获得的最大盈利。\n司机在行驶中一共有两种状态，一是载客，二是不载客。如果是不载客到达 i 点，那么它的最大盈利等于到达 i - 1 时的最大盈利；如果他是载客状态到达了 i 点，那么它的盈利为 终点为 i 的订单获得的盈利加上到达终点为 i 的订单的起点获得的盈利。然后需要将二者进行比较，求较大值。\n在计算载客状态时，可能会有多个订单的终点在 i 位置，需要一一计算，然后取最大值。\n求解过程 首先需要将所有订单按照终点进行排序。\n然后开始从 1 -\u0026gt; n 进行遍历，计算出不载客的时候，到达 i 位置的最大收益，然后判断是否有到达 i 节点的订单，如果有，计算收益，取最大值。\n因为司机是不会回退的，订单终点排好序了，也是不回退的，所以只需要记录订单终点为 i 的订单索引，不必每次进行搜索。\n复杂度 时间复杂度：$O(n + m)$ n 为地点个数，m 为订单个数。虽然有两层循环，但是 n 和 m 只遍历一遍，最多 n + m.\n空间复杂度：$O(n)$ 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public static int MAXN = 100005; public static long[] dp = new long[MAXN]; public long maxTaxiEarnings(int n, int[][] rides) { // 排序 + 动态规划 Arrays.fill(dp, 0, n, 0); // 按照终点进行排序 Arrays.sort(rides, 0, rides.length, (r1, r2) -\u0026gt; r1[1] - r2[1]); // 终点为 i 的订单索引位置 int index = 0; for (int i = 1; i \u0026lt;= n; i++) { // 不载客 dp[i] = dp[i - 1]; // 如果有订单，载客 while (index \u0026lt; rides.length \u0026amp;\u0026amp; rides[index][1] \u0026lt;= i) { dp[i] = Math.max(dp[i], dp[rides[index][0]] + rides[index][1] - rides[index][0] + rides[index][2]); index++; } } return dp[n]; } } ","date":"2023-12-08T11:01:10+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2008.-%E5%87%BA%E7%A7%9F%E8%BD%A6%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9B%88%E5%88%A9/","title":"LeetCode 2008. 出租车的最大盈利"},{"content":" 1466. 重新规划路线\n思路 一共有 n 个点，编号从 0 -\u0026gt; n - 1，一共有 n - 1 条单向边将这些点串起来。从题意可以得知，这是一个有向无环图，节点之间有唯一的一条路径。\n两个节点之间是单向边，如果要修改路的放线，使所有点都可以到达 0 号点，需要从 0 号点出发，查看是否每一条边都 “指向 0 号点的方向”。如果没有指向，就修改，计数 +1；否则不做任何操作，继续遍历下一个点。\n求解过程 因为要从 0 号点出发到达每一个点，所以需要构建一个无相图。同时遍历图的过程中，需要记录边的方向，这里使用节点的入度进行表示。如果当前节点连接的下一个节点有入度，说明可能是从当前节点指向下一个节点的。\n因为有不确定性，可能是下下个节点指向下一个节点的入度，所以在判断之前，先将下下个节点指向下一个节点的影响消除，如果还剩下入度，则说明是当前节点指向下一个节点的。\n从 0 节点开始不断进行递归调用，在到达一个新节点时，先递归调用下一个节点，直到叶子节点。\n如果叶子节点指向上一个节点，则不用改变方向，但是需要将上一个节点的入度 -1，这就是消除影响。如果上一个节点指向叶子节点，需要改变方向，不需要消除影响，因为没有影响上一个节点。\n就这样不断向上回溯，来到 i 节点时，它的所有子节点的影响都消除了，执行同样的操作逻辑，消除 i 节点的影响。最终返回到 0 节点，得到需要变向的数量。\n复杂度 时间复杂度： $O(n)$ 每个节点只遍历一遍\n空间复杂度： $O(n)$ 需要一个邻接表和入度表\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public int minReorder(int n, int[][] connections) { List\u0026lt;Integer\u0026gt;[] graph = new List[n]; for (int i = 0; i \u0026lt; n; i++) { graph[i] = new ArrayList\u0026lt;Integer\u0026gt;(); } // 初始化入度表和邻接表 int[] in = new int[n]; for (int[] con : connections) { graph[con[0]].add(con[1]); graph[con[1]].add(con[0]); in[con[1]]++; } return process(graph, in, 0, -1); } // 来到了 index 节点，它的父节点是 fa， // 返回从该节点出发到所有子节点的变向数量 public int process(List\u0026lt;Integer\u0026gt;[] graph, int[] in, int index, int fa) { int cnt = 0; for (int node : graph[index]) { if (node != fa) { // 先进行递归，在下一个递归函数中会消除影响 cnt += process(graph, in, node, index); // 现在 node 下边节点的影响已经消除 if (in[node] \u0026gt; 0) { // index -\u0026gt; node 变向 cnt++; in[node]--; } else { // 消除 index \u0026lt;- node 的影响 in[index]--; } } } return cnt; } } ","date":"2023-12-07T22:40:29+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-1466.-%E9%87%8D%E6%96%B0%E8%A7%84%E5%88%92%E8%B7%AF%E7%BA%BF/","title":"LeetCode 1466. 重新规划路线"},{"content":" 2646. 最小化旅行的价格总和\n思路 一共有 n 个点，编号从 0 -\u0026gt; n - 1，一共有 n - 1 条单向边将这些点串起来。所以任意两点之间是有唯一通路的，不存在更短的路径。因此从 i 号点到达 j 号点，经过哪些点是确定的，也就是说整个旅行，每一个点经过的次数是确定的。\n相邻的点不能同时打折，类似于 198. 打家劫舍 ，这道题也可以使用类似的方式解决，在遍历整个图的过程中，通过相邻节点的打折情况灵活选择是否打折，最终求得花费最小值。\n求解过程 首先需要统计出所有旅行经过了哪些点，经过了几次。我这里使用暴力递归的方式，每次求出一个旅行的经过的点，最终求出所有旅行经过的点。\n递归调用 process 函数，如果出发点等于目的地，出发地次数 +1，否则继续递归，如果从出发点能到达目的地，出发点次数 +1，返回 true，否则返回 false。\n然后，根据统计好的点及次数，再次遍历整个图，求出最小值。调用 getMinSum 函数，需要传入 discount，它是一个 boolean 类型的值，表示父节点有没有打折，然后子节点就可以根据情况选择能够和是否打折。分别求出两种情况（如果有的话），取最大值，然后返回。\n最后，因为递归存在重复调用的情况，我们使用一个 dp 表记录下递归调用的结果，如果结果已经存在，直接返回；如果结果不存在时再计算，计算完成后，将结果记录下来，再返回。\n复杂度 时间复杂度：$O(nm)$ n 为节点的个数，m 为旅行的次数。求旅行经过哪些点时和计算最小花费时，时间复杂度为都是 n。\n空间复杂度：$O(n)$ 需要存储邻接表、节点次数表和dp表。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class Solution { public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) { List\u0026lt;Integer\u0026gt;[] graph = new List[n]; for (int i = 0; i \u0026lt; n; i++) { graph[i] = new ArrayList\u0026lt;Integer\u0026gt;(); } for (int[] edge : edges) { graph[edge[0]].add(edge[1]); graph[edge[1]].add(edge[0]); } int[] cnt = new int[n]; for (int[] trip : trips) { process(graph, cnt, trip[0], trip[1], -1); } // 使用备忘录优化递归时间。 int[][] dp = new int[n][2]; return getMinSum(graph, price, cnt, 0, -1, 0, dp); } // 从 index 出发，能够到达 target public boolean process(List\u0026lt;Integer\u0026gt;[] graph, int[] cnt, int index, int target, int fa) { if (index == target) { cnt[index]++; return true; } for (int node : graph[index]) { if (node != fa \u0026amp;\u0026amp; process(graph, cnt, node, target, index)) { cnt[index]++; return true; } } return false; } public int getMinSum(List\u0026lt;Integer\u0026gt;[] graph, int[] price, int[] cnt, int index, int fa, int discount, int[][] dp) { if (dp[index][discount] != 0) { return dp[index][discount]; } int p1 = 0, p2 = 0, ans = 0; // 当前节点不打折 for (int node : graph[index]) { if (node != fa) { p1 += getMinSum(graph, price, cnt, node, index, 0, dp); } } // 到达叶子节点，返回可以选择的最小值。 if (p1 == 0) { dp[index][discount] = discount == 1 ? cnt[index] * price[index] : cnt[index] * (price[index] / 2); return dp[index][discount]; } ans = p1 + cnt[index] * price[index]; // 根据上个节点的打折情况，选择打折 if (discount == 0) { for (int node : graph[index]) { if (node != fa) { p2 += getMinSum(graph, price, cnt, node, index, 1, dp); } } ans = Math.min(ans, p2 + cnt[index] * (price[index] / 2)); } dp[index][discount] = ans; return ans; } } ","date":"2023-12-06T11:10:35+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2646.-%E6%9C%80%E5%B0%8F%E5%8C%96%E6%97%85%E8%A1%8C%E7%9A%84%E4%BB%B7%E6%A0%BC%E6%80%BB%E5%92%8C/","title":"LeetCode 2646. 最小化旅行的价格总和"},{"content":" 2477. 到达首都的最少油耗\n思路 一共有 n 的点，编号 0 -\u0026gt; n - 1，使用 n - 1 条边进行连接，所以整个图是无环的，并且任意两个节点之间的路径是唯一的。\n一开始的思路是 求出每个叶子节点到达首都的路径，对于每一条路径，根据节点数就可以计算出油耗，最终相加。后来发现是错误的，因为行驶过程中可以下车换乘。也就是说原本可以坐 3 个人的车，从 2 个节点来到 i ，他们每人都一辆车，到达 i 节点后，算上 i 节点上的人，一共有 3 个人，他们坐一辆车就够了，而不是分别计算油耗。\n所以需要从首都开始递归，查看到达每一个中间节点的人数，然后根据人数重新安排车辆。\n求解过程 首先使用邻接表建出来整个图，用于递归遍历。然后从 0 开始进行递归。\n假如当前到达了 i 号点，它的子节点是 node ，先进行子过程的调用，返回 node 节点一共有多少人，根据人数计算出这些人从 node 到达 i 点的油耗，再将人数计算到 i 号点的人数中去。计算出所有子节点的人数和油耗之后，就可以将人数返回。\n当递归调用来到了叶子节点时，因为只有一条路径，叶子节点没有子节点可以遍历，整个 for 循环相当于直接跳过，最终只返回叶子节点的人数。\n复杂度 时间复杂度：$O(n)$ 遍历一遍图即可，每个节点进入函数一次，出函数一次。\n空间复杂度：$O(n)$ 需要将图建出来，邻接表。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { long ans = 0; public long minimumFuelCost(int[][] roads, int seats) { // n - 1 条边，一共有 n 个节点 int n = roads.length + 1; List\u0026lt;Integer\u0026gt;[] graph = new List[n]; for (int i = 0; i \u0026lt; n; i++) { graph[i] = new ArrayList\u0026lt;Integer\u0026gt;(); } for (int[] road : roads) { graph[road[0]].add(road[1]); graph[road[1]].add(road[0]); } dfs(graph, 0, -1, seats); return ans; } // 返回到达 index 点，一共有多少人。 public int dfs(List\u0026lt;Integer\u0026gt;[] graph, int index, int fa, int seats) { // 到达 index 点至少有 1 个人(当前节点) int num = 1, nextNum; for (int node : graph[index]) { if (node != fa) { // 从 下一个节点来的人有多少。 nextNum = dfs(graph, node, index, seats); // nextNum 个人从 node 点到达 index 点的耗油 ans += (nextNum + seats - 1) / seats; num += nextNum; } } return num; } } ","date":"2023-12-05T11:07:39+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-2477.-%E5%88%B0%E8%BE%BE%E9%A6%96%E9%83%BD%E7%9A%84%E6%9C%80%E5%B0%91%E6%B2%B9%E8%80%97/","title":"LeetCode 2477. 到达首都的最少油耗"},{"content":" LeetCode 1038. 从二叉搜索树到更大和树\n思路 给定的是一个二叉搜索数，二叉搜索数具有以下几种特点：\n节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。 所以二叉搜索数的最右节点肯定是最大的，大于等于该值的节点只有自己。\n对于任意一个头节点，它的右树的每一个节点肯定大于头节点，左树的每一个节点都小于头节点。所以我们可以按照 右 -\u0026gt; 头 -\u0026gt; 左 的顺序进行遍历，过程中记录下当前遇到的节点的和 sum，将节点值修改为 sum即可。\n右 -\u0026gt; 头 -\u0026gt; 左 这种顺序恰好是中序遍历的逆序，所以将中序遍历修改一下就可以了。\n求解过程 求解方式有递归法、迭代法和 Morris 法。这里只记录了 Morris 方法。\nMorris 方法就是在遍历过程中，利用节点中空闲的指针，提前为自己的行程搭建捷径，然后“过河拆桥”，恢复为原来的状态。\n复杂度 时间复杂度：$O(n)$ 空间复杂度：$O(1) 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public TreeNode bstToGst(TreeNode root) { // 反向中序遍历 int sum = 0; TreeNode node = root; TreeNode mostLeft = null; while (node != null) { mostLeft = node.right; if (mostLeft != null) { while (mostLeft.left != null \u0026amp;\u0026amp; mostLeft.left != node) { mostLeft = mostLeft.left; } if (mostLeft.left == null) { mostLeft.left = node; node = node.right; continue; } else { mostLeft.left = null; } } sum += node.val; node.val = sum; node = node.left; } return root; } } ","date":"2023-12-04T12:04:36+08:00","permalink":"https://zhuaowei.github.io/article/leetcode-1038.-%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%88%B0%E6%9B%B4%E5%A4%A7%E5%92%8C%E6%A0%91/","title":"LeetCode 1038. 从二叉搜索树到更大和树"},{"content":"一、git基本概念 1、blob and tree git 将文件目录用两种数据类型组成，分别是tree(folder)和blob(file)，tree包含tree或者blob，也就是说，文件目录是tree递归形成的。git项目的根目录用 ‘/’ 表示，也是一个tree。\n用伪代码形式表示\n1 2 type blob = array\u0026lt;byte\u0026gt; type tree = map\u0026lt;string, [blob | tree]\u0026gt; 1 2 3 4 5 6 7 /(root) | |--foo(tree) | | | |--bar.txt(blob) | |--baz.txt(blob) 以上表示了一个简单项目的git结构，root tree包含一个tree和一个blob，而tree又包含一个blob。\n2、snapshot git可以很好地进行版本控制，因为它可以对每个修改拍摄快照，通过快照，你可以回到任何一个之前的节点，每个快照都包含一个完整的git项目。通过快照你可以找到它的父节点。\n1 2 3 4 o \u0026lt;---------- o \u0026lt;----------- o \u0026lt;------------- o ^ / \\ / o \u0026lt;------/ 快照也可以很方便地进行协作开发，例如，你要开发一个新功能，但又要解决已存在的bug，这时候就可以fork一下，分别做两件事，最后通过git合并。git合并是自动完成的，如果它不确定，它会提交给开发者看来决定。例如，有两个人分别对一个文件的同一行进行了修改，但不相同，他会让你决定保留哪一项修改，再例如，在相同的下面添加了不同的内容，git不知道如何调整顺序，谁的放在前面，它会让你决定。\n3、commit 除此之外，还有commit数据类型，它是git提交时产生的对文件的描述文件，它是一个struct结构，包含作者、时间戳、描述等信息\n1 2 3 4 5 6 7 8 # 用伪代码表示 type commit = struct { parents: array\u0026lt;commit\u0026gt; author: string message: string snapshot: tree ... } 1 2 3 4 5 6 7 8 9 10 11 12 13 references = map\u0026lt;string, string\u0026gt; def update_reference(name, id): references[name] = id def read_reference(name): return references[name] def load_reference(name_or_id): if name_or_id in references: return load(references[name_or_id]) else: return load(name_or_id) 4、object and sha-1 git在磁盘中存储这些数据，必须有一个对象存储它。所以git定义了一个object类，用map(字典)存储一系列的object对象。通过这些对象就可以回溯之前每一个提交。\n1 2 type object = [blob | tree | commit] objects = map\u0026lt;string, object\u0026gt; 那么如何存储和找到这些object呢，git通过object的key来获取object，那么如何决定key的值呢？\n通过哈希函数，git定义了两个函数，分别用来生成哈希并存储object和通过哈希值获取object。\n1 2 3 4 5 6 7 8 def store(o) { id = sha1(o); objects[id] = o; } def load(id) { return objects[id]; } 这个哈希值是通过一定的算法，将object转化为一个160位的二进制数，如果用十六进制表示就是40位，这也是在实际使用中看到的。\n5、references 但是，这么长的一串字符对于我们理解和记忆具体提交了什么内容毫无意义，所以git定义了一个references，以人能理解的字符代替这么长的哈希值。\n1 type references = map\u0026lt;string, string\u0026gt; 二、命令演示 1、initialize 首先创建一个目录作为项目的根目录，然后进入\n1 2 mkdir demo cd demo 然后使用命令将其初始化为git目录\n1 git init 这个命令会创建 .git 目录，有以下内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 drwxrwxr-x 8 zhu521 zhu521 4.0K May 26 18:58 ./ drwxrwxr-x 3 zhu521 zhu521 4.0K May 26 18:26 ../ drwxrwxr-x 2 zhu521 zhu521 4.0K May 26 17:16 branches/ -rw-rw-r-- 1 zhu521 zhu521 269 May 26 18:26 COMMIT_EDITMSG -rw-rw-r-- 1 zhu521 zhu521 92 May 26 17:16 config -rw-rw-r-- 1 zhu521 zhu521 73 May 26 17:16 description -rw-rw-r-- 1 zhu521 zhu521 23 May 26 17:16 HEAD drwxrwxr-x 2 zhu521 zhu521 4.0K May 26 17:16 hooks/ -rw-rw-r-- 1 zhu521 zhu521 176 May 26 18:26 index drwxrwxr-x 2 zhu521 zhu521 4.0K May 26 17:16 info/ drwxrwxr-x 3 zhu521 zhu521 4.0K May 26 17:21 logs/ drwxrwxr-x 13 zhu521 zhu521 4.0K May 26 18:26 objects/ drwxrwxr-x 4 zhu521 zhu521 4.0K May 26 17:16 refs/ objects 和 refs 目录里存放了所有存储库数据\n2、help and status 2.1、help 1 git help [command] 这个命令可以查看所有命令的帮助\n2.2、status 1 git status 告诉你项目处于什么状态\n3、提交 3.1、git 工作区域 从上到下依次有三个层次\nRepositories Staging area work area 4、command-line 4.1、add and commit add 1 git add \u0026lt;file_name\u0026gt; 将文件提交到暂存区，这样你就可以添加多个文件到暂存区，然后一次性提交到仓库。\ncommit 1 git commit 将暂存区的文件提交到仓库，然后你需要编写commit内容。\n好的commit内容可以帮助你更好地回顾版本。可以参考commit标准。\nhttps://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html\n提交完成后，会给出哈希值的一部分，可以根据这个哈希值找到所有存储数据\n1 2 3 4 5 6 7 8 9 10 ➜ demo git:(master) git cat-file -p 1df5c162 tree 68aba62e560c0ebc3396e8ae9335232cd93a3f60 author zhuaowei \u0026lt;z2845191711@163.com\u0026gt; 1622020851 +0800 committer zhuaowei \u0026lt;z2845191711@163.com\u0026gt; 1622020851 +0800 Add hello.txt ➜ demo git:(master) git cat-file -p 68aba62e560c0ebc3396e8ae9335232cd93a3f60 100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad hello.txt ➜ demo git:(master) git cat-file -p 3b18e512dba79e4c8300dd08aeb37f8e728b8dad hello world log cat-file 1 2 3 4 5 # 查看所有提交记录，最新的显示在上面 git log # 查看提交的commit和blob内容 git cat-file -p \u0026lt;sha-1\u0026gt; 使用 git add 和 git commit 的好处是我可以只提交我修改的那部分，而不是将整个项目打包然后拍摄快照。\n1 2 # 以图形化的形式展示历史记录 git log --all --graph --decorate 4.2、checkout git checkout 可以让你回到任一历史记录中\n1 2 3 4 5 6 7 # 这个命令可以让你回到哈希值指向的快照 git checkout \u0026lt;sha-1\u0026gt; # 如果你对文件进行修改，但是并没有提交，使用checkout会报错 # 并提示已修改的文件 # 使用 -f 强制执行，慎用，因为这回导致你放弃所有当前修改的内容，再也回不到这里 git checkout -f \u0026lt;sha-1\u0026gt; 在使用这个命令后查看log，你会发现一些不同。\nHEAD 和 master的位置会发生改变，HEAD会指向你当前的快照，而master是一个分支，是创建项目创建的主分支，事实上，在你工作的大部分时候都是只有这一个分支。master始终指向该分支的最新提交记录。\nmaster其实是一个 reference，就像之前提到的，它是哈希值的别名，可以使用它转到最新的主分支。\n1 git checkout master 4.3、diff 这个命令可以比较任何两个快照和当前工作区内容的变化\n1 git diff [option[ other]] \u0026lt;filename\u0026gt; 这个命令默认是比较当前工作区和HEAD所指向的快照的区别\n当然你也可以添加参数比较其他的快照之间的\ngit diff HEAD master git diff 1df5c162b hello.txt\n4.4、branch 分支可以让你并行完成两件事，当你分别完成这两件事情时，可以将其合并到master分支。\nbranch 1 git branch 这个命令会展示所有分支，并且标注你所在的分支\n1 git branch -vv 这个命令除有 git branch 的功能外，还会展示额外信息，例如分支的哈希值和提交信息。\n1 git branch \u0026lt;name\u0026gt; 在当前位置建立一个分支。\ncheckout 1 git checkout \u0026lt;name\u0026gt; 切换到目的分支。\n1 git checkout -b \u0026lt;name\u0026gt; 创建分支并切换到该分支。\n1 git log --all --graph --decorate --oneline 与 git log \u0026ndash;all \u0026ndash;graph \u0026ndash;decorate 不同的是，这个命令会显示更少信息，每个快照只显示一行，看起开更精简。\n4.5、merge 当你全部完成并行的两个分支后，可以使用merge合并到一起。我们并不能直接使用 git merge cat dog直接将两个分支合并到master，需要先合并其中一个分支，然后再合并另一个。\n1 2 # 将cat分支合并到当前分支 git merge cat 因为merge是将分支合并到当前分支，所以合并之前要看清自己所在的分支和快照。\n合并时可能会产生冲突，git会在冲突的地方对文档进行标注。\n1 2 3 # 这两个不是成对使用的 git merge --abort git merge --continue 使用 git merge \u0026ndash;abort 中断合并，然后项目会回到合并前的状态。\n一般情况下，使用 解决冲突的工具 (e.g. mergetool vimdiff)解决冲突（不会）。\n特殊情况下，我们可以手动将冲突解决，删除冲突标记，然后使用 git merge \u0026ndash;continue 告诉git我们已经解决了冲突，再将修改的文件添加到暂存区，再次使用 git merge \u0026ndash;continue 会进入边 commit 界面，填写commit信息后就会提交，这次是真正的解决冲突，这个时候 git 的分支就会合并到一起，并创建一个新的快照。\n4.6、remote init 在拷贝远程库之前需要做些准备。\n1 2 git init # 创建普通库 git init --bare #创建裸库 与 git init 的区别是，它创建的是裸库，虽然它会创建 .git 文件夹，但是你没有权限进行修改和删除，但是你仍然可以进行读取操作。这是在多人共享时用到的，通常这个文件夹用 .git 作为后缀，例如：example.git。\n实际上，它不会创建 .git 文件夹，而是将所有的 .git 下的文件直接放到项目的根目录。\nremote 1 2 git remote git remote add \u0026lt;remote\u0026gt; \u0026lt;url\u0026gt; git remote 会列出所有你配置过的远程仓库\ngit remote add 添加一个远程仓库的配置，这个url可以是一个git仓库连接，也可以是一个本地文件夹的路径。之后可以将本地仓库 push 到远程仓库\npush clone 1 2 3 git push \u0026lt;remote\u0026gt; \u0026lt;local branch\u0026gt;:\u0026lt;remote branch\u0026gt; git clone \u0026lt;url\u0026gt; \u0026lt;folder name\u0026gt; git clone --shallow \u0026lt;url\u0026gt; \u0026lt;folder name\u0026gt; 第一个命令是将本地仓库 push 到远程仓库，第二个命令是将远程仓库克隆到本地。\n使用push命令前后可以使用 git log \u0026ndash;all \u0026ndash;graph \u0026ndash;decorate \u0026ndash;oneline 查看分支如何变化。\n在push之后，会在push的节点多出一些信息，这些信息显示了远程仓库指向的节点。\nupstream 1 git branch --set-upstream-to=origin/master 本地库的所有修改不会影响远程，只有再次push才可以。不过有一种简单的方式不用每次都push，就是将远程设置为上游.\n这时候用 git branch -vv 可以看到origin已经作为本地的一个分支。之后再push的时候只需要使用 git push即可自动push到origin/master.\nfetch pull 1 2 git fetch git pull git fetch 会下载远程库到本地，并不会覆盖本地，而是作为一个分支，会检索本地与远程库是否相同。然后可以使用 git merge将其与本地合并。git fetch 默认会同步所有远程仓库的 master 分支，可以使用 git fetch 指定远程库及其分支。\ngit pull == git fetch; git merge\n5、config 1 2 git config vim ~/.gitconfig git config 会显示当前的git配置。\ngit的默认配置在 ~/.gitconfig 中。\n","date":"2023-04-04T15:23:43+08:00","permalink":"https://zhuaowei.github.io/article/git-%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/","title":"git 命令操作"},{"content":"1、LeetCode 题目 滑动窗口最大值\n给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n返回 滑动窗口中的最大值 。\n示例 1：\n输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\n输出：[3,3,5,5,6,7]\n解释：\n1 2 3 4 5 6 7 8 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 示例 2：\n输入：nums = [1], k = 1\n输出：[1]\n2、双端队列 双端队列：可以从两端出队和入队的队列。Java 中有 DeQueue 类，也可以使用 LinkedList 类，都可以实现以下操作：\n头部入队、头部出队\n尾部入队、尾部出队\n获取头部、获取尾部\n本文使用的类是 LinkedList。\n1 2 3 4 5 6 头部入队: addFirst() 头部出队: removeFirst() 尾部入队: addLast() 尾部出队: removeLast() 获取头部: getFirst() 获取尾部: getLast() 3、窗口 窗口其实就是数组中的一个范围，它包括左边界 L和右边界 R，左边界不能超过右边界。窗口在变化的过程中，左边界和右边界只能向右移动，也可以不动，但是不能往左走。在初始情况下，窗口是不在数组中的，所以他们的值都是 -1。\n4、详解原理 我们使用双端队列存储窗口中的最大值，存储的是数组对应的下标，因为有下标我们就可以获取数组的信息。\n首先，我们将窗口变化的情况分为两种，一是 右边界右移，而是 左边界右移。\n1、右边界右移\n当右边界扩充到 i 位置时，arr[i] 相比于双端队列的最后一个元素 LAST 有以下三种情况：\n1.1、LAST \u0026gt; arr[i]，添加后不影响队列的单调性，直接添加。\r1.2、LAST == arr[i]，添加后队列不是绝对单调，所以需要将 LAST 出队，然后继续比对 LAST，循环往复，直到 `LAST \u0026gt; arr[i]` 或者队列为空，将 arr[i] 添加到队列尾部。\r1.3、LAST \u0026lt; arr[i]，和上面的 1.2 一样破坏了队列的绝对单调性，操作和上面的一样。\r绝对单调性：指整个单调递增或单调递减，没有存在导数为 0 的情况。\n2、左边界右移\n当左边界扩充到 i 位置时（左边界不超过右边界），arr[i] 相比于双端队列第一个元素 FIRST 有两种情况（因为队列 FIRST 是窗口中最大的，不可能有 arr[i] 还大的）：\n2.1、arr[i] \u0026lt; FIRST，舍弃该元素并不影响窗口内的最大值，队列不坐任何操作。\r2.2、arr[i] == FIRST，如果 FIRST 的下标等于 i，说明 FIRST 就是 arr[i]，而 arr[i] 是要舍去的，所以 FIRST 从头部出队；如果 arr[i] == FIRST，但二者下标并不同，那么 FIRST 的下标必定大于 i（因为尾部入队保证绝对单调性），窗口范围不包括 i，也不影响窗口内的最大值，所以什么都不做。\r3、双端队列的实际意义\n双端队列中保持绝对单调性的实际含义，我们需要从尾部入队的情况来看：\n3.1、LAST \u0026gt; arr[i]，比尾部小，但是还是有可能成为窗口最大值的，只不过肯定比 LAST 晚。\r3.2、LAST == arr[i]，与尾部相等，但是下标比尾部大，所以 arr[i] 肯定比尾部晚过期。\r3.3、LAST \u0026lt; arr[i]，前面的 LAST 永远都没有机会称为窗口的最大值。\r所以，双端队列的实际意义就是从前往后，依次有可能成为最大值的，且过期时间最晚的顺序。\n5、Java 代码 这段代码最关键的有两段，就是 右边界右移 和 左边界右移 的代码。\n5.1、右边界右移代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 如果 LAST \u0026gt; nums[i]; 2.2 直接尾部入队 if (nums[list.getLast()] \u0026gt; nums[i]) { list.addLast(i); } else { // 否则继续比对，直到队列为空 while (!list.isEmpty()) { // 如果 LAST \u0026gt; nums[i]，可以不比了；否则出队继续比 if (nums[list.getLast()] \u0026lt;= nums[i]) { list.removeLast(); } else { break; } } // 最终入队 list.addLast(i); } 在右边界第一次右移时，队列是空的，所以加个判断条件，遇到空队列，直接添加到尾部。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if (list.isEmpty()) { list.addLast(i); continue; } `` **5.2、左边界右移代码** ```java // 如果 FIRST == nums[i - k]，并且下标相同才出队，否则什么都不做 if (nums[i - k] == nums[list.getFirst()] \u0026amp;\u0026amp; i - k == list.getFirst()) { list.removeFirst(); } 5.3、完整Solution代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public int[] maxSlidingWindow(int[] nums, int k) { LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); int max = Integer.MIN_VALUE; int[] ans = new int[nums.length - k + 1]; // 先把初始窗口建立起来 for (int i = 0; i \u0026lt; k; i++) { if (list.isEmpty()) { list.addLast(i); continue; } if (nums[list.getLast()] \u0026gt; nums[i]) { list.addLast(i); } else { while (!list.isEmpty()) { if (nums[list.getLast()] \u0026lt;= nums[i]) { list.removeLast(); } else { break; } } list.addLast(i); } } ans[0] = nums[list.getFirst()]; for (int i = k; i \u0026lt; nums.length; i++) { // 左边界右移 if (nums[list.getLast()] \u0026gt; nums[i]) { list.addLast(i); } else { while (!list.isEmpty()) { if (nums[list.getLast()] \u0026lt;= nums[i]) { list.removeLast(); } else { break; } } list.addLast(i); } // 左边界右移 if (nums[i - k] == nums[list.getFirst()] \u0026amp;\u0026amp; i - k == list.getFirst()) { list.removeFirst(); } // 右移一次，左移一次，然后记录窗口最大值 ans[i - k + 1] = nums[list.getFirst()];; } return ans; } } ","date":"2022-11-18T21:35:38+08:00","permalink":"https://zhuaowei.github.io/article/%E4%BD%BF%E7%94%A8%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E6%B1%82%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/","title":"使用双端队列求滑动窗口的最大值"},{"content":"1、回文子串 回文就是正着读和反着读是一样的，例如 abcba 反过来还是 abcba，abba 反过来也是 abba。\n回文子串就是字符串中某段连续的子串是回文，子串必须是连续的。\n如何求回文呢，如果是暴力解法，用某一个字符作为对称轴，然后不断向两边比对延伸。这种方法不仅慢，而且还有一个问题，就是无法找到长度为偶数的回文，编程上也很难实现。\n更好的方法是 Manacher 方法，它是在原来字符串的基础上，在字符之间和头尾添加字符，可以使用原字符串的字符作为对称轴，找到单数长度的；也可以使用插入的字符作为对称轴，找到双数长度的。例如：\n1 2 3 4 5 | abcba -\u0026gt; #a#b#c#b#a#。 | abba -\u0026gt; #a#b#b#a# | 添加的字符有什么要求吗，答案是没有。无论添加什么字符。都不会影响结果。因为比对时，始终是原字符和原字符比，虚字符和虚字符比（虚字符：添加的）。\n这个时候再用暴力解法就会比原来方便，得出的结果只需除以 2 即可。例如第一个字符串 长度是 11，原字符串是 5；第二个字符串长度是 9，原字符串是 4。\n2、Manacher 加速 有没有什么办法，类似 KMP 算法，让对比的速度加快，也就是利用已经比对过的信息，省去一些不必要的比对。其实就是利用 Manacher 算法。\n先来了解几个概念：\n回文中心：回文对称轴所在的位置。因为对原字符串处理过，回文中心一定是整数。 回文直径：回文的长度 回文半径：回文中心到回文边界的长度。 我们使用一个整数数组将其存储起来，表示 i 位置的回文半径为 pArr[i]。同时我们记录一下 i 位置之前的回文达到最右的情况的信息（回文中心C，右边界R），那么相应的左边界为 L。\n如果在对比以某字符为中心的回文时，在这之前已经有前面字符的回文中心、半径信息，我们可能会遇到下面两种情况：\n1、要比对的回文字符中心 i，在之前的最大右边界之外：我们得不到任何有用的信息，暴力解法，一个一个比对。例如下面的情况：\n1 2 L C R i ...[...C...]...x 2、如果要比对的回文字符中心 i，在之前的最大右边界之内：这个时候，根据 i 的位置又分 3 种情况。\n2.1、第一种情况，如果以 C 为中心的 i 的对称点 i'，这个位置的回文完全在 [L, R] 之内，那么位置 i 的回文串长度必定与之相等。\r```\rL C R\r...[.................C.................]...\r...m(...x...)n... ...p(...x...)q...\ri' i\r```\r为什么必定呢？因为 m != n，并且根据关于 C 对称的，m == q,n == p,那么 p != q，所以 i 位置的回文肯定是 pArr[i'] 这么长，不会多。\r2.2、第二种情况，如果以 C 为中心的 i 的对称点 i'，这个位置的回文一部分出现在 [L, R] 之外，那么 i 位置的回文长度也一定不会超过 R - i。\r```\rL C R\r......[...........C...........]......\r...m(...x...)... ...(...x...)q...\ri' ( i )\r```\r如图，小括号是 i 和 i' 回文串对应的范围，但是 i 位置的回文串肯定不是括号标识的那么长，它肯定不会超过 [L, R] 的右边界。因为如果超过了右边界 R，那么 m == q，那么 [L - 1, R + 1] 也肯定是回文串，因为它不是，所以 m != q，i 位置的回文串半径肯定是 R - i。\r2.3、第三种情况，如果以 C 为中心的 i 的对称点 i'，这个位置的回文的左边界与 L 重合，只能确定 i 位置的回文串至少等于 i' 位置的回文串。\r```\rL C R\r...[............C............]...\rm(...x...)n p(...x...)q\ri' i\r```\r从上面看出：m != n, n == p, m != q. 而 p == q? 这个并不知道，还要继续往下比对。\r3、Java代码实现 下面的代码实现与上面的有两点不同：\n一是 R 的定义，下面的 R 比上面的大 1，为了方便写代码。原来的 R 是 回文串中心位置 + 半径 - 1；现在的 R 不用减 1.\n二是不会将第二种情况一一进行分类处理，当然实际上是可以的。统一处理的好处是代码简洁。例如 for 循环中第一行代码，实际上是获取 i 位置回文串的中暂时的半径，i + pArr[i] 和 i - pArr[i] 实际上就是下一个需要进行比对的位置。即使知道其中有两种情况不需要比对，实际上他们比对一下就会跳出 while 循环，但这样做简化了代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public static int getMaxLcpsString(String s) { // 将字符串转换成 manacher 字符串 char[] str = getManacherString(s); // i 位置的回文半径 int[] pArr = new int[str.length]; // R: 回文到达的最远位置 + 1；C: 到达最远位置时回文中心。 int R = -1, C = -1; int max = Integer.MIN_VALUE; for (int i = 0; i \u0026lt; str.length; i++) { /** 计算出不需要验证的范围 * 1、i 超出 R，设置为 1，因为自身不需要验证 * 2、i 在 R 范围内，选择范围最小的 * 2.1、如果完全在内部，pArr[2 * C - i] * 2.2、如果在外部或者压线，R - i */ pArr[i] = i \u0026lt; R ? Math.min(R - i, pArr[2 * C - i]) : 1; /** * 除了 i 不在 R 内和 i 在 R 内且边界重合的情况需要扩 * 另外两种，因为直到肯定扩不成，但是还是放在一起写，简化代码 */ while (i + pArr[i] \u0026lt; str.length \u0026amp;\u0026amp; i - pArr[i] \u0026gt; -1) { if (str[i + pArr[i]] == str[i - pArr[i]]) { pArr[i]++; } else { break; } } // 如果超过了原来边界，更新 if (i + pArr[i] \u0026gt; R) { R = i + pArr[i]; C = i; } max = Math.max(max, pArr[i]); } return max - 1; } public static char[] getManacherString(String s) { char[] str = new char[s.length() * 2 + 1]; char[] os = s.toCharArray(); for(int i = 0; i \u0026lt; str.length; i++) { // 偶数位置插入 #；奇数位置插入原字符，因为数组边长了，所以要除以 2. str[i] = i % 2 == 0 ? \u0026#39;#\u0026#39; : os[i / 2]; } return str; } ","date":"2022-11-17T17:07:19+08:00","permalink":"https://zhuaowei.github.io/article/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E6%B1%82%E6%B3%95manacher/","title":"最长回文子串求法Manacher"},{"content":"1、KMP 简介 KMP 是1964年发明的字符匹配算法，经过 25 年的证明才将相关的理论证明完成。\n假设要从字符串 str1 中匹配出字符串 str2。\n暴力的字符匹配算法就是将两个字符串的字符从第一个开始一个一个匹配，如果不相等，str1 右移一个位置，而 str2 直接移动到 0，重新开始匹配，时间复杂度为 O(MN)。MN分别是 str2、str1 的长度。\n而 KMP 算法就是将这个 str2 右移的速度加快了。具体是怎么加快的呢，就是利用 str2 中子串的最长的前缀后缀相等的长度进行加速的，它的时间复杂符不会超过O(2N)。\n例如：str1 = abbecabbstabbecabbx; str2 = abbecabby。\n加速匹配过程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 i1 v abbecabbstabbecabbx abbecabby ^ i2 1、按顺序匹配 i1 v abbecabbstabbecabbx abbecabby ^ i2 2、遇到不相等的情况，不是 i1 回退到字符 b 的位置，i2 回到索引为 0 位置， 而是 i1 不动，i2 向前移动到前面子串的最长前缀后缀相等长度的位置。 此时最长的相等的前缀后缀是 abb，（[abb]ec[abb]） i1 v abbecabbstabbecabbx abbecabby ^ i2 为什么不用重新匹配呢，因为经过 str2 的最长前缀后缀计算后，已经找到了能够移动的最大位置，而且保证中间不会再有匹配成功的位置。\n继续匹配：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 i1 v abbecabbstabbecabbx abbecabby ^ i2 3、发现又不相等，i2 位置的最长前缀后缀长度为 0，跳转到索引 0 位置 i1 v abbecabbstabbecabbx abbecabby ^ i2 4、也没匹配上，同时发现 i2 已经到了 0 位置了，不能再移动了，只好移动一下 i1 i1 v abbecabbstabbecabbx abbecabby ^ i2 5、如此循环下去。 从上面的过程可以看出，i1 自始至终没有回退，i1 移动到 第三个 a 的位置，只需要 4 步（从i1、i2第一次不相等的位置）；而暴力匹配至少要 10 步。\n2、最长前缀后缀 abbecabby 的子串是 abbecabb，子串的最长前缀后缀是 abb.\n1 2 3 abbecabb abb abb i2 移动之前，i2 之前的字符串和 i1 前面那段与之长度相同的一段，是相等的。\n1 2 3 4 5 6 7 8 i1 v abbecabbstabbecabbx abbecabby ^ i2 =\u0026gt; abbecab(str1) = abbecab(str2) 把 i2 移动到最长前缀后缀的下一个位置与 i1 位置进行比较，保证了前缀和后缀相等，也就是 str2 的前缀和 str1 中 i1 前面的一段后缀与之相等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 i1 v abbecabbstabbecabbx --- abbecabby --- --- ^ i2 等价于 i1 v abbecabbstabbecabbx ---| |-\u0026gt; |abbecabby ---| --- ^ i2 相当于 str1 从第二个 abb 开始与 str2 的 0 位置重新开始匹配，并且移动了 abb 的位置。因为这两段是肯定相等的，我们计算过了，我们只需要匹配不相等的部分，即下一个位置。利用反证法可以证明，跳过的位置不会再有更长的最长前缀后缀。\n这样我们只需要求出 str2 的 next 数组即可。\n3、next 数组求解 next数组是与 str2 等长的 int 型数组，它的 i 位置记录了前面子串的最长前缀后缀的长度（最长前缀尾部后面一个元素的索引），换句话说就是，当匹配不成功时，i2 应该跳到的位置。\nnext 数组规定 next[0] = -1; next[1] = 0;\nnext[1] = 0，因为子串长度为 1，并且前缀和后缀不允许等于子串长度，所以 next[1] 必定为 0。\n当 i \u0026gt; 1 时如何求 next[i] 呢？\n分两种种情况：\n1、当子串的最长前缀后面的字符与 i - 1 的字符相等时，相当于最长前缀后缀增加了1，所以 next[i] = next[i - 1] + 1\n2、当子串的最长前缀后面的字符与 i - 1 的字符不相等时，根据子串最长前缀位置的子串的最长前缀判断：\n2.1、当这个值 大于 0 时，最长前缀还可以再往前推，最长前缀变小。\r2.2、如果这个值 小于 0 时，说明最长前缀长度已经为 0 了，不能再推了，i 位置的最长前缀长度为 0，`next[i] = 0`\r同样可以使用反证法证明在这中间已经没有比之更长的前缀了。\n这个 str2 的 next 数组计算是线性的，所以，它的时间复杂度是 O(M)。KMP算法中使用了一次，初次之外还有一个时间复杂度为 O(N) 的循环匹配，所以准确地说，KMP 的总体复杂度是 O(M + N)，因为 N \u0026gt;= M，所以上面说时间复杂度不超过 O(2N) 也对。\n4、Java 代码实现 KMP 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 public class KMP { /** * 使用 KMP 算法得出 s 是否包含 m * 如果包含，返回 s 中 m 的开始索引，否则返回 -1 */ public static int getIndexOf(String s, String m) { // 首先将 str1 str2 转成字符数组 char[] str1 = s.toCharArray(); char[] str2 = m.toCharArray(); int i1 = 0, i2 = 0; int[] next = getNextArray(str2); while (i1 \u0026lt; s.length() \u0026amp;\u0026amp; i2 \u0026lt; m.length()) { if (s == null || m == null || m.length() \u0026lt; 1 || s.length() \u0026lt; m.length()) { return -1; } if (str1[i1] == str2[i2]) { // 匹配成功，同时右移 i1++; i2++; } else if (i2 == 0) { // 也可以写成 next[i2] == -1，意思是一样的 // 这个时候 i2 无论如何也无法向前移动了，只能移动 i1 i1++; } else { // i2 还能向前移 System.out.println(next[i2] + \u0026#34; \u0026lt;- \u0026#34; + i2); i2 = next[i2]; } } // 如果匹配成功，那么 i2 肯定走到头了，减去 i2 就是开始位置；否则返回 -1 return i2 == m.length() ? i1 - i2 : -1; } /** * 给定一个字符数组，返回一个它的 next 数组 */ public static int[] getNextArray(char[] ms) { int[] next = new int[ms.length]; // 规定 next 数组前两个分别是 -1，0 next[0] = -1; next[1] = 0; // cn 有两个含义：1、i - 1 位置的最长前缀值；2、cn 位置应该和i - 1 位置相比。 int cn = 0; // i 是开始计算 next 数组的位置 int i = 2; while (i \u0026lt; next.length) { if (ms[cn] == ms[i - 1]) { /** * 下面三句可以简化成一句。 * next[i] = cn + 1; * i++; * cn++; */ next[i++] = ++cn; } else if (cn \u0026gt; 0) { // cn 位置最长匹配前后缀还有东西，还可以前移 // i 并不增加，下次循环继续尝试新的最长匹配前缀 cn = next[cn]; } else { /** * 下面两句可以简化成一句 * next[i] = 0; * i++; */ next[i++] = 0; } } return next; } public static void main(String[] args) { String s1 = \u0026#34;abbstabbecabbstabbx\u0026#34;; String s2 = \u0026#34;abbstabbx\u0026#34;; System.out.println(getIndexOf(s1, s2)); } } ","date":"2022-11-15T20:02:06+08:00","permalink":"https://zhuaowei.github.io/article/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95-kmp/","title":"字符串的模式匹配算法 KMP"},{"content":"1、并查集 并查集的结构设计就是都以比较快的速度实现这两个操作：合并两个集合、查询两个元素是否在同一个集合。\n实现细节：\n1、元素类：定义元素类，并定义一个构造函数，使并查集可以接收任意类型的集合。\n2、并查集的属性：\n2.1、elementMap：根据元素原始类型可以查询到Element类型的map，存储所有加入并查集的元素。\r2.2、fatherMap：根据Element，可以查询到他的父元素。\r2.3、mapSize：记录头元素所代表的集合的大小。\r所谓头元素，就是所有集合祖先元素，所有元素都可以通过不断向上查询找到它。\n3、并查集的方法：\n3.1、isSameSet：给出两个元素，判断是否在同一个集合，返回一个布尔值。\r3.2、union：合并两个元素所在的集合，如果并查集中不存在其中元素或者两个元素已经在同一个集合了，就不做任何操作。\r3.3、findHead：给出一个元素，查找它的头元素（集合的代表元素）。同时，把路径上经过的元素的父元素都改成头元素，这个操作也叫扁平化处理，能够提高查询的速度。\r4、并查集的初始化：\n4.1、初始化要一次性把所有元素都加进来，之后不能再添加元素。\r4.2、初始化时，所有元素都加入elementmap，且每个元素都是自己单独一个集合，mapsize为 1.\r并查集的实现代码放在最后（Java实现）。\n2、感染法求岛的个数 例题：有一个二位数组，只存储 0 和 1，0 代表海洋，1代表陆地。陆地可以跟上下左右四个方向的陆地相连，形成小岛，单独一块陆地也是小岛，求数组中小岛的数量。\n解：使用感染法，两层 for 循环查询元素为 1 的值，对这个值调用感染函数，每次遇到 1，就将小岛数加 1。函数中使其值为 2，然后继续递归调用函数，感染上下左右四个陆地。停止条件为陆地超出边界或者 不为 1.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // x, y 是陆地的座标，M, N 是数组的行数和列数。 public void infect(int[][] arr, int x, int y, int M, int N) { if (x \u0026lt; 0 || x \u0026gt;= N || y \u0026lt; 0 || y \u0026gt;= M || arr[x][y] != 1) { // 如果超过边界，感染过或者不是陆地，直接返回。 return; } arr[x][y] = 2; // 分别是上下左右 infect(arr, x, y - 1, M, N); infect(arr, x, y + 1, M, N); infect(arr, x - 1, y, M, N); infect(arr, x + 1, y, M, N); } 因为数组是有边界的，而且感染的陆地被修改为2，不会让递归一直进行。时间复杂度为 O（MN）。\n上面的是单线程的，因为所有的算法平台都是单核的，如果地图特别大，需要并行计算怎么办，如果只是简单地划分不同块，然后合并，得到的数字可能会变大，因为有岛会被切成多个。\n解决办法是：使用并查集，在单独计算块内的岛时，特别记录一下位于边界的块，记录一下他们是从哪个块被感染的，存入并查集。合并时，将每一个块与相邻的块合并，如果原图是同一个岛，就将两个集合合并。\n3、并查集实现代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 public class UnionFindSet\u0026lt;V\u0026gt; { /** * 定义一个泛型类，给元素套上壳 */ public class Element\u0026lt;V\u0026gt; { public V value; public Element(V value) { this.value = value; } } // 加入并查集的元素，并查集只支持开始添加元素。 public HashMap\u0026lt;V, Element\u0026lt;V\u0026gt;\u0026gt; elementMap; // 元素的父元素 public HashMap\u0026lt;Element\u0026lt;V\u0026gt;, Element\u0026lt;V\u0026gt;\u0026gt; fatherMap; // 代表元素的 size，代表元素就是集合最上层的元素，只有这个元素才能有size属性 public HashMap\u0026lt;Element\u0026lt;V\u0026gt;, Integer\u0026gt; mapSize; /** * 对元素列表进行并查集的初始化 * 1. 所有元素加入elementmap * 2. 所有元素的父元素是自己 * 3. 所有元素的size属性为1 */ public UnionFindSet (List\u0026lt;V\u0026gt; list) { elementMap = new HashMap\u0026lt;\u0026gt;(); fatherMap = new HashMap\u0026lt;\u0026gt;(); mapSize = new HashMap\u0026lt;\u0026gt;(); for (V e: list) { elementMap.put(e, new Element\u0026lt;\u0026gt;(e)); fatherMap.put(elementMap.get(e), elementMap.get(e)); mapSize.put(elementMap.get(e), 1); } } public Element\u0026lt;V\u0026gt; findHead(Element\u0026lt;V\u0026gt; e) { Stack\u0026lt;Element\u0026lt;V\u0026gt;\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); // 一直向上找，直到找到某元素的父元素是自己，一路上将元素存入栈 while (e != fatherMap.get(e)) { stack.push(e); e = fatherMap.get(e); } // 一次弹出栈，将元素的父元素设置为e。扁平化的目的是减少寻找的时间，降低复杂度。 while (!stack.isEmpty()) { fatherMap.put(stack.pop(), e); } return e; } /** * 判断是否是在同一个集合 */ public boolean isSameSet(V a, V b) { if (elementMap.containsKey(a) \u0026amp;\u0026amp; elementMap.containsKey(b)) { return findHead(elementMap.get(a)) == findHead(elementMap.get(b)); } return false; } /** * 将 a 所在集合与 b 所在集合 合并 */ public void Union(V a, V b) { // 加入并查集才能合并 if (elementMap.containsKey(a) \u0026amp;\u0026amp; elementMap.containsKey(b)) { Element\u0026lt;V\u0026gt; aH = findHead(elementMap.get(a)); Element\u0026lt;V\u0026gt; bH = findHead(elementMap.get(b)); // 不是同一个头才合并 if (aH != bH) { // 区分出哪个是大的，哪个是小的。小的连到大的后面 Element\u0026lt;V\u0026gt; big = mapSize.get(aH) \u0026gt;= mapSize.get(bH) ? aH : bH; Element\u0026lt;V\u0026gt; small = aH == big ? bH : aH; fatherMap.put(small, big); mapSize.put(big, mapSize.get(small) + mapSize.get(big)); mapSize.remove(small); } } } } ","date":"2022-11-14T18:36:50+08:00","permalink":"https://zhuaowei.github.io/article/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%BB%A5%E5%8F%8A%E6%84%9F%E6%9F%93%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97%E5%B2%9B%E7%9A%84%E6%95%B0%E9%87%8F/","title":"并查集以及感染算法计算岛的数量"},{"content":"1、时间复杂度 1.1、操作单元 程序执行的一个最基本的操作。例如获取数组中第 i 个元素的值，只需计算它的偏移量即可；跳转一次链表，指向下一个单元；执行一次交换操作等。\n1.2、时间复杂度 估算的执行程序所需的执行操作单元的次数，以选择排序为例，计算选择排序算法的时间复杂度。\n选择排序是遍历一边数组，找出数组中数值最小的一项，与第一项交换，然后从第二项开始再次找到最小的元素，与第二项交换，以此类推，直到最后。\n那么算法需要执行\n遍历操作数为 1 + 2 + 3 + ... + n 次，一共是 [n(n+1)]/2 次。\n比较次数与上面一样 [n(n+1)/2] 次\n交换操作 n 次。\n一共是 $n^2 + 2n$ 次，保留最高项，去掉最高项的系数，所以选择排序的事件复杂度为 $O(n^2)$ 。\n当数据量很大的时候，舍去的项就显得非常微小了，所以这也是只保留最高项的原因。\n当两个时间复杂度相同的算法比较好坏时，需要分析不同样本下程序运行所需要的事件。\n2、排序算法 2.1、选择排序 第 i 次循环，找出index \u0026gt;= i 中值最小的项，与第 i 项交换（i = 0, 1, 2, \u0026hellip;, N）\nC/C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 交换两个元素 int* swap(int arr[], int i, int j){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } int* selectionSort(int arr[], int length){ // 排除空数组和长度为1 的数组 if (arr == nullptr || length \u0026lt; 2) { return arr; } // 循环开始 for (int i = 0; i \u0026lt; length; i++) { // 最小值的 index int minIndex = i; for (int j = i; j \u0026lt; length; j++) { // 比较一下，更新最小值的索引 if (arr[minIndex] \u0026gt; arr[j]) { minIndex = j; } } swap(arr, minIndex, i); } return arr; } 2.2、冒泡排序 第一次循环，依次比较第 1，2个；2，3个；3，4个；\u0026hellip;；N - 1个，N个元素的大小，不符合排序顺序的就交换。\n第二次循环，依次比较第 1，2个；2，3个；3，4个；\u0026hellip;；N - 2个，N - 1个元素的大小，不符合排序顺序的就交换。\n第二次循环，依次比较第 1，2个；2，3个；3，4个；\u0026hellip;；N - 3个，N - 2个元素的大小，不符合排序顺序的就交换。\n\u0026hellip;\nC/C++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int* swap(int arr[], int i, int j){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } int* bubbleSort(int arr[], int length) { for (int i = 0; i \u0026lt; length - 1; i++) { for (int j = 0; j \u0026lt; length - 1 - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { swap(arr, j, j + 1); } } } return arr; } 2.3、插入排序 从左到右逐步实现有序，就像打扑克整理牌一样。\n第一步，实现 0 - 0 有序，必然是有序的，可以跳过\n第二步，实现 0 - 1 有序，如果 arr1 \u0026lt; arr0，则交换。\n第三步，实现 0 - 2 有序，如果arr2 \u0026lt; arr1，交换；再继续向前比较，如果还是arr2（这个时候已经变成arr1了）小，继续交换，以此类推\u0026hellip;\n\u0026hellip;\n直到第N步，实现整个数组的排序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } public static void insertSort(int[] arr) { for (int i = 1; i \u0026lt; arr.length; i++) { for (int j = i - 1; j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; arr[j + 1]; j--) { swap(arr, j, j + 1); } } } 2.4、插入排序的时间复杂度 如果考虑最好的情况，就是排序好的数组，每次循环只需看一下，不满足循环条件就到下一次循环。这种情况的时间复杂度是O(N)。\n如果是最坏的情况，与预期排序的顺序完全相反，那么第 i 次循环救药执行 i 次，就是1 + 2 + 3 + \u0026hellip; + N，这个时间复杂度就是 $O(N^2)$ 。\n算法时间复杂度只考虑最坏的情况。\n3、交换 3.1、普通交换 使用一个中间变量暂时存储其中一个变量，这个变量把另一个变量存储好后，就把临时变量赋值给另一个变量。\n1 2 3 4 5 int* swap(int arr[], int i, int j){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } 3.2、加法交换 变量1存储两个数的和，然后把变量1减变量2的结果赋值给变量2，最后把变量1减去变量2的结果赋值给变量1。\n1 2 3 4 5 int* swap(int arr[], int i, int j){ arr[i] = arr[i] + arr[j]; arr[j] = arr[i] - arr[j]; arr[i] = arr[i] - arr[j]; } 不需要借助临时变量。\n3.3、异或交换 1、异或\n异或用符号 ^ 表示，同位的数字相同为0，不同为1。\n1 2 3 a 111010 b 010111 ^ 101101 2、异或特性\n任何值异或0都是本身 任何值与自己异或都是0 满足交换律和结合律 3、交换\n1 2 3 4 5 int* swap(int arr[], int i, int j){ arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; } 原理：\n第一步 arr[i] = arr[i] ^ arr[j];\n第二步 arr[j] = arr[i] ^ arr[j] = arr[i] ^ arr[j] ^ arr[j] = arr[i] ^ 0 = arr[i];\n第三步 arr[i] = arr[i] ^ arr[j] = arr[i] ^ arr[j] ^ arr[i] = arr[j] ^ 0 = arr[j];\n注意：这种方法必须保证交换的双方指向的不是同一块内存地址。不推荐使用\n位操作的速度比一般加减乘除快。\n4、相关题目\n给一个数组，里面包含一个出现奇数次的数和其他出现偶数次的数，请你找出这个出现奇数次的数。 解法：定义一个变量 eor = 0; 然后与数组中的每一个数都异或，得到的结果就是出现奇数次的数。\n因为出现偶数次的数以及出现奇数次中的偶数部分异或之后都为 0，在异或一次出现奇数次的数就得到结果了。\n1 2 3 4 5 6 7 8 9 int oneOdd(int arr[], int length) { // 初始值为 0 int eor = 0; for (int i = 0; i \u0026lt; length; i++) { eor ^= arr[i]; } return eor; } 给一个数组，里面包含两个出现奇数次的数和其他出现偶数次的数，请你找出这两个出现奇数次的数。 解法：首先还是定义一个 eor = 0 ，先异或一遍数组，得到的结果是 eor = a ^ b; （假设这两个数是a和b，a != b），\n那么这两个数肯定有某个位置是不相同的，而这些位置在eor中就是1所在的位置。我们根据其中一个不相同的位置将数据划分为两个部分，定义一个变量 eor2 = 0 异或一遍其中一部分，得到的就是其中的 a 或 b，最后再把 eor ^ eor2 得到另一个数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int* twoOdd(int arr[], int length) { int eor = 0; for (int i = 0; i \u0026lt; length; i++) { eor ^= arr[i]; } int eor2 = 0; // 重要的一步，得到eor最右边为1的数。 int rightOne = eor \u0026amp; (~eor + 1); for (int i = 0; i \u0026lt; length; i++) { // 将每一个数都与 rightOne 按位与 // 如果那个位置是 0，则结果为 0，写 != 也是一样，目的是分开数据。 if ((arr[i] \u0026amp; rightOne) == 0) { eor2 ^= arr[i]; } } printf(\u0026#34;%d, %d\\n\u0026#34;, eor2, (eor ^ eor2)); } 假设第一次循环得到的eor是 1 0 0 1 0 0 ，int rightOne = eor \u0026amp; (~eor + 1); 这一步做的就是：\neor取反 0 1 1 0 1 1\n加一 0 1 1 1 0 0\n再和最初的eor相与 0 0 0 1 0 0 ，这样就得到了 a 和 b 最右边不相同位的数字。\n之后数组中每个数字都与这个数字相与，那么倒数第三位为 1 的就不为0，为0的就等于0，这样就把两种数字区分开了。\n4、二分查找 4.1、有序数组二分查找 对于有序数组，从从查找一个数字的位置可以使用二分查找的方法。\n第一步，设置left和right以及middle，middle就是left + right / 2，将要查找的值与第 middle 个值进行比较，如果要查的值比较小，就更新right，如果要查的值计较大，就更新left。最后再更新middle。\n然后一直重复上面的步骤，直到找到那个值的位置，或者left \u0026gt; right。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static int binarySearch(int[] arr, int value) { int left = 0; int right = arr.length - 1; while (left \u0026lt;= right) { int middle = (left + right) / 2; if (arr[middle] \u0026gt; value) { right = middle - 1; } else if (arr[middle] \u0026lt; value) { left = middle + 1; } else { return middle; } } return -1; } 4.2、二分查找的时间复杂度 二分查找的最复杂的情况就是查找到left \u0026gt; right，也就是 log(N)。因为每循环一次就去掉现有区域的一半。例如 8 4 2 1。\n4.3、扩展 给一个有序数组，查找大于x的最左侧的值的索引。 使用二分查找的思路就是，先用一个临时变量存储最接近目标值的索引，然后继续查找有没有更接近的，如果middle所指的值比指定的值要大，那么就更新临时变量，如果比指定值小（或相等），就不变。最后更新left，right，middle，直到left \u0026gt; right。\n与一般二分查找不同的是，这个二分查找一定要搜索到底。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public static int leftBinarySearch(int[] arr, int value) { int left = 0; int right = arr.length - 1; int res = right; while (left \u0026lt;= right) { int middle = left + (right - left) / 2; if (arr[middle] \u0026gt; value) { res = middle; right = middle - 1; } else { left = middle + 1; } } return res; } 找出（无序）数组中一个局部最小值。 如果第一个数字比第二个小，第一个值就是局部最小值。同理最后一个比倒数第二个小，也是局部最小值。\n第 i 个值小于第 i - 1 个，也小于 第 i + 1 个，他也是局部最小值。\n假如满足arr[0] \u0026lt; arr[1] 就返回零，否则查看 arr[N - 1] \u0026lt; arr[N - 2]，如果满足，返回 N - 1，否则进入下一步。\n如果上面两个都不满足，那么这个数组两端就是翘的，\\ ..... / ，其中肯定有局部最小值点。\n如果是 \\.../m/.../ 或者 \\.../m\\.../ ，如果左侧较小，那么左边肯定有最小值点如果右侧较小，右边肯定有最小值点，如果两个条件都没有满足，那么middle就是最小值点。\n1 // TODO ","date":"2022-11-14T15:45:35+08:00","permalink":"https://zhuaowei.github.io/article/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BB%8B%E7%BB%8D%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/","title":"算法复杂度介绍、三种常见排序算法以及二分查找算法"},{"content":"1、使用广播信道的数据链路层 1.1、局域网的数据链路层 局域网的主要特点：网络为一个单位所拥有，且地理范围和站点数据均有限。\n局域网的优点：\n具有广播功能。 便于系统的扩展和逐渐演变，各设备的位置可灵活调整。 提高了系统的可靠性（reliability）、可用性（availability）和生存性（survivability）。 局域网的分类：\n星形网 环形网 总线网 局域网主要使用双绞线作为传输媒体，因为便宜且传输速率也不错（10 Mbit/s ~ 10 Gbit/s）。当数据驴很高时，往往需要使用光纤。\n局域网包含物理层和数据链路层，因为它包含和很多数据链路层的内容，所以在这里说明。\n共享信道的划分方法：\n静态划分信道：就是使用各种信道复用技术。但是这种方法的代价比较高，不适合局域网。 动态媒体接入：又称多点接入（multiple access），特点是不把信道固定分给用户使用。又分为两类： 随机接入：所有用户随机发送信息，如果有两个用户同时发送就会发生碰撞（也叫冲突），导致所有人发送失败。所以必须要有解决碰撞的网络协议。 受控接入：用户必须服从一定的控制。典型代表有分散控制的令牌环局域网和集中控制的多点线路探询（polling），或者称为轮询。 1、以太网的两个标准\nDIX Ethernet V2：美国施乐公司和DEC、因特尔公司联合提出的第二版规约。\nIEEE 802.3：与上面的差别不大。为了适应更多局域网标准，把局域网的数据链路层拆成两个子层，逻辑链路控制 LLC（Logic Link Control）和 媒体接入控制 MAC（media Access Control）。\n随着互联网的发展，以太网称为局域网的代名词，互联网发展成 TCP/IP 体系， IEEE 802.3 协议的 LLC 子层的作用已经消失了，现在适配器也没有 LLC 协议。\n2、适配器的作用\n计算机与外接局域网的连接是通过通信适配器（adapter）进行的。原本是插在电脑主板上的一块网络接口板，也叫网络接口卡 NIC（Network Interface Card）或者简称为网卡。\n适配器包括处理器和存储器（RAM 和 ROM），与外部通过双绞线连接，与内部通过 I/O 总线方式传输。外部传输是串行的，内部传输是并行的，所以适配器的作用就是做串行和并行传输的相互转换。主板插上适配器后，驱动程序会告诉适配器在什么位置把多长的数据发送到局域网，或者在存储的什么位置把从局域网传输的数据存储下来，还要实现以太网协议。\n适配器使用字迹的处理器，当收到错误的帧时直接丢掉，当收到正确的帧时，通过中断通知计算机，交付协议栈中的网络层。同样，发送时，网络层将 IP 数据把发送给适配器组装成帧。\n适配器的硬件地址存储在 ROM 中，而计算机的 IP 地址则存储在计算机的存储器中。\n1.2、CSMA/CD 协议 CSMA/CD：载波监听多点接入/碰撞检测（Carrier Sense Multiple Access with Collision Detection）\n最早的以太网是总线形，一台主机通过广播发送给局域网的其他主机，其他主机通过对比数据中的硬件地址来判断是否是发给字节的，如果不是就丢弃。\n为了通信的简便，以太网采取了下面的措施：\n无连接的方式：不编号，也不需要对方发送确认。所以是尽最大努力交付，即不可靠交付。 数据使用 **曼彻斯特（Manchester）**编码。 CSMA/CD 的要点：\n多点接入：说明是总线形网络。 载波监听：检测信道，不管是发送前还是在发送中，每个站都必须不停地检测信道。如果有主机在发送，自己就暂时不发送。目的是及时发现本站与其他站的碰撞，这就是碰撞检测。 碰撞检测：边发送边监听。适配器边发送边检测信道上的电压，如果电压变化幅度超过一定的门限值，就认为有至少两个站在同时发送数据，发生了冲突，所以也叫冲突检测。发生冲突后，立即停止发送，然后等待随机时间后，再次发送。 碰撞传递\n当有两个站发送消息，在线路上发生了碰撞，当对方的消息到达自己站时才能检测到碰撞，检测到碰撞后立即停止发送。\n为什么发生发送前检测到没有在发送，还是会发生碰撞呢，原因是其他站发送的数据还没到本站，没有检测出；反之亦然。\n那么在本站开始发送数据后，最长多长时间能够检测到冲突呢，时间是 2t，t 为数据传送局域网最大线路的时间，2t 就是往返时间。\n这段时间被称为争用期，因为这段时间遇到碰撞是不确定的，也叫碰撞窗口。只有经过争用期还没有检测到碰撞的，才能肯定这次发送不会发生碰撞。\n碰撞延迟发送算法：截断二进制指数退避\n当发生碰撞后，发生碰撞的站不是等待信道空闲立即发送，而是等待一段随机时间。\n截断二进制指数退避：\n协议规定基本退避时间为争用期 2t，具体的时间是 51.2 微秒。 从整数集合 [0, 1, \u0026hellip;, (2 ^ k - 1)] 中随机选取一个数，记为 r。重传应推后的时间就是 r 倍的争用期。 $$ k = Min[重传次数, 10] $$\n当重传16次仍不能成功，则丢弃该镇，并向高层报告。 适配器每次发送一个帧都要执行CSMA/CD 协议，并且适配器对于发生的碰撞没有记忆。因此有可能新来的帧正好排到前面，抢到信道的发送权。\n争用期的时间正好够发送 64 字节数据，所以，如果发送成功，帧的大小一定是大于 64 字节的；反过来，站点收到小于64字节的帧都应该丢弃。\n强化碰撞：当发生碰撞后，除了立即停止发送数据，还要发送一个32比特或48比特的人为干扰信号，让所有用户都知道发生了碰撞。\n帧间最小间隔：规定帧间最小间隔时间为 9.6 微秒，相当于 96 比特时间，为了使收到帧的站点有时间处理接收缓存。\n总结：\n准备发送：适配器从网络层得到一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器缓存。发送前检测信道。 检测信道：一直检测信道，直到信道空闲，等待信道空闲 96 比特时间后，发送这个帧。 边发送边监听。 发送成功：在争用期内一直没有检测到碰撞，一定能发送成功。 发送失败：争用期内发生碰撞，停止发送，并发送人为干扰信号。执行指数退避算法，等待一定时间后，回到第 2 步。如果 16 次还不能成功，停止重传，并报告上层。 以太网每发送完一帧，一定要把已发送的帧暂时保留一下，以防争用期发生碰撞。\n1.3、使用集线器的星形拓扑 星形中心使用一台集线器（hub）。集线器的特点：\n逻辑上是总线网，各站共享逻辑上的总线，也是使用 CSMA/CD 协议。同一时刻最多只允许有一个站发送数据。 一个集线器有许多接口，像一个多接口的转发器。 集线器工作在物理层，仅简单地转发比特，不进行碰撞检测。 采用专门芯片，进行自适应串音回波抵消。消除强信号的干扰，发送前对每个比特进行再生整形并重新定时。 1.4、以太网的信道利用率 略\n1.5、以太网的 MAC 层 1、MAC 层的硬件地址\n硬件地址，也叫物理地址、MAC 地址（因为用在 MAC 帧中）。\n“名字指出我们要找的那个资源，地址指出那个资源在何处，路由告诉我们如何到达该处。”\n严格地讲，名字应当与系统的所在地无关。IEEE 802 规定了局域网使用一种 48 位的全球地址，是固化在局域网每一台计算机 ROM 中的地址。因此：\n适配器决定了计算机的物理地址，更换了适配器就更换了计算机的物理地址。 计算机的物理地址与所连的局域网，地理位置无关。 严格地讲，局域网的“地址”应当是每一个站的“名字”或标识符。而有些路由器、主机有多个适配器，那么就有多个物理地址，更严格地说，地址应当是某个接口的标识符。\nIEEE 802 规定地址应使用 6 字节（48位）或者 2 字节（12位）的，但是目前实际上用的是 6 字节的。\nIEEE 的注册管理机构 RA （Registration Authority） 是局域网全球地址的法定管理机构。6 字节地址的前 3 字节必须向其购买，这 3 个字节叫 组织唯一标识符OUI（Organization Unique Identifier），也叫公司标识符。后三位由公司自己分配，只要保证没有重复的地址即可，这 3 位叫 扩展的唯一标识符（Extend Unique Identifier）。\nIEEE 规定第一个字节的最低位为 I/G 位（Individual/Group）。当 I/G 位为 0 时，表示单个站地址；当 I/G 位 为 1 时，表示组地址，用来多播。\n地址的两种记法：\n每个字节的最低位写在左边，IEEE就是这样记得。 每个字节的最高位写在左边。 考虑到有人不想买，IEEE 规定第一字节的最低第二位为 G/L（Global/Local） 位，当 G/L 位为 0 时，表示全球管理；当 G/L 位为 1 时，表示本地管理。所有 2 字节都是本地管理。\n适配器的过滤功能：适配器根据 MAC 地址过滤是否是发往本站的帧。\n**单播（unicast）**帧：一对一。 目的地址与本站相同。 **广播（broadcast）**帧：一对全体。发给本局域网的所有人，地址全 1. **多播（multicast）**帧：一对多。发给本局域网的部分站。 所有的适配器都至少支持两种帧，即单播和广播。有的支持多播。\n混杂方式\n适配器还有一种混杂方式（Promiscuous mode），不管什么帧都收下来。\n缺点：会被黑客窃取数据。\n优点：方便网络维护管理人员监视，分析网上的流量。嗅探器也使用这种适配器，方便人们学习网络协议的原理。\n2、MAC 帧的格式\n以太网有两种标准，一种是DIX Ethernet V2，一种是 IEEE 802.3，用的最多是 V2 版本。\nV2 的 MAC 帧由 5 个字段构成，64 ~ 1518字节。\n目的地址，6 字节。 源地址，6 字节。 上层协议类型，2 字节。 数据部分。46 ~ 1500 字节（因为 MAC 帧至少 64 字节，除去数据部分有 18 字节）。 帧检验序列 FCS（CRC 校验），4 字节。 物理层在发送时还要再在头部添加 8 字节（硬件产生），目的是同步适配器的时钟，防止整个帧废掉。\n这 8 个字节由 2 个字段构成：\n前同步码，7 字节。1、0交替码，目的是使适配器的时钟与发送段同步。 帧开始定界符，1 字节，定义为 10101011。 以太网不需要使用帧结束定界符，也不需要字节插入保证透明传输。\n无效的 MAC 帧（满足下列任意一种情况）：\n帧长度不是整数字节。 FCS 检验出差错。 数据长度不在 46 字节和 1500 字节之间。 无效的帧直接丢弃，以太网不负责重传丢弃的帧。\n","date":"2022-11-09T21:46:48+08:00","permalink":"https://zhuaowei.github.io/article/%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","title":"使用广播信道的数据链路层"},{"content":"数据链路层主要有两种通信方式：\n点对点信道：一对一，点对点通信方式。\n广播信道：一对多的广播通信方式。\n1、使用点对点信道的数据链路层 1.1、数据链路和帧 链路（link，物理链路）：从一个结点到相邻结点的一段物理通路（有线或无线），而中间没有任何其他交换结点。\n数据链路（data link， 逻辑链路）：除了必须有一条物理线路外，还必须有一些必要的通信协议来控制这些数据的传输。实现协议的软硬件加到链路上，就构成了数据链路。\n通常用网络适配器（既有软件，也有硬件）来实现这些协议，包括数据链路层和物理层的功能。\n规程（procedure）：早期通信协议的叫法，在数据链路层，这俩是同义词。\n帧：点对点信道的数据链路层的协议数据单元。\nIP数据报（数据报、分组、包）：网络层的协议数据单元。\n通信步骤：\nA 的数据链路层将网络层交下来的 IP 数据报添加首部和尾部封装程帧。 结点 A 把封装好的帧发送给结点 B 的数据链路层。 若 B 的数据链路层收到的帧无差错，从帧中提取出 IP 数据报交给网络层；否则丢弃这个帧。 1.2、三个基本问题 三个基本问题：封装成帧、透明传输和差错检测。\n1、封装成帧\n在一段数据的前后分别添加首部和尾部。在传输比特流时，数据链路层就能根据首部和尾部的标记识别出报文的开始和结束，这也是首部和尾部最重要的作用——帧定界。\nMTU（Maximum Transfer Unit）：最大传输单元，数据链路层规定了传送的帧的数据部分长度上限。\n当数据是由可打印的 ASCII 码组成的文本文件是，帧定界可以使用特殊的帧定界符。\nASCII 码由 7 bit 表示，一共由 128 个字符，其中包括 95 个可打印字符，33 个不可打印字符。\n**控制字符 SOH（Start Of Header， 十六进制是 0X01）放在一帧的最前面，表示帧的首部开始。另一个控制字符EOT（End Of Transmission，十六进制是 0X04）**表示帧的结束。\n2、透明传输\n因为帧的开始和结束标记使用的专门的字符，所以在报文中间任何 8 bit的组合都不允许出现和开始结束标记一样的编码。\n如果传输的内容是由键盘输入的，那么永远都不会出现开始结束标记，永远可以放在真中传输，这样的传输就是透明传输，也叫无差错传输（原样传输）。\n如果传输的是二进制编码或者图像，那么就有可能出现开始和结束的字符，这样的传输就不是透明传输。\n透明：表示一个实际存在的事物看起来却好像不存在一样，例如玻璃。在数据链路层透明传输意思就是，无论什么样的数据都能够无差错地原样通过这个数据链路层。\n转义字符\n为了解决报文中可能出现的控制字符，就需要对出现开始结束控制字符进行转义，在SOH和EOT前面插入一个转义字符 “ESC”（十六进制是0X1B）。接收端的数据链路层在上交网络层之前将转义字符 ESC 删去。这种方法称为字节填充（byte stuffing）或字符填充（character stuffing）。\n如果转义字符也出现在数据中，就在转义字符前面再加一个转义字符。接收端收到两个转义字符就删除前面的一个。\n3、差错检测\n比特差错：在传输中，0 可能会变成 1，1 也有可能变成0。\n误码率 BER（Bit Error Rate）：传输错误的比特数占总数的比率。\n误码率和信噪比有很大关系，提高信噪比可以降低误码率。\n比特差错是无法避免的，目前数据链路层广泛试用了循环冗余检验 CRC（Cyclic Redundancy Check）。\n检测原理：在发送端将要发送的数据分组，每组 k 个比特。假设要发送的数据是M（k bit），就在数据的末尾添加一个 n 位的冗余码，所以一共要发送 （k + b）比特。\n计算过程：首先在数据 M 末尾补上 n 个 0，用二进制的模 2 运算进行计算。得到的（k + n）位的数除以双方实现商定的长度位 （n + 1）位的除数 P得出的商是 Q，而余数 R 是 n 位的。\n模 2 运算：加法和减法一样，不进位。1111 + 1010 = 0101。\n计算出的 余数 R 作为帧检测序列 FCS（Frame Check Sequence），添加到数据的末尾发送出去。FCS 就是冗余码。\n检测方法：接收端把接受到的每一个帧都除以同样的除数 P（模 2 运算），然后检查得到余数 R。如果传输过程中没有差错，那么经过 CRC 检验后，得到的余数是 0。\n如果出现差错，得到的余数还是 0 的概率是非常非常小的。\n如果接收的帧是有差错的，那么数据链路层就会丢弃这个帧，换句话说，凡是接收的帧，我们都能以非常接近 1 的概率认为这些帧在传输过程中无差错。\n可靠传输：依靠上面的差错检测，并不能做到可靠传输，因为差错并不是只有比特差错一种，还有可能是另一种差错，即帧丢失、帧重复和帧失序。\n在过去，为了保证数据链路层上交的数据是可靠的，对于发送方发送的数据，数据链路层在 CRC 的基础上，增加了帧编号、确认和重传机制。数据链路层的发送方对于发送的每一个帧都要求接受方在一定时间内给出确认，否则就认为传输出现了差错，因而进行重传，直到收到确认为止。\n现在网络质量大大提高，出现伤处差错的情况很少见，因此互联网采取了区别对待的情况：对于质量良好的网络，不要求数据链路层向上层提供可靠传输的服务，即不使用确认和重传机制，可靠传输由上层协议实现（例如 TCP 协议）；对于质量较差的网络，数据链路层向上提供可靠的传输服务，即使用确认和重传机制。\n2、点对点协议 PPP 点对点协议 PPP（Point-to-Point Protocol）：是目前使用最广泛的数据链路层协议。\n2.1、PPP 协议的特点 PPP 协议就是用户计算机和 ISP 进行通信时使用的数据链路层协议。\n1、PPP 协议应满足的需求\n简单：对数据链路层的帧，不需要纠错，不需要序号，也不需要流量控制。首要的要求就是”简单“。 封装成帧：必须使用特殊的字符作为帧定界符，便于接收端准确判断帧的开始和结束位置。 透明性：如果数据中碰巧出现帧定界符的比特组合，就要采取有效的措施解决。 多种网络协议：必须在同一物理链路上同时支持多种网络层协议。 多种类型链路：必须能在多种类型的链路上运行。 差错检测（error detection）：必须能对接收端收到的帧进行检测，并立即丢弃有差错的帧。 检测连接状态：必须有一种机制能够及时（不超过几分钟）自动检测出链路是否处于正常状态。 最大传送单元：必须对每一种点对点的链路设置最大传送单元 MTU 的默认值。 网络层地址协商：必须提供一种机制使通信的两个网络层的实体能够通过协商或能够配置彼此的网络层地址。 数据压缩协商：必须提供一种方法来协商使用数据压缩算法。但并不要求将数据压缩算法进行标准化。 在 TCP/IP 协议族中，可靠传输由运输层的 TCP 协议负责，因此 PPP 协议并不需要进行纠错，不需要设置序号，也不需要进行流量控制。\nPPP 协议只支持点对点的链路通信，且只支持双全工通信。\n2、PPP 协议的组成\n一个将 IP 数据报封装到串行链路的方法。 一个用来建立、配置和测试数据链路连接的链路控制协议 LCP（Link Control Protocol）。 一套网络控制协议 NCP（Network Control Protocol），其中的每一个协议支持不同的网络层协议，如 IP、OSI 的网络层、DECnet、AppleTalk等。 2.2、PPP 协议的帧格式 1、各字段的意义\nPPP 的帧格式由首部和尾部组成，分别有 4 个字段和 2 个字段。\n1 2 3 4 先发送 | F | A | C | 协议 | 信息部分 | FCS | F | | 7E | FF | 03 | | 信息部分 | | 7E| | \u0026lt;------- 首部 -------\u0026gt; | IP 数据报 | 尾部 | 首部\nF（Flag）：1 字节，标志字段，开始帧定界符，规定为 0X7E。和结束帧定界符一样，表示帧的开始或结束。 A（Address）：1 字节，地址字段，规定为 0XFF。 C（Control）：1 字节，控制字段，规定为 0X03。A、C 两个字段实际上并没有携带 PPP 帧任何信息。 协议：2 字节。如果为 0X0021，信息部分就是 IP 数据报；如果是 0XC021，信息字段就是 PPP 链路控制协议 LCP 的数据；如果是 0X8021 ，就是网络层的控制数据。 尾部\nFCS：使用 CRC 的帧检验序列 FCS。 F（Flag）：1字节，标志字段，同开始帧定界符。 信息部分：长度是可变的，不超过 1500 字节。\n2、字节填充\n当信息字段中出现和标志字段（0X7E）一样的比特组合时，就必须采取一些措施使这种形式上可标志字段一样的比特组合不出现在信息字段中。\n当 PPP 使用异步传输时，把转义字符定为 0X7D（01111101），并使用字节填充。\n0x7E -\u0026gt; 0x7D,0x5E 0x7D -\u0026gt; 0x7D,0x5D ASCII 码中的控制字符（小于 0x20 的字符），在前面加一个转义字符 0x7D，并改变编码。例如 0x03 -\u0026gt; 0x7D,0x23。 由于在发送段进行了字节填充，在链路上传输的字节数就超过了原来的字节数。在接收端收到数据之后，进行与发送端相反的操作，就恢复出了原来的信息。\n3、零比特填充\nPPP 协议在 SONET/SDH 链路时，使用同步传输而不是异步传输，这中情况下使用零比特填充实现透明传输。\n同步传输：一连串的比特连续传送。\n异步传输：逐个字符地传送。\n实现方法\n发送端：先扫描整个信息字段，只要发现有 5 个连续 1，就立即填入一个0。\n接收端：先找到标志字段 F以确定一个帧的边界，然后扫描其中的比特流，当发现 5 个连续 1 时，就删除后面的一个 0。\n2.3、PPP 协议的工作状态 PPP 链路的初始化：当用户拨号接入 ISP 后，就建立了一条从用户隔热电脑到 ISP 的物理层连接。之后用户电脑向 ISP 发送一系列链路控制协议 LCP 分组（封装成多个 PPP 帧），以便建立 LCP 连接。这些分组及响应选择了将要使用的一些 PPP 参数。\n接下来还要进行网络层的配置，网络控制协议 NCP 给新接入的用户电脑分配一个临时的 IP 地址。这样用户电脑就称为互联网上一个有 IP 地址的主机了。\n当用户通信完毕时，NCP 释放网络层连接，收回分配出去的 IP 地址。接下来，LCP 协议释放数据链路层连接，最后释放的时物理层的连接。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 +----------------------------\u0026gt; 链路静止 设备之间无链路 | / | | | | | 物理层连接建立 | LCP 链路终止 LCP 配置 V V ^ 协商失败 \u0026lt;--------- 链路建立 物理链路 | | LCP 配置协商 | | 鉴别失败 V V 链路终止 \u0026lt;------------------------- 鉴别 LCP 链路 ^ | 鉴别成功或无须鉴别 | | V V | 网络层协议 已鉴别的 LCP 链路 链路故障或关闭请求 | | | | NCP 协商 | | V V +---------------------------- 链路打开 已鉴别的 LCP 链路 和 NCP 链路 PPP 链路的起始和终止状态永远是链路静止，这时用户电脑和 ISP 的路由器之间并不存在物理层的连接。\n当用户电脑通过调制解调器呼叫路由器时，路由器就能检测到其发出的载波信号，双方建立了物理连接后，PPP 就进入了**链路建立（Link Establish）**状态，目的是建立链路层的 LCP 连接。\n这时 LCP 开始协商一些配置选项，即发送 LCP 的配置请求帧（Configure-Request）。这时一个 PPP 帧，其协议字段是 LCP 对应的代码，信息字段包含特定的配置请求。另一端可以发送以下几种响应的一种：\n配置确认帧（Configure-Ack）：所有选项都接受。 配置否认帧（Configure-Nak）：所有选项都理解，但不能接受。 配置拒绝帧（Configure-Reject）：选项有些无法识别或不能接受，需要协商。 LCP 配置选项包括：链路上的最大帧长、所使用的鉴别协议（authentication protocol）（如果有），以及不适用 PPP 帧中的地址和控制字段（因为是固定的，且没有任何意义）。\n协商结束后双方就建立了 LCP 链路，接着就进入了**鉴别（Authenticate）状态。这一状态中，只允许传送 LCP 协议的分组、鉴别协议的分组以及监测链路质量的分组。若鉴别失败，则转到链路终止（Link Terminate）状态。若鉴别成功则进入网络层协议（Network-Layer Protocol）**状态。\n鉴别协议：可以使用 口令鉴别协议 PAP（Password Authentication Protocol），如果为了更好的安全性，可以使用更复杂的 握手鉴别协议（Challenge-Handshake Authentication Protocol）。\n鉴别由发起通信的一方发送身份识别表示符和口令，系统允许用户重试若干次。\n在网络层协议状态，PPP 链路的两端的网络控制协议 NCP 根据网络层的不同协议互相交换网络层特定的网络控制分组。\n因为现在的路由器支持多种网络层协议，所以这个步骤很重要。虽然两端使用不同的网络测协议，但是仍然可以使用同一个 PPP 协议进行通信。\n如果 PPP 链路上运行的是 IP 协议，则 PPP 链路的每一端配置 IP 协议模块（如分配 IP 地址）时就要使用 NCP 中支持 IP 的协议——IP 控制协议 IPCP（IP Control Protocol）。IPCP 协议也封装成 PPP 帧在链路上传送，其协议字段为 0x8021。\n在低速链路上运行时，双方还可以协商使用压缩的 TCP 和 IP 首部，减少在链路上发送的比特数。\n当网络层配置完成后，链路就进入可进行数据通信的链路打开（Link Open）状态。这时，链路的两个 PPP 端点可以互相发送分组，还可以发送回送请求 LCP 分组（Echo-Request）和回送回答 LCP 分组（Echo-Reply），以检查链路的状态。\n数据传输结束后，可以有链路的一端发出终止请求 LCP 分组（Terminate-Request）请求终止链路连接，在收到对方发来的终止确认 LCP 分组（Terminate-Ack）后，转到链路终止状态，如果链路出现故障，也会从链路打开转到链路终止。当调制解调其的载波停止后，则回到链路静止状态。\n","date":"2022-11-04T21:20:42+08:00","permalink":"https://zhuaowei.github.io/article/%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AE-ppp/","title":"点对点协议 PPP"},{"content":"1、TCP 的运输连接管理 TCP 是面向连接的协议，连接建立和连接释放是每次面向连接通信必不可少的过程。运输连接有三个阶段：连接建立、数据传输和连接释放。TCP 连接建立要解决以下三个问题：\n要是每一方能够确知对方的存在。 允许双方协商一些参数。 能够对运输实体资源进行分配。 TCP 连接采用客户服务器方式。主动发起连接建立的应用进程叫作客户（client），而被动等待连接建立的应用进程叫作服务器（server）。\n1.1、TCP 连接的建立（三次握手） TCP 建立连接的过程叫作握手，握手需要在客户和服务器之间交换三个 TCP 报文段。\n1 2 3 4 5 6 A | | B Client | ---------------- SYN = 1, seq = x ----------------\u0026gt; | Server | | | \u0026lt;----- SYN = 1, ACK = 1, seq = y, ack = x + 1 ----- | | | | -------- ACK = 1, seq = x + 1, ack = y + 1 --------\u0026gt;| 上述过程中，A 主动打开连接，B 被动打开连接。\n1、连接建立之前\nB 的 TCP 服务器进程先创建传输控制块 TCB，准备接受客户进程的连接请求，然后服务器进程就处于 LISTEN 状态。\n传输控制块 TCB：存储了每一个连接中的重要信息。\nA 的 TCP 客户进程也是首先创建传输控制模块 TCB。然后就可以发送 TCP 连接建立请求。\n2、连接建立过程\n第一次握手：A 发送一个连接请求报文 SYN = 1, seq = x。TCP 规定：SYN 报文段不能携带数据，但是要消耗一个序号。发送完成后，A 进入 SYN-SNET 状态（同步已发送）。\n第二次握手：B 收到请求报文后，如果同意请求，就发送一个确认报文 SYN = 1, ACK = 1, seq = y, ack = x + 1。这个报文也属于 SYN 报文，也不能携带数据，确认号 ack = seq + 1，也要选择一个自己的确认号。发送完确认报文后，B 进入 SYN-RCVD 状态（同步收到）。\n第三次握手：A 收到 B 的确认报文后，也需要给出确认 ACK = 1, seq = x + 1, ack = y + 1。ACK 报文可以携带数据，如果不携带数据，则不消耗序号。这时 A 进入ESTABLISHED 状态（连接确认）。\nB 收到 A 的确认后，也进入 ESTABLISHED 状态.\nB 发送给 A 的确认报文可以分为两次发送，这样就是四次握手，但本质上没有区别。\n两次报文分别是：ACK = 1， ack = x + 1 和 SYN = 1, seq = y。\n3、为何要第三次握手？\n假设 A 发送了一次连接请求，这个请求不幸丢失了，那么 A 就会再次发送请求，B 收到后给出确认，之后正常进行，没有什么问题。但是，如果 A 的第一次连接在网络中长时间滞流，滞留到 A 的第二次连接已经完成数据传送，并且释放掉了，这时第一次的连接请求才来到 B。如果不采用第三次握手，B 给出确认就建立了连接，但是 A 并没有要建立连接，B 就一直等待数据传送，白白浪费了资源。如果采用第三次握手，A 不会向 B 的第二次连接请求确认发出确认。\n1.2、TCP 的连接释放（四次挥手） 1 2 3 4 5 6 7 8 9 A | | B Client | -------------- FIN = 1, seq = u --------------\u0026gt; | Server | | | \u0026lt;------- ACK = 1, seq = v, ack = u + 1 -------- | 立即发送 | | | \u0026lt;--- FIN = 1, ACK = 1, seq = w, ack = u + 1 --- | | | | ------- ACK = 1, seq = u + 1, ack = w + 1 ----\u0026gt; |CLOSED | | 在连接释放之前，A、B 都处于连接建立状态。\n1、释放连接过程\n第一次挥手：A 发送请求释放连接报文 FIN = 1, seq = u。此时 A 进入 FIN-WAIT-1 状态（终止等待1），也不再发送数据。\n第二次挥手：B 收到 A 的连接释放报文段后立即发出确认 ACK = 1, seq = v, ack = u + 1。报文的序号 v 是前面已传送过数据的最后一个字节的序号加 1。此时 B 进入CLOSE-WAIT 状态（关闭等待），B 仍然可以向 A 发送数据，TCP 处于**半关闭（half-close）**状态。\nA 收到确认报文后，进入 FIN-WAIT-2 状态（终止等待2）。\n第三次挥手：B 确定没有数据要向 A 发送了，应用进程就通知 TCP 释放连接。这时 B 发出连接释放报文 FIN = 1, ACK = 1, seq = w, ack = u + 1。报文确认号必须还是上次的 ack = u + 1，这时 B 进入 LAST-ACK 状态（最后确认）。\n第四次挥手：A 在收到 B 的连接释放报文后，必须对此发出确认 ACK = 1, seq = u + 1, ack = w + 1。然后进入 TIME-WAIT 状态（时间等待）。TCP 连接现在还没有释放，必须经过**时间等待计时器（TIME-WAIT timer）**设置的时间 2MSL 后，A 才进入 CLOSED 状态。\nMSL（Maximum Segment Lifetime）：最长报文段寿命，RFC 793 建议设为 2 分钟。\n所以 A 要经过 4 分钟才能进入 CLOSED 状态，当 A 撤销相应的传输控制块 TCB 后，就结束了这次的 TCP 连接。\n2、为什么 TIME-WAIT 状态要等待 2MSL？\n第一，为了保证 A 发送的最后一个 ACK 报文能够到达 B。如果 最后一个 ACK 报文丢了，B 就会重发第三次握手的报文，A 收到报文后再次发送 ACK 报文，并重设 2MSL 计时器。如果不设置这个计时器，A 就无法收到重发的报文，也就不会重发确认报文，B 最终无法正常进入 CLOSED 状态。\nB 一旦收到 A 的确认报文就进入了 CLOSED 状态，并且撤销相应的传输控制块 TCB。\n第二，防止已失效的报文出现在本连接中。A 发送完最后一个 ACK 报文后，再经过 2MSL 的时间，就可以使本连接中出现的所有报文都从网络中消失。\n3、保活计时器 keepalive timer\n为什么设置这个计时器呢？防止在连接建立后，客户端突然噶了，服务器就不能收到客户发来的数据，于是白白等待下去。\n服务器每次收到客户发来的数据，就会重置一下保活计时器。保活计时器的时间通常设置为 2 小时，2 小时过后，服务器还是没有收到客户端的数据，就发送一个探测报文，之后每个 75 秒发送一次，一共连发 10 次，10 次之后还是没有回应，就认为客户端噶了，于是关闭这个连接。\n等了两个小时，还要每隔 75 秒发送一次消息，还连发 10 次，真的“他温我哭”。\n","date":"2022-11-01T16:38:24+08:00","permalink":"https://zhuaowei.github.io/article/tcp-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/","title":"TCP 的三次握手和四次挥手"},{"content":"1、TCP 的拥塞控制 1.1、拥塞控制的一般原理 1、拥塞的定义\n拥塞（congestion）：网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。\n拥塞是一个复杂的问题，它并不是增加某一个资源就能解决的。\n2、造成拥塞的因素\n某个节点的缓存容量不足，无法暂存分组，只得丢弃分组。 节点的处理机的处理速度太慢。 输出链路的容量不足。 只提高上面某一项资源是不足以解决拥塞问题的。例如只增大缓存容量，到达节点的分组会逐渐增多，不过不增大处理速度和输出容量，缓存迟早会占满。另外两项同理。\n拥塞还有一个特点，就是常常会趋于恶化。例如，某个分组因拥塞而被丢弃，那么发送方就会重传这一分组，可能还会重传多次。\n3、拥塞控制\n拥塞控制：防止过多的主矩注入到网络中，这样可以是网络中的路由器或链接不致过载。即网络能够承受现有的网络负荷。\n拥塞控制和流量控制的区别：\n流量控制是端到端的通信量的控制，只涉及发送和接收两方的主机。\n拥塞控制是一个全局性的过程，涉及到网络中所有的主机，路由器等与拥塞有关的因素。\n4、负载与吞吐量的关系\n提供的负载（offered load）：单位时间内输入给网络的分组的数量。\n吞吐量（throughput）：单位时间内从网络输出分组的数量。\n理想状态下，在某一限度内，吞吐量和负载是相等的，当超过一定限度，吞吐量就会达到饱和，不再变化。\n实际上，不设置拥塞控制的情况下，在网络还未到达所说的限度时，就已经开始拥塞，即输入的负载大于输出的吞吐量。当吞吐量明显小于理想的吞吐量时，网络就进入了轻度拥塞状态。当提供的负载达到某一数值时，吞吐量不增反降，网络就进入到了拥塞状态。当负载继续增大，直到吞吐量下降到零，网络就进入到了死锁状态。\n在有拥塞控制的网络中，吞吐量会随着提供的负载增大而增大，但永远不会到达理想的吞吐量。\n5、拥塞控制的设计\n拥塞控制有两种方法，开环控制和闭环控制。\n开环控制：实现将所有的拥塞的因素都考虑到，避免发生拥塞，一旦整个系统运行，就不再中途修改。\n闭环控制：基于反馈环路的概念，主要有以下几种措施：\n监测网络系统，以便检测拥塞何时，何处发生。 把拥塞发生的信息传送到可采取行动的地方。 调整网络系统的运行以解决出现的问题。 为了监测网络拥塞，需要选择一些指标，例如丢弃分组的百分比，平均分组时延，平均队列长度，超时重传的分组数等等。\n一般会将拥塞的信息传送到产生分组的源站，但这会加剧拥塞，另一种方式是在转发分组保留一个字段或比特，表示是否产生拥塞。还可以由一些主机和路由周期性地发出探测分组，询问是否发生拥塞。\n1.2、TCP 的拥塞控制方法 TCP 使用四种拥塞控制算法：慢开始（slow-start），拥塞避免(congestion avoidance)，快重传（fast retransmit），快恢复（fast recovery）。\n现在假设：数据传输是单方面的，接收方有充足空间接收数据，发送窗口由拥塞程度决定。\n1、慢开始和拥塞避免\n拥塞窗口cwnd（congestion window）：发送方维持的一个状态变量，取决于网络的拥塞程度，并动态变化。因为接收方的空间无限大，所以就让发送方的发送窗口等于拥塞窗口。\n如何判断网络是否发生拥塞？依据就是出现超时。\n慢开始：刚开始发送的时候，并不知道网络的状况，为了防止数据输入过多而发生拥塞，就先试探一下，即由小到大逐渐增大发送窗口，也即由小到大逐渐增大拥塞窗口的数值。\nSMSS（Sender Maximum Segment Size）：发送方最大发送报文段。\n拥塞窗口的单位是字节，这里为了方面说明，将 SMSS 作为拥塞窗口的单位\n在刚开始发送时，把初始拥塞窗口设置为 1 至 2 个 SMSS。新规定是不超过 2 - 4 个 SMSS。\n若 SMSS \u0026gt; 2190 字节：不得超过 2 个 SMSS。 若 SMSS \u0026gt; 1095 字节：不得超过 3 个 SMSS。 若 SMSS \u0026lt;= 1095 字节：不得超过 4 个 SMSS。 每收到一个对新的报文段的确认后，就可以把拥塞窗口增加最多一个 SMSS 的数值。 $$ 拥塞窗口 cwnd 每次的增加量 = min(N, SMSS) $$ N 是原先未被确认、但现在被刚收到的确认报文所确认的字节数。\n每经过一个传输轮次，拥塞窗口 cwnd 就加倍。\n1 2 3 4 5 6 7 8 9 10 11 发送方 接收方 cwnd = 1 | | | ----------------------------\u0026gt; | 传输 1 个报文 | \u0026lt;---------------------------- | 轮次1 cwnd = 2 | | ----------------------------\u0026gt; | 传输 2 个报文 | \u0026lt;---------------------------- | 轮次2 cwnd = 4 | | ----------------------------\u0026gt; | 传输 4 个报文 | \u0026lt;---------------------------- | 轮次3 cwnd = 8 慢开始门限（ssthresh）：为了防止拥塞窗口增长过大而引起网络拥塞，需要设置一个慢开始门限。\ncwnd \u0026lt; ssthresh：使用慢开始算法。 cwnd \u0026gt; ssthresh：停止使用慢开始算法，使用拥塞避免算法。 cwnd = ssthresh：即可使用慢开始算法，也可使用拥塞避免算法。 2、拥塞避免\n拥塞避免是让拥塞窗口缓慢增大，每经过一个往返时间 RTT 就把发送方的拥塞窗口加 1（加法增大）。\n当网络中出现超时，发送方判断为网络拥塞。于是调整门限值 ssthresh = cwnd / 2，同时设置拥塞窗口 cwnd = 1，进入慢开始阶段。\n3、快重传\n当发送方连续收到 3 个来自同一报文的确认时，说明不是网络发生了拥塞，而是自己发送的报文丢失了，需要尽快重传。\n快重传要求接收方要立即发送确认，即使收到的报文是失序的，不能等到发送数据时捎带确认。\n4、快恢复\n当发送方收到了上面情况的报文，发送方就知道只是丢失了个别的报文，于是就执行快恢复算法。调整门限值 ssthresh = cwnd / 2，同时设置 cwnd = ssthresh，并开始拥塞避免算法。\n从上面可以看出，拥塞避免阶段拥塞窗口值是线性增长，也叫加法增大AI（additive Increase）。而一旦超时或者收到 3 个重复确认就要降低门限值为原来的一半，并大大减小拥塞窗口的值，这也叫乘法减小MD（Multiplication Decrease）。\n上面的算法是假设接收方有足够的空间接收报文段，只考虑了拥塞窗口。现实情况下，发送方的发送窗口也不能超过接收方给出的接收窗口值 rwnd。所以： $$ 发送窗口的上限值 = Min[rwnd, cwnd] $$\n1.3、主动队列管理 AQM 网络层采取的策略与 TCP 拥塞控制的关系：如果网络中某一个路由器的处理时间特别长，导致这个啊勃文超时重传，TCP 就认为网络中发生了拥塞，实际上并没有。\n尾部丢弃策略（tail-drop policy）：路由器按照先进先出的规则处理收到的分组，如果队列已经满了，那么排在队列尾部的分组就会被丢弃。\n如果采用尾部丢弃策略，丢弃尾部往往会导致一连串分组的丢失，发送方的 TCP 就会进入慢开始状态。如果尾部丢弃一下导致很多 TCP 连接进入慢开始状态，这种情况被称为全局同步（global synchronization）。网络恢复后，通信量会突然大增。\n为了避免全局同步现象，提出了 主动队列管理AQM（active Queue Management）。在队列出现某种拥塞征兆时就主动丢弃到达的分组。实现方法有很多，流行的是随机早期检测RED（Random Early Detection）。\n实现 RED 要维持两个变量：队列长度最小门限和最大门限。当分组到达时：\n若平均队列长度小于最小门限，新到的分组入队。 若平均队列长度大于最大门限，新到的分组丢弃。 若平均队列长度在最小门限和最大门限之间，按照某一丢弃概率 p 丢弃。（随机性） 最难处理的就是概率 p 的选择，对于每个分组都要计算丢弃概率 p。\n事实证明 RED 效果不太理想，但是 AQM 是必要的，代替 RED 的算法都正在实验中。\n","date":"2022-11-01T16:38:20+08:00","permalink":"https://zhuaowei.github.io/article/tcp-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/","title":"TCP 的拥塞控制"},{"content":"1、TCP 的流量控制 1.1、利用滑动窗口实现流量控制 1、接收窗口\n流量控制（flow control）：就是让发送方的发送速率不要太快，要让接收方来的及接收。\n区别于拥塞控制：流量控制是点对点的，发送和接收双方的传送速率控制；而拥塞控制是设计到整个网络的，是限制发送速率，防止短时间有大量数据传送进网络，避免整个网络发生拥塞。\n假设 A 向 B 发送数据，在连接建立时，B 发送给 A 的确认报文中包含了一个接收窗口的大小 rwnd = 400，这个值告诉 A 我还有多少字节空间可以接收数据。因此，发送方 的发送窗口不能超过接收方给出的接收窗口的数值。\n接收窗口的单位是字节。 只有 ACK = 1 的确认报文才有效。 当接收窗口的值为 0 时，发送方就不允许发送了，发送方会一直暂停发送，直到接收方发来接收窗口不为 0 的报文。\n2、持续计时器 persistence timer\n当发送方收到了零窗口报文后就停止发送了，过了一段时间后，接收方有空间接收报文，就发送了一个非零窗口报文，恰巧这个报文丢失了，那么就会发生死锁，双方会一直等待。\n为了解决上面的问题，TCP 设置了一个持续计时器（persistence timer），只要发送方收到了接收方发送过来的零窗口报文，就会启动这个计时器，计时器到期后，发送方就会发送一个探测报文段（仅有 1 字节数据）。接收方收到这个报文会给出一个确认报文，如果窗口值不为零，那么发送方就可以发送数据了；如果仍然为零，那么发送方在接收到这个报文时就会重设持续计时器。\n1.2、TCP 的传输效率 1、TCP 报文发送时机\n最大报文段长度MSS（Maximum Segment Size）:TCP 维持的一个变量。\n应用进程将数据传送到 TCP 的发送缓存后，TCP 有三种机制控制发送时机：\n只要缓存中存放的数据达到 MSS 字节时，就组装成一个报文发送出去。 由发送方的应用程序指明要求发送报文段，即 TCP支持**推送（push）**操作。 发送方的一个计时器期限到了，这时就把已有的缓存数据装入报文段（长度不超过 MSS）发送出去。 2、Nagle 算法\n若发送方的应用程序把要发送的数据逐个字节地发送到 TCP 的发送缓存中，那么发送方就把第一个字节先发送出去，把剩下的字节缓存起来。当发送方收到第一个字节的确认后，再把剩下的缓存中的数据组装成一个报文发送出去，接着对随后到达的数据进行缓存，同时等待确认，发送下一个报文。当数据到达较快而网络速率较慢时，用这样的方法可明显减少所用的网络带宽。\n当到达的数据已达到发送窗口的一般或已达到报文段的最大长度时，就立即发送一个报文段，这样做，就可以有效地提高网络的吞吐量。\n3、糊涂窗口综合征（silly window syndrome）\nTCP 的接收窗口已满，而交互式的进程一次只从接收缓存读取 1 个字节，然后发送确认，把窗口值设置为1；发送方再发送一个 1 字节的报文，这样会使网络的效率变得很低。（20字节IP数据报头部，20字节TCP数据报头部，只携带1字节数据，而且确认报文也是如此，40字节头部，不包含数据）\n解决方法：接收方等待一段时间，等到接收缓存有空间容纳一个最大长度的报文段，或者等到接收方的缓存有一半空闲，这个时候就可以向发送方发送确认报文，告知自己的接收窗口大小。此外，发送方也不要发送太小的报文段，等累积到足够大的报文段或者达到发送缓存的一半大小再发送。\n","date":"2022-11-01T12:49:44+08:00","permalink":"https://zhuaowei.github.io/article/tcp-%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/","title":"TCP 的流量控制"},{"content":"1、TCP 可靠传输的实现 为了方便描述，假定数据传输只有一个方向。A 发送数据，B 发送确认。\n1.1、以字节为单位的滑动窗口 1、发送窗口\n假如 A 收到了 B 发来的确认报文，报文内容是：ack = 31, rwnd = 20，这说明：B 已经收到了序号为 30 之前的报文了，期待发送的是序号为 31 的报文，窗口大小是 20，也就是 A 能发送序号为 31 - 50 的报文，这个范围就是 A 的发送窗口。\n发送窗口里是允许发送且不需要确认的报文，这些报文在没有收到确认之前都要保留，以防超时重发。\n收到确认报文后，确认序号前的报文就都可以释放了，然后 A 的发送窗口就可以向前移动，但是不能超过 B 的窗口值。\n接收方也有一个接收窗口，接收窗口和发送窗口是一样的，接收方只对按序到达的最后一个报文发送确认。\n例如：接收方发送了 ack = 31, rwnd = 20，此时接收窗口就是 31 - 50，31 之前的已经交付给主机并释放掉了。这是 A 发来了序号为 32， 33，的报文，B 不能发送 ack = 34 的报文，只能发送 ack = 31 的报文，因为他们不是按序到达的。如果 A 又发来了序号为 31，37， 38， 40的报文，B 可以发送 ack = 34 的报文。当 A 收到这个确认报文后就可以将发送窗口向前移动 3 个位置了。\n1 2 3 4 |29|30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52|53|54|55| ^ ^ ^ |p1 \u0026lt;------- 已发未确认 -------\u0026gt; |p2 \u0026lt;---- 允许但未发 ----\u0026gt;|p3 | \u0026lt;--------------------- 发送窗口 -------------------\u0026gt; | A 在发送时，P2指针会一直向前移动，直到与 p3 重合，但不会超过 p3。如果 p2、p3 重合，就必须停止发送，在超时计时器到时间后，就要重新发送未确认的报文，然后重置超时计时器，如此循环，直到收到 B 的确认报文。\n2、发送缓存和接收缓存\n发送方的应用程序把字节流写入 TCP 的发送缓存，接收方的应用进程从接收缓存中读取字节流。\n关于发送缓存和接收缓存：\n它们的空间都是有限的，且是循环使用的。 实际缓存或这窗口的字节数都是很大的。 3、发送缓存\n存放应用程序传送给发送方 TCP 的准备发送的数据： 存放 TCP 已经发送但是尚未收到确认的数据。1 包含 2 发送窗口是发送缓存的一部分。已经确认的数据应当从缓存中删除。应用程序不应当发送过快，否则会没有空间存放数据。\n4、接收缓存\n存放收到的数据 存放未被应用程序读取的数据（按序到达的部分）。 如果收到的分组被检测到有差错就要丢弃。\n如果应用程序来不及读取到达的数据，那么缓存最终就会被填满，接收窗口就会减小到0；反之，缓存空间就会变大，接收窗口也会变大，但是不会超过缓存。\n5、注意\n虽然发送窗口是由接收窗口设置的，但是统一时刻，这两个窗口是可能不一样的，因为网络传输有延迟。 对于不按序到达的数据，没有明确处理方式，接收方可以完全丢弃，但是浪费资源，一般是临时存储到接收窗口中，然后按序上交到应用程序。 TCP 要求接收方必须有累积确认的功能，这样可以减少开销。接收方也可以在合适的时候发送确认，也可以在发送数据时捎带确认信息。 确认推迟的时间不得超过 0.5 秒。如果收到一连串最大长度的报文端，必须每隔一段时间发送一个确认。 捎带确认信息的情况不常见，因为很少有双向发送的情况。 1.2、超时重传时间的选择 超时重传时间对网络的影响：时间太短，引起不必要的重传，增大网络开销；时间太长，网络利用率减小，传输效率降低。\n1、超时重传时间\n报文段的往返时间 RTT：发送一个报文，记录它的发送时间，和收到相应确认报文的接收时间。这个时间差就是报文段的往返时间 RTT。\nTCP 保留了一个 RTT 的加权平均返回时间 RTTs（S表示Smoothed，因为加权使它更平滑），每次测到新的 RTT 样本时，就计算一下新的 RTTs。 $$ 新的 RTT_s = (1 - \\alpha) \\times (旧的 RTT_s) + \\alpha \\times (新的 RTT 样本) $$ $0 \\le \\alpha \\lt 1$，当 $\\alpha$ 很接近 0，新的 RTTs 和旧的 RTTs 变化不大，（RTT 值更新较慢）；当 $\\alpha$ 接近 1，RTTs 受 RTT 的影响较大，（RTT 值更新较快）。官方建议的 $\\alpha$ 的值是 $\\frac{1}{8}$，也就是 0.125。\n超时重传时间 RTO（RetransmissionTime-Out）: $$ RTO = RTT_s + 4 \\times RTT_D $$ $RTT_D$ 是 RTT 的偏差的加权平均值，它与 $RTT_s$ 和新的 RTT 样本之差有关。建议使用下面的公式计算： $$ 新的 RTT_D = (1 - \\beta) \\times (旧的 RTT_D) + \\beta \\times \\lvert RTT_s - 新的 RTT 样本 \\rvert $$ $\\beta$ 是一个小于 1 的系数，它是推荐值是 $\\frac{1}{4}$，也就是 0.25。\n2、重传确认时间\n如果确认报文丢失，超时后重传计算的超时重传时间会明显增大。如果从重传后开始计算时间，碰到确认延迟的情况，刚重传就收到了确认报文，超时重传时间就会明显减小，这样又会导致更多的报文重传。\n因此，Karn 提出一个算法：在计算加权平均 RTTs 时，只要报文段重传了，就不采用其往返时间样本。这样计算出的加权平均 RTTs 和 RTO 就比较准确。\n但是，这样又会出现新的问题，当网络延时突然增大，规定时间内收不到确认报文，刚刚发出的报文就需要重新发送，然而这些重发的报文是不计入往返时间样本的，这就导致 RTTs 和 RTO 就无法更新。\n所以要对上面的算法修正：每次重传，就将超时重传时间 RTO 增大为原来的 2 倍。\n1.3、选择确认 SACK 当接收方收到了报文无差错，只是没有按序号，接收方是不能发送确认报文的，发送方能否只重发按序到达中缺少的那部分报文？答案是可以。\n例如：接收方收到了几段不连续的报文\n1 2 3 4 5 |1--------1000| |1501--------3000| |3501--------4500| | | |L1 |R1 |L2 |R2 # 边界信息 L1 = 1501, R1 = 3001 L2 = 3501, R2 = 4501 如果要准确告诉对方这些信息，就要使用选择确认SACK描述这些信息。如果使用这个功能，双方一开始就要约定好使用这个选项，原来的 ACK 功能不变。因为 TCP 的首部选项最多只能有 40 字节，所以 SACK 应该按如下安排：\nSACK：1 个字节，指明使用SACK。\n选项长度：1 个字节，指明选项的长度。\n边界信息：一个字节块有 2 个边界，一个边界需要 4 个字节，所以最多可以有 4 个字节块的边界信息。\n","date":"2022-10-31T21:21:51+08:00","permalink":"https://zhuaowei.github.io/article/tcp-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0/","title":"TCP 可靠传输的实现"},{"content":"1、传输控制协议 TCP 概述 1.1、TCP 的主要特点 **TCP 是面向连接的运输层协议。**必须先建立连接，再传送数据，最后断开连接。 每一条TCP 连接只能有两个端点（endpoint），每一条 TCP 连接只能是点对点的。 TCP 提供可靠交付的服务。无差错、不丢失、不重复、按序到达。 TCP 提供双全工通信。 面向字节流。TCP中的**“流”（stream）指的是流入和流出进程的字节序列**。TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。TCP 并不知道所传送的字节流的含义。 一个 TCP 报文段通常包含上千个字节。TCP 连接是一条虚连接。\n虚连接（逻辑连接）：并不是一条真正的物理连接，而是要依靠底层的协议实现，所以是虚连接。\n1.2、TCP 的连接 TCP 把连接作为最基本的抽象。前面提到的端点叫作套接字（socket）或插口，即端口号拼接到IP地址。 $$ 套接字 socket = （IP地址：端口号） $$ 每一条连接唯一地被通信两端的两个端点所确定。即： $$ TCP 连接 ::= {socket1, socket2} = {(IP1:port1), (IP2, port2)} $$\n2、可靠传输的工作原理 2.1、停止等待协议 假设有一个端点发送数据，另一个端点接受数据，分别是A和B。A每次发送完一个分组后，就要等待B发来的确认。\n有以下几种情况：\n1、无差错情况：正常进行\n2、出现差错\n超时重传：A 只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传刚才发过的分组。\n要设置一个超时计时器，每次发送都要设置计时器，如果在规定时间内收到确认就撤销。\n细节问题：\nA 必须暂时保留没收到确认的分组。 分组和确认分组都必须进行编号 超时计时器的重传时间应当比平均往返时间长一些。 3、确认丢失和确认迟到\n确认丢失：如果B给A发送的确认报文丢失了，A就会重传分组，B这时收到重复分组，丢掉分组，重新发送确认。\n确认迟到：如果B发给A的确认报文遇到拥塞，超过了重传计时器的时间，A也会重发分组，B收到重复的分组也是丢掉分组，重新发送确认，A就会收到两份确认，对于第二份确认，A什么也不会做。\n依靠上面的机制，就可以在不可靠的网络上提供可靠通信。而这种可靠传输协议常称为自动重传请求ARQ（Automatic Repeat reQuest）。\n4、信道利用率\n如果像上面说的那样，A发送一个分组，就等待一个确认分组，然后才能发送，那么信道的利用驴就会很低。\n为了提高传输效率，发送方可以不使用停止等待协议，而是采用流水线传输，发送方可以连续发送多个分组。\n2.2、连续ARQ协议 发送方维持一个发送窗口，位于发送窗口内的所有分组都可以发送，不必等待确认。\n发送方每收到一个确认就把发送窗口向前滑动一个分组的位置。\n接收方一般采取累计确认的方式，对于收到的分组，对按序到达的最后一个分组发送确认。\n3、TCP 的报文段的首部格式 TCP 传送的数据单元是报文段。一个TCP报文段分为首部和数据两部分。TCP 的前 20 字节是固定的，后面 4n 字节根据需要增加。\n源端口和目的端口：各占 2 字节。 序号（seq）：占 4 字节，序号循环使用，溢出模后再开始（mod $2^{32}$）。每一个字节都按序号编号，序号指的是本报文数据开始的序号，如果一段报文序号为301，数据长度为100，下个报文的序号为401。 确认号（ack）：占 4 字节，期望收到的下一个报文段的第一个数据字节的序号。 数据偏移：占 4 位，指出报文数据起始处距离报文起始处的长度，其实就是头部的长度，单位是 4 字节。 保留：6 位 紧急URG（urgent）：1 位，URG = 1时有效，要插到最前面发送，配合紧急指针使用。 确认ACK（acknowledgment）：1 位，当 ACK = 1 时，ack 才有效。所以，连接建立后，所有的报文都是 ACK = 1 推送PSH（push）：1 位，设置为 PSH = 1后，发送方立即创建报文发送过去，接收方收到后，立即交付应用进程。 复位RST（reset）：1 位，RST = 1时，说明连接出现了严重差错，必须释放再重新建立连接。也可以用于拒绝连接。 同步SYN（synchronization）：1 位，连接建立时用来同步序号。SYN = 1，ACK = 0 表示请求建立连接，对方回复 SYN = 1,ACK = 1 表示同意。 终止FIN（finis）：1位，FIN = 1 表示发送方的数据已经发送完毕，要求释放连接。 窗口（rwnd，window）：占 2 字节。表示发送方的接受窗口，告诉对方，我还有多少空间可以接受数据（字节位单位）。 检验和：2 字节，检验范围包括首部和数据，计算时，和UDP一样，需要在报文段前面加上12字节的伪首部。 紧急指针：2 字节，只有 URG = 1 时才有意义，指出紧急数据的字节数。 上面 20 字节时固定的。\n选项：长度可变，最长40字节，最后填充只是为了让头部是4字节的整数倍。 MSS（Maximum segment Size）：每一个 TCP 报文段中数据字段的最大长度。\n","date":"2022-10-30T19:58:30+08:00","permalink":"https://zhuaowei.github.io/article/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE-tcp-%E6%A6%82%E8%BF%B0/","title":"传输控制协议 TCP 概述"},{"content":"1、UDP 用户数据报协议 1.1、UDP 概述 主要特点：\nUDP是无连接的，发送前不需要建立连接。 UDP 使用尽最大努力交付，即不保证可靠交付，因为主机不需要维持复杂的连接状态表。 UDP 是面向报文的。对应用层交下来的报文，加个头部就发了，保留这些报文的边界，不做其他处理。 UDP 没有拥塞控制，网络拥塞并不会降低发送速率。 UDP 支持一对一、一对多、多对一和多对多的交互通信。 UDP 的首部开销小，只需要 8 字节。 1.2、UDP 的首部格式 源端口：16 位，需要回复时使用，否则可以全为 0。 目的端口：16 位，交付报文时必须使用。 长度：16 位，UDP用户数据报的长度，最小为 8（只有首部）。 检验和：16 位，检测 UDP 用户数据报在传输中是否有错，如果有就丢弃。 如果目的端口不正确，就丢弃报文，并由网际控制报文协议 ICMP 发送“端口不可达”差错报文给发送方。\nUDP 并不需要使用套接字来建立连接。\n检验和计算：\n在计算前，首先要在报文前面加上 12 字节的伪首部，这个伪首部既不向下传送，也不向上递交，仅作为计算。\n首先将检验和部分全部填 0 ，把伪首部，首部，数据看成是由许多 16 位的字串接起来的，如果数据部分不是偶数个这样的部分，就在末尾添 0（这部分也是不发送的）。然后按二进制反码计算这些16 位字的和，将此和的二进制反码填到检验和。\n在接收方，如果收到的报文是正确的，那么检验和应该全为1，否则就是错的，接收方应该丢弃或者上交，但应该指出是错误的。\n伪首部的结构：\n源 IP 地址：32位 目的 IP 地址：32位 0填充：8位 协议类型：8位，UDP是17，TCP是6。 UDP报文长度：16位。 ","date":"2022-10-30T19:55:16+08:00","permalink":"https://zhuaowei.github.io/article/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE-udp/","title":"用户数据报协议 UDP"},{"content":"1、运输层概述 1.1、进程之间通信 运输层向它上面的应用层提供通信服务，它数据面向通信部分的最高层，同时也是用户功能的最底层。\n端到端的通信不是指主机与主机之间的通信，准确来说，是主机进程之间的通信，而通信的真正端点就是主机中的进程。\n在一台主机中，经常有多个应用进程和其他主机的多个进程之间进行通信，所以运输层需要一个很重要的功能，就是复用（multiplexing）和分用（demultiplexing）。\n运输层提供应用进程间的逻辑通信。逻辑通信的意思是好像通信是沿着水平方向进程的，实际上是依赖底层的协议实现的，他们之间并没有直接的物理连接。\n运输层需要对收到的报文进行差错检测，而 IP 数据报只检验首部。\n根据不同的需求，运输层提供了两种运输协议，即面向连接的TCP和无连接的UDP。\n另外，运输层向高层屏蔽了下面的网络核心的细节他是应用进程看见的就是好像再两个运输层实体之间有一条端到端的逻辑通信信道。\n1.2、运输层的两个主要协议 用户数据报协议UDP（User Datagram Protocol） 传输控制协议TCP（Transmission Control Protocol） 它们对应的运输协议数据单元TPDU（Transport Protocol Data Unit）为UDP用户数据报和TCP报文段（segment）。\n1.3、运输层的端口 复用：应用层所有的应用进程都可以通过运输层再传送到IP层。\n分用：运输层从IP层收到发送给各应用进程的数据后，必须分别交付到指明的各应用进程。\n端口（port）：协议端口号（protocol port number），是用来标志进程的，是应用层的各种协议进程与运输实体进程层间交互的一种地址。\nTCP/IP 使用 16 位端口号来标志一个端口，端口号只具有本地意义。范围 0 - 65535。\n端口号的划分：\n服务器端使用的端口号： 熟知端口号（well-known port number）/系统端口号：0 - 1023，一些比较重要的系统服务进程。 等级端口号：1024 - 49151，也即 $[2^{10}, \\frac{3}{4}\\times2^{16} - 1]$ 客户端使用的端口号：49152 - 65535，也即 $[\\frac{3}{4}\\times2^{16}, 2^{16} - 1]$，只有再客户进程运行时才动态选择，所以又叫短暂端口号。 熟知端口号：\n应用进程 熟知端口号 FTP 21 SSH 22 TELNET 23 SMTP 25 DNS 53 TFTP 69 HTTP 80 SNMP 161 SNMP（trap） 162 HTTPS 443 ","date":"2022-10-30T19:52:27+08:00","permalink":"https://zhuaowei.github.io/article/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/","title":"计算机网络运输层概述"},{"content":"渲染数学公式有两种方式，一种是 mathjax ，另一种是 KaTex，因为 KaTex 比较快，所以使用这种方式。\n具体步骤如下：\n首先创建一个部分的模板文件，里面链上 CSS 文件和 JS 文件，这些脚本会自动将公式渲染。 /layouts/partials/helpers/katex.html。 1 2 3 4 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.css\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/contrib/auto-render.min.js\u0026#34; onload=\u0026#34;renderMathInElement(document.body);\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 不要只顾着复制，看一下版本更新，我写博客的时候已经更新到 0.16.3 了，把版本号替换一下就可以了。\n具体更新看这里 -\u0026gt; update。\n在头文件中引用刚才的模板。 /layouts/partials/head.html 1 {{ if .Params.math }}{{ partial \u0026#34;helpers/katex.html\u0026#34; . }}{{ end }} 在需要渲染数学公式的博客的 frontMatter 中使用 math 参数。 1 2 3 --- math: true --- 如果要使用内联公式样式，还需要添加以下代码： /layouts/partials/helpers/katex.html 1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { renderMathInElement(document.body, { delimiters: [ {left: \u0026#34;$$\u0026#34;, right: \u0026#34;$$\u0026#34;, display: true}, {left: \u0026#34;$\u0026#34;, right: \u0026#34;$\u0026#34;, display: false} ] }); }); \u0026lt;/script\u0026gt; 如果你要使用内联样式，只需要用一个 $ 符号包裹，例如$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}$ 的效果就是这样的：$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}$。\n如果要独占一行居中就要使用两个 $$，而且不能和公式在同一行。\n1 2 3 $$ x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a} $$ 效果如下：\n$$ x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a} $$\nps: 亲测，加不加都可以使用内联样式\nreference: https://mertbakir.gitlab.io/hugo/math-typesetting-in-hugo/\n","date":"2022-10-29T22:16:55+08:00","permalink":"https://zhuaowei.github.io/article/%E5%A6%82%E4%BD%95%E5%9C%A8hugo%E4%B8%AD%E4%BD%BF%E7%94%A8markdown%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/","title":"如何在Hugo中使用markdown的数学公式"},{"content":"1、频分复用、时分复用和统计时分复用 1.1、频分复用： 用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽资源。\n1.2、时分复用： 将时间划分为一段段等长的时分复用帧（TDM帧）每个用户在每个TDM帧中占用固定序号的时隙。\n时分复用的所有用户在不同的时间占用同样的带宽资源。\n1 2 3 | A | B | C | D | A | B | C | D | | | | | \u0026lt;---- TDM 帧 -----\u0026gt; | \u0026lt;---- TDM 帧 -----\u0026gt; | 在通信时，**复用器（multiplexer）和分用器（demultiplexer）**成对使用。\n1.3、统计时分复用 **STDM（Statistic TDM）**是一种改进的时分复用，它能明显提高信道的利用率。集中器（concentrator）常使用这种统计时分复用。\n使用STDM帧来发送数据，每个帧时隙数小于用户数，每个用户往集中器中发送数据，STDM帧中放满了数据就发送出去。\n集中器能正常工作的前提时所有用户都是间歇地工作。\n2、波分复用 其实就是光的频分复用。\n3、码分复用 CDM（Code Division Multiplexing），常用的时码分多址（CDMA，Code Division Multiple Access ）。各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。\n每一个比特时间划分为 m 个短的间隔，称为码片（chip）。使用CDMA的每个站都使用一个唯一的 m bit 的码片序列（chip sequence），而且相互之间需要正交，（相当于手机号）。如果一个站要发送 1，则发送它自己的码片序列，如果要发送 0，则发送它自己的码片序列的反码。\n","date":"2022-10-29T22:06:41+08:00","permalink":"https://zhuaowei.github.io/article/%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF-division-multiplexing/","title":"信道复用技术 Division Multiplexing"},{"content":"1、物理层的基本概念 传输媒体接口的一些特性：\n机械特性：指明接口所用接线器的形状、尺寸、引脚数目和排列、固定和锁定装置等。 电气特性：指明在接口电缆的各条线上出现的电压范围。 功能特性：指明某条线上出现的某一电平的电压的意义。 过程特性：指明对于不同功能的各种可能事件的出现顺序。 计算机内部是并行传输、在通信线路上是串行传输，所以物理层还要完成传输方式的转换。\n2、数据通信基本常识 2.1、数据通信系统的模型 一个数据通信系统合一划分为三大部分：源系统（或者发送端、发送方）、传输系统（或传输网络）和目的系统（或接收端、接收方）。\n源点（source，源站、信源）：源点设备产生要传输的数据，计算机产生的数字比特流。 发送器：通常源点产生的数字比特流需要通过发送器编码后才能够在传输系统中传输。典型的发送器就是调制器。 接收器：将传输系统传统过来的信号转换成能够被目的设备处理的信息。典型的接收器就是解调器。 终点（destination，目的站、信宿）：终点设备接受从接收器传输过来的数字比特流，然后把信息输出。 消息（message）：文字、语音、图像、视频等。通信的目的是传送消息。\n数据（data）：是运送消息的实体。数据是使用特定方式标识的信息，通常是有意义的符号序列。\n信号的分类：\n模拟信号（连续信号）：代表消息的参数的取值是连续的。 数字信号（离散信号）：代表消息的参数的取值是离散的。 码元：在使用时间域（或者简称为时域）的波性标识数字信号时，代表不同离散数值的基本波性就成为码元。\n二进制时只有两种码元：一种代表0，另一种代表1。\n2.2、有关通信的基本概念 通信的基本方式：\n单向通信（单工通信）：只有一个方向的通信。 双向交替通信（半双工通信）：同时只能有一个方向的通信，不能同时发送或者接收。 双向同时通信（双全工通信）：双方可以同时发送和接受信息。 单工通信只使用一条信道，而半双工和双全工需要两条信道。双全工效率最高。\n来自信源的基带信号通常包含较多低频成分，甚至有直流成分，而信道并不能传输这些，所以必须对基带信号进行调制。\n调制（Modulation）：将数字信号调制成模拟信号。\n基带调制：仅对基带信号的波性进行变换。\n带通调制：使用载波（carrier），把基带信号的频率范围搬移到较高的频段，并转换成模拟信号。\n常用编码方式：\n不归零制：正电平代表1，负电平代表0。 归零制：正脉冲代表1，负脉冲代表0。 曼彻斯特编码：位周期中心向上跳变代表0，位周期中心向下跳变代表1。 差分曼彻斯特编码：位开始边界有跳变代表1，位开始边界没有跳变代表0。 基本带通调制方法：\n调幅（AM, Amplitude Modulation）：载波的振幅随基带数字信号而变化。 调频（FM, Frequency Modulation）：载波的频率随基带数字信号而变化。 调相（PM, Phase Modulate）：载波的初识相位随基带数字信号而变化。 正交振幅调制（QAM，Quadrature Amplitude Modulation）：混合调制方法，提高传输速率。\n2.3、信道的极限容量 虽然信号在信道中会失真，但是只要接收端能够识别出原来的信号，那么这种失真就对通信质量无影响。\n码元传输的速率越高，或者信号传输的距离越远，或者噪声干扰越大，或者传输媒体质量越差，在接收端的波性失真就越严重。\n奈氏准则：在任何信道中，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间串扰的问题，使接收端对码元的判决成为不可能。 信噪比：信号的平均功率和噪声的平均功率之比。记为 S/N，单位分贝（dB）。 $$ 信噪比(dB) = 10 log_{10}{(S/N)} (dB) $$\n香农公式：信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。 $$ C = W log_{2}{(1 + S/N)} $$\nC：信道的极限信息传输速率。\n为了提高信息的传输速率，用编码的方法让每一个码元携带更多比特的信息量。\n3、物理层下面的传输媒体 3.1、导引型传输媒体 1、双绞线\n定义：也叫双纽线，最古老但又最常见的传输媒体。就是两根互相绝缘，按规则绞合的线。绞合可以减少相邻导线的电磁干扰。\n为了提高抗干扰能力，在双绞线的外面再套一层金属丝编织成的屏蔽层，这就是屏蔽双绞线（STP）。\n2、同轴电缆\n定义：由内导体铜质芯线（单股实心线或多股绞合线）、绝缘层、网状编织的外导体屏蔽层一级保护塑料外层锁组成。由于外导体屏蔽层的作用，具有更好地抗干扰特性，广泛用于较高速率的传输。\n3、光缆\n定义：由非常透明的石英玻璃拉成细丝，主要由纤芯和包层构成双层通信圆柱体。\n发射端使用发光二极管发出光脉冲，接收端用光电二极管做成检测器，还原电脉冲。\n可以存在多条不同角度入射的光线在一条光纤中传输，这种就叫作多模光纤。如果只有细到只有一个光波传输，而不会产生反射，就叫作单模光纤。\n优点：\n通信容量大。 传输损耗小，适合远距离传输。 抗雷电和电磁干扰性能好。 无串音干扰，保密性好。 体积小，重量轻。 3.2、非导引型传输媒体 无线传输可以使用的频段很广，根据频率可以将通信进行划分：\n低频LF：（30kHz - 300kHz，波长：1km - 10 km）\n中频MF：（300kHz - 3MHz）\n高频HF：（30MHz - 30MHz）\n甚高频（V，Very）：（30MHz - 300MHz）\n特高频（U，Ultra）：（300MHz - 3GHz）\n超高频（S，Super）：（3GHz - 30GHz）\n极高频（E，Extremely）：（30GHz - 300GHz）\n","date":"2022-10-29T22:01:32+08:00","permalink":"https://zhuaowei.github.io/article/%E7%89%A9%E7%90%86%E5%B1%82%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/","title":"物理层的基本概念与常识"},{"content":"1、FTP 概述 使用最广泛的文件传输协议。FTP和 TFTP都是文件共享协议中的一大类，即复制整个文件。若要存取一个文件，必须先获取一个本地的文件副本。若要修改文件，只能对文件的副本进行修改，然后再将修改后的文件副本传回到原节点。\n另一大类是联机访问（on-line access）。联机访问意味着允许多个程序同时对一个文件进行存取，它是由操作系统提供对远地共享文件访问的服务，就如同对本地文件的访问一样。这就使用户可以用远地文件作为输入和输出来运行任何应用程序，而操作系统中的文件系统则提供对共享文件的透明存取。\n透明存取的优点是：将来用于处理本地文件的应用程序用来处理远地文件时，不需要对改应用程序作明显的改动。\n2、FTP 的基本工作原理 FTP 只提供文件传送的基本服务，使用 TCP 可靠的运输服务。\nFTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。\n一个 FTP 服务进程可以为多个客户提供服务。FTP 的服务器进程有两大部分组成：一个主进程，负责接受新的请求；若干个从属进程，负责处理单个请求。\n主进程的工作步骤：\n打开21端口 等待用户连接 启动从属进程处理请求。从属进程处理完毕后终止，工作中可能会开启其他子进程。 回到等待状态，继续接受请求。主从进程处理是并发的。 FTP 的工作情况：\n工作时有两个从属进程：控制进程和数据传送进程。这两个是并行的 TCP 连接：控制连接和数据连接。请求和控制信息通过控制连接；数据传送通过数据连接。\n3、简单文件传送协议 TFTP TFTP（Trivial File Transfer Protocol），使用UDP协议实现的很小的易于实现的文件传送协议。\n优点：\n可用于UDP环境 代码所占内存小 主要特点：\n每次传送的数据报文中有512字节数据，最后一次可以不足512. 报文按序号编号，从1开始 支持ASCII码或者二进制传送 可对文件进行读写。 首部简单。 工作步骤：\n客户端向服务端（端口69）发送一个读或者写的请求报文，服务端另开一个端口给客户端通信。如果最后一个报文的数据部分正好是512字节，则还需要发送一个无数据部分的报文，作为结束标志；如果不足512字节，就不用发送了，因为不足512已经是结束标志了。\n差错改正措施：\n服务端每次发完一个文件块之后，都会等待一个确认的报文，报文指明所确认的编号。如果在规定时间内收不到确认报文，就会重发数据PDU；如果客户端在发完确认报文后，在规定时间内没有收到下一个文件块，也要重新发送确认报文。\n发送方：收不到确认报文，重发文件块\n接收方：收不到下一个文件块，重发确认报文\n","date":"2022-10-29T21:54:13+08:00","permalink":"https://zhuaowei.github.io/article/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-ftp/","title":"文件传输协议 FTP"},{"content":"尚硅谷Java面试题第一季第03节\n一、代码 Father.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Father { private int i = test(); private static int j = method(); static { System.out.println(\u0026#34;(1)\u0026#34;); } Father() { System.out.println(\u0026#34;(2)\u0026#34;); } { System.out.println(\u0026#34;(3)\u0026#34;); } public int test() { System.out.println(\u0026#34;(4)\u0026#34;); return 1; } public static int method() { System.out.println(\u0026#34;(5)\u0026#34;); return 1; } } Son.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class Son extends Father { private int i = test(); private static int j = method(); static { System.out.println(\u0026#34;(6)\u0026#34;); } Son() { System.out.println(\u0026#34;(7)\u0026#34;); } { System.out.println(\u0026#34;(8)\u0026#34;); } @Override public int test() { System.out.println(\u0026#34;(9)\u0026#34;); return 1; } public static int method() { System.out.println(\u0026#34;(10)\u0026#34;); return 1; } public static void main(String[] args) { Son s1 = new Son(); System.out.println(); Son s2 = new Son(); } } 结果是：(5)(1)(10)(6)(9)(3)(2)(9)(8)(7) (9)(3)(2)(9)(8)(7)\n二、结果分析 main 方法中调用了两次 new Son()，总共发生了一次类初始化和两次对象初始化。\n2.1、类初始化 类初始化是当类遇到需要初始化的时候根据包名将类进行加载、连接、初始化的过程，而连接又分为验证、准备、解析三个阶段。\n关于类加载的条件《Java虚拟机规范》值给出了6中必须加载的情况，其中之一就是上面的 new 关键字。其实 new 关键字在解析为字节码文件后生成了new字节码指令，这个才是具体的需要加载的条件。\nmain() 方法所在的类需要先初始化\n当一个类的需要初始化时，会先检查其父类有没有初始化，如果没有，就先初始化父类。\n在类初始化过程中，类加载器会执行 \u0026lt;clinit\u0026gt; 方法，这个方法是java帮我们自动生成的，它包含类中所有静态变量的赋值代码和静态块，这些代码是按照上下文的顺序执行的。\n因此首先初始化 main() 方法所在的 Son 类，然而 Son 类的父类还没有初始化，所以先初始化 Father 类。\n1 2 3 4 5 6 1. Father.\u0026lt;clinit\u0026gt; j = method(); // (5) System.out.println(\u0026#34;(1)\u0026#34;); // (1) 2. Son.\u0026lt;clinit\u0026gt; j = method(); (10) System.out.println(\u0026#34;(6)\u0026#34;); // (6) 2.2、对象初始化 类初始化完毕后就是对象初始化，对象初始化也有 \u0026lt;init\u0026gt; 方法，类中有几个构造函数就有几个 \u0026lt;init\u0026gt; 方法，创建对象实例时调用对应的 \u0026lt;init\u0026gt; 方法。\n\u0026lt;init\u0026gt; 方法的内容：\nspuer.\u0026lt;init\u0026gt;（最前）：首先它包含父类的构造方法，无论写或不写都会有，它放在子类构造器的最前面。\n非静态的变量赋值代码\n非静态代码块\n子类构造器中的内容（最后）\n2和3按代码书写顺序执行。\n所以创建子类实例时，先执行父类的 \u0026lt;init\u0026gt; 方法，再执行子类的 \u0026lt;init\u0026gt; 方法。\n1 2 3 4 5 6 7 8 1. Father.\u0026lt;init\u0026gt; i = test(); // 9，因为子类重写了父类的方法，所以执行的是子类的test()方法 System.out.println(\u0026#34;(3)\u0026#34;); // 3 Father(); // 2 2. Son.\u0026lt;init\u0026gt; i = test(); // 9 System.out.println(\u0026#34;(8)\u0026#34;); // 8 Son(); // 7 创建对象实例时，执行类中非静态方法的前面都有一个关键字 this，指代的就是子类对象本身，当初始化父类对象时，test() 执行的时被子类重写的 test()。\n所以结果是：(9)(3)(2)(9)(8)(7)\n2.3、子类继承和重写 哪些方法不可以被重写：\nfinal 修饰的方法\n静态方法\nprivate 等子类中不可见的方法\n方法的多态：\n如果子类重写了父类的方法，通过子类对象调用时，调用的就是重写后的代码。\n非静态方法默认的调用对象是 this。\nthis在构造器或者 \u0026lt;init\u0026gt; 方法中就是构造的对象本身。\n","date":"2022-09-30T15:17:44+08:00","permalink":"https://zhuaowei.github.io/article/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/","title":"类初始化及创建过程中，代码的执行顺序"},{"content":"前言\n今天复习计算机操作系统，网上的博客只提了一嘴，没有详细写，所以我就找到以前的课本重新复习了一遍，顺便记下来，以免忘记。详细参考了《计算机组成原理（第3版）蒋本珊 编著》。\n所谓寻址，就是找到操作数的地址或者下一条指令的地址。首先先看一下编址的方式。\n一、计算机的编址方式 编址就是对计算机的各种存储设备进行编码，这些设备主要就是各种寄存器和内存。\n编址就像将存储设备中的一个个小的存储单元按一定的规则编号，根据单元的大小就有不同的编址方式。目前常用的编址方式有字编址、字节编址和位编址。\n字编址：字就是参与运算的最基本的数， 由加法器、寄存器的位数决定。因此，每执行一条指令，程序计数器就加1，所以这种编址方式最为简单。如果寄存器是32位的，那么一个字就是32位。\n字节编址：最普遍的编址方式，一个字节为一个编址单位。如果指令是32位的，那么每执行一条指令，程序计数器就会加4。\n思考：为什么32位的计算机最大内存不超过4GB？\n现在大多数计算机使用的编址方式是按字节编址，32位可以标识的最大的数就是 $2 ^ {32}$ ，一个编址单位是 1 字节，也就是 1B ，32位最多能表示 $2 ^ {32}$ B ，也就是 4GB。目前绝大部分计算机的内存最少也是8GB，所以这些计算机肯定是64位的。\n按位编址：一个比特位一个编址单位，这种编址方式只有巨型计算机才会用，效率比按字节编址更低。 二、寻址类型和寻址方式 寻址类型可以根据要寻的目标分为数据寻址和指令寻址。\n寻址方式可大致分为顺序寻址和跳跃寻址。\n顺序寻址：程序计数器自动加1。\n跳跃寻址：通过程序转移类指令来实现。根据转移的方式又可分为3种：\na. 直接寻址\nb. 间接寻址\nc. 相对寻址\n三、寻址方式 真是千呼万唤始出来啊，终于到了详细的寻址方式了。\n立即寻址：指令中直接饱含了操作数，这个数叫作立即数。优点是可以直接取数，速度快。缺点是在指令中，无法修改，也受指令位数的限制。\n寄存器寻址：指令中存放着寄存器的地址，通过这个地址在相应的寄存器中可以找到操作数。\n直接寻址：指令中存放的是操作数在内存中的地址。\n间接寻址：指令中存放的是操作数在内存中地址的地址。就是拿着地址从内存中找到一个地址，再用这个地址在内存中找到操作数。\n这个间接寻址还可以套娃，上面的在指令和操作数中间隔了一次寻址，叫作一级间接寻址，还有二级、三级。也不会套很多层，因为很麻烦。\n间接寻址可以让指令中的寻址范围扩大。因为指令中存放着指令和地址，地址位数不足以查找整个内存的，只能访问一部分数据，而这一部分数据可以寻址的范围是整个内存，所以寻址的范围扩大了。\n寄存器间接寻址：跟上面的一级间接寻址类似，不过中间地址是存放在寄存器中的。\n变址寻址：把变址寄存器中的地址与指令中的形式地址相加，就得到了操作数在内存中的地址。适合顺序存储的数组和字符串等。\n基址寻址：与变址寻址类似，是将基址寄存器中的地址与指令中的位移量相加得出操作数的有效地址。\n变址寻址和基址寻址有何区别？\n变址寻址是变址寄存器提供的修改量，是可变的，指令中提供的基准值是固定的；而基址寄存器提供的基准值是不可变的，指令中提供的位移量是可变的。\n变址寻址面向的是用户，用于数组、字符串和向量等批数据；基址寻址面向的是系统，主要用于逻辑地址和物理地址的变换等。\n相对寻址：相对寻址是基址寻址的一种变通，它是由PC提供基准值，指令提供位移量，这个位移量可正可负，所以最终寻址可能在基准值的前或者后。\n页面寻址：将主存分为若干个大小相同的区，也叫页，每个页再分为若干个大小相同的主存单元，每个页都有自己的编号，叫页面地址；页内每个主存单元也有自己的编号，叫作页内地址。例如64KB的内存空间被分为256个页面，每个页面中又有256个主存单元。寻址时，用前8位表示页面地址，后8位表示页内地址，两者一拼凑就行成了内存地址。\n页面寻址的页内地址一般直接来源于指令，而根据页面地址的不同可以将页面寻址再次分为3种：\na. 基页寻址：也叫零页寻址，因为页面地址全是0，所以操作数在零页面中，相当于直接寻址。\rb. 当前页寻址：页面地址就等于PC的高位部分的内容，操作数与指令本身处于同一页面中。\rc. 页寄存器寻址：页面地址取自页寄存器。\r除了这9中寻址方式之外，还有几种更为复杂的寻址方式，其实就是这9中的变形或组合。计算机中寻址方式不只一种，一般是几种寻址方式互相组合来达到更高的效率。\n","date":"2022-09-25T20:56:50+08:00","permalink":"https://zhuaowei.github.io/article/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%ADcpu%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/","title":"操作系统中CPU的寻址方式总结"},{"content":"一直想自己搭建一个博客，但是碍于实力与审美，还有自己太懒了，于是就使用Hugo搭建了一个自己的博客。\n环境：centos7\n下面是具体的折腾流程：\n一、安装Hugo 安装Golang\nHugo是用Go写的，所以首先应该安装Golang。\n1 2 3 4 sudo yum -y install golang # 查看安装的版本 go version 添加yum源\n直接安装找不到安装包，需要先添加yum源。创建下面的文件，然后把内容粘上去。\nsudo vim /etc/yum.repos.d/hugo.repo\n1 2 3 4 5 6 7 8 9 [daftaupe-hugo] name=Copr repo for hugo owned by daftaupe baseurl=https://copr-be.cloud.fedoraproject.org/results/daftaupe/hugo/epel-7-$basearch/ type=rpm-md skip_if_unavailable=True gpgcheck=1 gpgkey=https://copr-be.cloud.fedoraproject.org/results/daftaupe/hugo/pubkey.gpg repo_gpgcheck=0 enabled=1 安装Hugo\n1 2 3 sudo yum install -y hugo # 查看Hugo的版本 hugo version 二、创建一个站点 创建站点 一个站点就是一个网站，创建好站点后就可以对这个站点进行配置。\n1 hugo new site \u0026lt;mysite\u0026gt; 添加主题\n我用的主题是hugo-paper，非常简洁，适合展示代码，还有明暗两种主题。\n1 2 3 4 # 进入站点根目录 cd mysite # 下载主题到主题目录 git clone https://github.com/nanxiaobei/hugo-paper.git themes/paper 修改配置，配置文件在站点根目录，叫 config.toml\n1 theme = \u0026#34;paper\u0026#34; 还可以复制主题paper文件夹下的配置，根据自己的需要修改配置。\n配置中的 baseURL 是你将来访问站点的URL，一些网页内的页面跳转需要用到，不要写错。 目前使用的主题不是Paper，而是 hugo-theme-stack，这个主题默认的功能比较多，也比较好看，推荐使用。 添加内容\n给站点添加一些文章。\n1 hugo new post/first.md 这样就创建了一个文章，文章开头 --- 之间的是文章的信息，不会显示在网页上。\n文章内容在最后的 --- 下面添加。\n所有的文章都保存在 content 目录下，一个 content 可以有多个 section，也就是多个文件夹，方便管理文章。\n构建\n添加完内容之后就可以生成静态的网页内容了。\n1 2 # 必须在站点的根目录执行。 hugo 这样就生成了博客的静态页面，生成的内容放在了 public 目录下。\n三、部署页面 我使用的是 nginx 部署的静态页面。修改 Nginx 配置：\nsudo vim /usr/local/nginx/conf/nginx.conf\n1 2 3 4 5 6 7 8 9 10 11 # 添加或修改一个server server { listen 80; server_name \u0026lt;yoursite.com\u0026gt;; # 一会儿你要把生成的内容放在这个目录下 root \u0026lt;path/to/site\u0026gt;; location / { index index.html index.htm; } } 将 public 目录下的内容复制到配置的 root 目录下，重新加载Nginx配置 service nginx reload。\n好了，这个时候访问自己的网站就可以看到博客的内容了。\n","date":"2022-08-10T21:13:55+08:00","permalink":"https://zhuaowei.github.io/article/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","title":"第一次使用Hugo搭建博客"}]